









import type { StandardSchemaV1 } from '@standard-schema/spec';

declare namespace Joi {
    type Types =
        | 'any'
        | 'alternatives'
        | 'array'
        | 'boolean'
        | 'binary'
        | 'date'
        | 'function'
        | 'link'
        | 'number'
        | 'object'
        | 'string'
        | 'symbol';

    type BasicType = boolean | number | string | any[] | object | null;

    type LanguageMessages = Record<string, string | Record<string, string>>;

    type PresenceMode = 'optional' | 'required' | 'forbidden';

    interface ErrorFormattingOptions {
        
        escapeHtml?: boolean;
        
        label?: 'path' | 'key' | false;
        
        language?: keyof LanguageMessages;
        
        render?: boolean;
        
        stack?: boolean;
        
        wrap?: {
            
            label?: string | false,

            
            array?: string | false

            
            string?: string | false
        };
    }

    interface BaseValidationOptions {
        
        abortEarly?: boolean;
        
        allowUnknown?: boolean;
        
        artifacts?: boolean;
        
        cache?: boolean;
        
        context?: Context;
        
        convert?: boolean;
        
        dateFormat?: 'date' | 'iso' | 'string' | 'time' | 'utc';
        
        debug?: boolean;
        
        errors?: ErrorFormattingOptions;
        
        externals?: boolean;
        
        noDefaults?: boolean;
        
        nonEnumerables?: boolean;
        
        presence?: PresenceMode;
        
        skipFunctions?: boolean;
        
        stripUnknown?: boolean | { arrays?: boolean; objects?: boolean };
    }

    interface ValidationOptions extends BaseValidationOptions {
        
        messages?: LanguageMessages;
    }

    interface AsyncValidationOptions extends ValidationOptions {
        
        artifacts?: boolean;
        
        warnings?: boolean;
    }

    interface LanguageMessageTemplate {
        source: string;
        rendered: string;
    }

    interface ErrorValidationOptions extends BaseValidationOptions {
        messages?: Record<string, LanguageMessageTemplate>;
    }

    interface RenameOptions {
        
        alias?: boolean;
        
        multiple?: boolean;
        
        override?: boolean;
        
        ignoreUndefined?: boolean;
    }

    interface TopLevelDomainOptions {
        
        allow?: Set<string> | string[] | boolean;
        
        deny?: Set<string> | string[];
    }

    interface HierarchySeparatorOptions {
        
        separator?: string | false;
    }

    interface DependencyOptions extends HierarchySeparatorOptions {
        
        isPresent?: (resolved: any) => boolean;
    }

    interface EmailOptions {
        
        allowFullyQualified?: boolean;
        
        allowUnicode?: boolean;
        
        allowUnderscore?: boolean;
        
        ignoreLength?: boolean;
        
        multiple?: boolean;
        
        separator?: string | string[];
        
        tlds?: TopLevelDomainOptions | false;
        
        minDomainSegments?: number;
        
        maxDomainSegments?: number;
    }

    interface DomainOptions {
        
        allowFullyQualified?: boolean;
        
        allowUnicode?: boolean;
        
        allowUnderscore?: boolean;
        
        tlds?: TopLevelDomainOptions | false;
        
        minDomainSegments?: number;
        
        maxDomainSegments?: number;
    }

    interface HexOptions {
        
        byteAligned?: boolean;
        
        prefix?: boolean | 'optional';
    }

    interface IpOptions {
        
        version?: string | string[];
        
        cidr?: PresenceMode;
    }

    type GuidVersions = 'uuidv1' | 'uuidv2' | 'uuidv3' | 'uuidv4' | 'uuidv5' | 'uuidv6' | 'uuidv7' | 'uuidv8';

    interface GuidOptions {
        version?: GuidVersions[] | GuidVersions;
        separator?: boolean | '-' | ':';
        
        wrapper?: true | false | '[' | '{' | '(' | undefined;
    }

    interface UriOptions {
        
        scheme?: string | RegExp | Array<string | RegExp>;
        
        allowRelative?: boolean;
        
        relativeOnly?: boolean;
        
        allowQuerySquareBrackets?: boolean;
        
        domain?: DomainOptions;
        
        encodeUri?: boolean;
    }

    interface DataUriOptions {
        
        paddingRequired?: boolean;
    }

    interface Base64Options extends Pick<DataUriOptions, 'paddingRequired'> {
        
        urlSafe?: boolean;
    }

    interface SwitchCases {
        
        is: SchemaLike;
        
        then: SchemaLike;
    }

    interface SwitchDefault {
        
        otherwise: SchemaLike;
    }

    interface WhenOptions<ThenSchema = any, OtherwiseSchema = any> {
        
        is?: SchemaLike;

        
        not?: SchemaLike;

        
        then?: SchemaLike<ThenSchema>;

        
        otherwise?: SchemaLike<OtherwiseSchema>;

        
        switch?: Array<SwitchCases | SwitchDefault>;

        
        break?: boolean;
    }

    interface WhenSchemaOptions<ThenSchema = any, OtherwiseSchema = any> {
        
        then?: SchemaLike<ThenSchema>;
        
        otherwise?: SchemaLike<OtherwiseSchema>;
    }

    interface Cache {
        
        set(key: any, value: any): void;

        
        get(key: any): any;
    }
    interface CacheProvisionOptions {
        
        max: number;
    }

    interface CacheConfiguration {
        
        provision(options?: CacheProvisionOptions): void;
    }

    interface CompileOptions {
        
        legacy: boolean;
    }

    interface IsSchemaOptions {
        
        legacy: boolean;
    }

    interface ReferenceOptions extends HierarchySeparatorOptions {
        
        adjust?: (value: any) => any;

        
        map?: Array<[any, any]>;

        
        prefix?: {
            
            global?: string;

            
            local?: string;

            
            root?: string;
        };

        
        ancestor?: number;

        
        in?: boolean;

        
        iterables?: boolean;

        
        render?: boolean;
    }

    interface StringRegexOptions {
        
        name?: string;

        
        invert?: boolean;
    }

    interface RuleOptions {
        
        keep?: boolean;

        
        message?: string | LanguageMessages;

        
        warn?: boolean;
    }

    interface ErrorReport extends Error {
        code: string;
        flags: Record<string, ExtensionFlag>;
        path: string[];
        prefs: ErrorValidationOptions;
        messages: LanguageMessages;
        state: State;
        value: any;
        local: any;
    }

    interface ValidationError extends Error {
        name: 'ValidationError';

        isJoi: boolean;

        
        details: ValidationErrorItem[];

        
        annotate(stripColors?: boolean): string;

        _original: any;
    }

    interface ValidationErrorItem {
        message: string;
        path: Array<string | number>;
        type: string;
        context?: Context;
    }

    type ValidationErrorFunction = (errors: ErrorReport[]) => string | ValidationErrorItem | Error | ErrorReport[];

    interface ValidationWarning {
        message: string;

        details: ValidationErrorItem[];
    }

    type ValidationResult<TSchema = any> = {
        error: undefined;
        warning?: ValidationError;
        value: TSchema;
    } | {
        error: ValidationError;
        warning?: ValidationError;
        value: any;
    }

    interface CreateErrorOptions {
        flags?: boolean;
        messages?: LanguageMessages;
    }

    interface ModifyOptions {
        each?: boolean;
        once?: boolean;
        ref?: boolean;
        schema?: boolean;
    }

    interface MutateRegisterOptions {
        family?: any;
        key?: any;
    }

    interface SetFlagOptions {
        clone: boolean;
    }

    interface CustomHelpers<V = any> {
        schema: ExtensionBoundSchema;
        state: State;
        prefs: ValidationOptions;
        original: V;
        warn: (code: string, local?: Context) => void;
        error: (code: string, local?: Context, localState?: State) => ErrorReport;
        message: (messages: LanguageMessages, local?: Context) => ErrorReport;
    }

    type CustomValidator<V = any, R = V> = (value: V, helpers: CustomHelpers<R>) => R | ErrorReport;

    interface ExternalHelpers<V = any> {
        schema: ExtensionBoundSchema;
        linked: ExtensionBoundSchema | null;
        state: State;
        prefs: ValidationOptions;
        original: V;
        warn: (code: string, local?: Context) => void;
        error: (code: string, local?: Context) => ErrorReport;
        message: (messages: LanguageMessages, local?: Context) => ErrorReport;
    }

    type ExternalValidationFunction<V = any, R = V> = (value: V, helpers: ExternalHelpers<R>) => R | undefined;

    type Primitives = string | number | boolean | bigint | symbol | null;

    type SchemaLikeWithoutArray<TSchema = any> = Exclude<
      (Primitives | Schema<TSchema> | SchemaMap<TSchema>),
      any[]
    >;
    type SchemaLike<TSchema = any> = SchemaLikeWithoutArray<TSchema> | object;

    type NullableType<T> = undefined | null | T

    type IsPrimitiveSubset<T> =
        [T] extends [string]
        ? true
        : [T] extends [number]
        ? true
        : [T] extends [bigint]
        ? true
        : [T] extends [boolean]
        ? true
        : [T] extends [symbol]
        ? true
        : [T] extends [null]
        ? true
        : [T] extends [undefined]
        ? true
        : false;

    type IsUnion<T, U extends T = T> =
      T extends unknown ? [U] extends [T] ? false : true : false;

    type IsNonPrimitiveSubsetUnion<T> = true extends IsUnion<T> ? true extends IsPrimitiveSubset<T> ? false : true : false;

    type ObjectPropertiesSchema<T = any> =
        true extends IsNonPrimitiveSubsetUnion<Exclude<T, undefined | null>>
        ? Joi.AlternativesSchema
        : T extends NullableType<string>
        ? Joi.StringSchema
        : T extends NullableType<number>
        ? Joi.NumberSchema
        : T extends NullableType<bigint>
        ? Joi.NumberSchema
        : T extends NullableType<boolean>
        ? Joi.BooleanSchema
        : T extends NullableType<Date>
        ? Joi.DateSchema
        : T extends NullableType<Buffer>
        ? Joi.BinarySchema
        : T extends NullableType<Array<any>>
        ? Joi.ArraySchema
        : T extends NullableType<object>
        ? (StrictSchemaMap<T> | ObjectSchema<T>)
        : never

    type PartialSchemaMap<TSchema = any> = {
        [key in keyof TSchema]?: SchemaLike | SchemaLike[];
    }

    type StrictSchemaMap<TSchema = any> =  {
        [key in keyof TSchema]-?: ObjectPropertiesSchema<TSchema[key]>
    };

    type SchemaMap<TSchema = any, isStrict = false> = isStrict extends true ? StrictSchemaMap<TSchema> : PartialSchemaMap<TSchema>

    type Schema<P = any> =
        | AnySchema<P>
        | ArraySchema<P>
        | AlternativesSchema<P>
        | BinarySchema<P>
        | BooleanSchema<P>
        | DateSchema<P>
        | FunctionSchema<P>
        | NumberSchema<P>
        | ObjectSchema<P>
        | StringSchema<P>
        | LinkSchema<P>
        | SymbolSchema<P>;

    type SchemaFunction = (schema: Schema) => Schema;

    interface AddRuleOptions {
        name: string;
        args?: {
            [key: string]: any;
        };
    }

    interface GetRuleOptions {
        args?: Record<string, any>;
        method?: string;
        name: string;
        operator?: string;
    }

    interface SchemaInternals {
        
        $_super: Schema;

        
        $_terms: Record<string, any>;

        
        $_addRule(rule: string | AddRuleOptions): Schema;

        
        $_compile(schema: SchemaLike, options?: CompileOptions): Schema;

        
        $_createError(
            code: string,
            value: any,
            context: Context,
            state: State,
            prefs: ValidationOptions,
            options?: CreateErrorOptions,
        ): Err;

        
        $_getFlag(name: string): any;

        
        $_getRule(name: string): GetRuleOptions | undefined;

        $_mapLabels(path: string | string[]): string;

        
        $_match(value: any, state: State, prefs: ValidationOptions): boolean;

        $_modify(options?: ModifyOptions): Schema;

        
        $_mutateRebuild(): this;

        $_mutateRegister(schema: Schema, options?: MutateRegisterOptions): void;

        
        $_property(name: string): any;

        
        $_reach(path: string[]): Schema;

        
        $_rootReferences(): any;

        
        $_setFlag(flag: string, value: any, options?: SetFlagOptions): void;

        
        $_validate(value: any, state: State, prefs: ValidationOptions): ValidationResult;
    }

    interface AnySchema<TSchema = any> extends SchemaInternals, StandardSchemaV1<TSchema> {
        
        _flags: Record<string, any>;

        
        $: this;

        
        ruleset: this;

        type?: Types | string;

        
        allow(...values: any[]): this;

        
        alter(targets: Record<string, (schema: this) => Schema>): this;

        
        artifact(id: any): this;

        
        bind(): this;

        
        cache(cache?: Cache): this;

        
        cast(to: 'map' | 'number' | 'set' | 'string'): this;

        
        concat(schema: this): this;

        
        custom(fn: CustomValidator, description?: string): this;

        
        default(value?: BasicType | Reference | ((parent: any, helpers: CustomHelpers) => BasicType | Reference)): this;

        
        describe(): Description;

        
        description(desc: string): this;

        
        disallow(...values: any[]): this;

        
        empty(schema?: SchemaLike): this;

        
        equal(...values: any[]): this;

        
        error(err: Error | ValidationErrorFunction): this;

        
        example(value: any, options?: { override: boolean }): this;

        
        exist(): this;

        
        external(method: ExternalValidationFunction, description?: string): this;

        
        extract(path: string | string[]): Schema;

        
        failover(value: any): this;

        
        forbidden(): this;

        
        fork(key: string | string[] | string[][], adjuster: SchemaFunction): this;

        
        id(name?: string): this;

        
        invalid(...values: any[]): this;

        
        isAsync(): boolean;

        
        keep(): this;

        
        label(name: string): this;

        
        message(message: string): this;

        
        messages(messages: LanguageMessages): this;

        
        meta(meta: object): this;

        
        not(...values: any[]): this;

        
        note(...notes: string[]): this;

        
        only(): this;

        
        optional(): this;

        
        options(options: ValidationOptions): this;

        
        prefs(options: ValidationOptions): this;

        
        preferences(options: ValidationOptions): this;

        
        presence(mode: PresenceMode): this;

        
        raw(enabled?: boolean): this;

        
        required(): this;

        
        rule(options: RuleOptions): this;

        
        shared(ref: Schema): this;

        
        strict(isStrict?: boolean): this;

        
        strip(enabled?: boolean): this;

        
        tag(...tags: string[]): this;

        
        tailor(targets: string | string[]): Schema;

        
        unit(name: string): this;

        
        valid(...values: any[]): this;

        
        validate(value: any, options?: ValidationOptions): ValidationResult<TSchema>;

        
        validateAsync<TOpts extends AsyncValidationOptions>(
          value: any,
          options?: TOpts
        ): Promise<
          TOpts extends { artifacts: true } | { warnings: true }
            ? { value: TSchema } & (TOpts extends { artifacts: true }
            ? { artifacts: Map<any, string[][]> }
            : {}) &
            (TOpts extends { warnings: true }
              ? { warning: ValidationWarning }
              : {})
            : TSchema
          >;

        
        warn(): this;

        
        warning(code: string, context: Context): this;

        
        when(ref: string | Reference, options: WhenOptions | WhenOptions[]): this;

        
        when(ref: Schema, options: WhenSchemaOptions): this;
    }

    interface Description {
        type?: Types | string;
        label?: string;
        description?: string;
        flags?: object;
        notes?: string[];
        tags?: string[];
        metas?: any[];
        example?: any[];
        valids?: any[];
        invalids?: any[];
        unit?: string;
        options?: ValidationOptions;
        [key: string]: any;
    }

    interface Context {
        [key: string]: any;
        key?: string;
        label?: string;
        value?: any;
    }

    interface State {
        key?: string;
        path?: (string | number)[];
        parent?: any;
        reference?: any;
        ancestors?: any;
        localize?(...args: any[]): State;
    }

    interface BooleanSchema<TSchema = boolean> extends AnySchema<TSchema> {
        
        falsy(...values: Array<string | number | null>): this;

        
        sensitive(enabled?: boolean): this;

        
        truthy(...values: Array<string | number | null>): this;
    }

    interface NumberSchema<TSchema = number> extends AnySchema<TSchema> {
        
        greater(limit: number | Reference): this;

        
        integer(): this;

        
        less(limit: number | Reference): this;

        
        max(limit: number | Reference): this;

        
        min(limit: number | Reference): this;

        
        multiple(base: number | Reference): this;

        
        negative(): this;

        
        port(): this;

        
        positive(): this;

        
        precision(limit: number): this;

        
        sign(sign: 'positive' | 'negative'): this;

        
        unsafe(enabled?: any): this;
    }

    interface StringSchema<TSchema = string> extends AnySchema<TSchema> {
        
        alphanum(): this;

        
        base64(options?: Base64Options): this;

        
        case(direction: 'upper' | 'lower'): this;

        
        creditCard(): this;

        
        dataUri(options?: DataUriOptions): this;

        
        domain(options?: DomainOptions): this;

        
        email(options?: EmailOptions): this;

        
        guid(options?: GuidOptions): this;

        
        hex(options?: HexOptions): this;

        
        hostname(): this;

        
        insensitive(): this;

        
        ip(options?: IpOptions): this;

        
        isoDate(): this;

        
        isoDuration(): this;

        
        length(limit: number | Reference, encoding?: string): this;

        
        lowercase(): this;

        
        max(limit: number | Reference, encoding?: string): this;

        
        min(limit: number | Reference, encoding?: string): this;

        
        normalize(form?: 'NFC' | 'NFD' | 'NFKC' | 'NFKD'): this;

        
        pattern(pattern: RegExp, options?: string | StringRegexOptions): this;

        
        regex(pattern: RegExp, options?: string | StringRegexOptions): this;

        
        replace(pattern: RegExp | string, replacement: string): this;

        
        token(): this;

        
        trim(enabled?: any): this;

        
        truncate(enabled?: boolean): this;

        
        uppercase(): this;

        
        uri(options?: UriOptions): this;

        
        uuid(options?: GuidOptions): this;
    }

    interface SymbolSchema<TSchema = Symbol> extends AnySchema<TSchema> {
        
        map(iterable: Iterable<[string | number | boolean | symbol, symbol]> | { [key: string]: symbol }): this;
    }

    interface ArraySortOptions {
        
        order?: 'ascending' | 'descending';
        by?: string | Reference;
    }

    interface ArrayUniqueOptions extends HierarchySeparatorOptions {
        
        ignoreUndefined?: boolean;
    }

    type ComparatorFunction = (a: any, b: any) => boolean;

    interface ArraySchema<TSchema = any[]> extends AnySchema<TSchema> {
        
        has(schema: SchemaLike): this;

        
        items<A>(a: SchemaLikeWithoutArray<A>): ArraySchema<A[]>;
        items<A, B>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>): ArraySchema<(A | B)[]>;
        items<A, B, C>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>, c: SchemaLikeWithoutArray<C>): ArraySchema<(A | B | C)[]>;
        items<A, B, C, D>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>, c: SchemaLikeWithoutArray<C>, d: SchemaLikeWithoutArray<D>): ArraySchema<(A | B | C| D)[]>;
        items<A, B, C, D, E>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>, c: SchemaLikeWithoutArray<C>, d: SchemaLikeWithoutArray<D>, e: SchemaLikeWithoutArray<E>): ArraySchema<(A | B | C| D | E)[]>;
        items<A, B, C, D, E , F>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>, c: SchemaLikeWithoutArray<C>, d: SchemaLikeWithoutArray<D>, e: SchemaLikeWithoutArray<E>, f: SchemaLikeWithoutArray<F>): ArraySchema<(A | B | C| D | E |F)[]>;
        items<TItems>(...types: SchemaLikeWithoutArray<TItems>[]): this;

        
        length(limit: number | Reference): this;

        
        max(limit: number | Reference): this;

        
        min(limit: number | Reference): this;

        
        ordered(...types: SchemaLikeWithoutArray[]): this;

        
        single(enabled?: any): this;

        
        sort(options?: ArraySortOptions): this;

        
        sparse(enabled?: any): this;

        
        unique(comparator?: string | ComparatorFunction, options?: ArrayUniqueOptions): this;
    }

    interface ObjectPatternOptions {
        fallthrough?: boolean;
        matches: SchemaLike | Reference;
    }

    interface ObjectSchema<TSchema = any> extends AnySchema<TSchema> {
        
        and(...peers: Array<string | DependencyOptions>): this;

        
        append(schema?: SchemaMap<TSchema>): this;
        append<TSchemaExtended = any, T = TSchemaExtended>(schema?: SchemaMap<T>): ObjectSchema<T>

        
        assert(ref: string | Reference, schema: SchemaLike, message?: string): this;

        
        
        instance(constructor: Function, name?: string): this;

        
        keys(schema?: SchemaMap<TSchema>): this;

        
        length(limit: number): this;

        
        max(limit: number | Reference): this;

        
        min(limit: number | Reference): this;

        
        nand(...peers: Array<string | DependencyOptions>): this;

        
        or(...peers: Array<string | DependencyOptions>): this;

        
        oxor(...peers: Array<string | DependencyOptions>): this;

        
        pattern(pattern: RegExp | SchemaLike, schema: SchemaLike, options?: ObjectPatternOptions): this;

        
        ref(): this;

        
        regex(): this;

        
        rename(from: string | RegExp, to: string, options?: RenameOptions): this;

        
        schema(type?: SchemaLike): this;

        
        unknown(allow?: boolean): this;

        
        with(key: string, peers: string | string[], options?: DependencyOptions): this;

        
        without(key: string, peers: string | string[], options?: DependencyOptions): this;

        
        xor(...peers: Array<string | DependencyOptions>): this;
    }

    interface BinarySchema<TSchema = Buffer> extends AnySchema<TSchema> {
        
        encoding(encoding: string): this;

        
        min(limit: number | Reference): this;

        
        max(limit: number | Reference): this;

        
        length(limit: number | Reference): this;
    }

    interface DateSchema<TSchema = Date> extends AnySchema<TSchema> {
        
        greater(date: 'now' | Date | number | string | Reference): this;

        
        iso(): this;

        
        less(date: 'now' | Date | number | string | Reference): this;

        
        min(date: 'now' | Date | number | string | Reference): this;

        
        max(date: 'now' | Date | number | string | Reference): this;

        
        timestamp(type?: 'javascript' | 'unix'): this;
    }

    interface FunctionSchema<TSchema = Function> extends ObjectSchema<TSchema> {
        
        arity(n: number): this;

        
        class(): this;

        
        minArity(n: number): this;

        
        maxArity(n: number): this;
    }

    interface AlternativesSchema<TSchema = any> extends AnySchema<TSchema> {
        
        conditional<ThenSchema, OtherwiseSchema>(ref: string | Reference, options: WhenOptions | WhenOptions[]): AlternativesSchema<ThenSchema | OtherwiseSchema>;
        conditional<ThenSchema, OtherwiseSchema>(ref: Schema, options: WhenSchemaOptions<ThenSchema, OtherwiseSchema>): AlternativesSchema<ThenSchema | OtherwiseSchema>;

        
        match(mode: 'any' | 'all' | 'one'): this;

        
        try<A>(a: SchemaLikeWithoutArray<A>): AlternativesSchema<A>;
        try<A, B>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>): AlternativesSchema<A | B>;
        try<A, B, C>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>, c: SchemaLikeWithoutArray<C>): AlternativesSchema<A | B | C>;
        try<A, B, C, D>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>, c: SchemaLikeWithoutArray<C>, d: SchemaLikeWithoutArray<D>): AlternativesSchema<A | B | C| D>;
        try<A, B, C, D, E>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>, c: SchemaLikeWithoutArray<C>, d: SchemaLikeWithoutArray<D>, e: SchemaLikeWithoutArray<E>): AlternativesSchema<A | B | C| D | E>;
        try<A, B, C, D, E , F>(a: SchemaLikeWithoutArray<A>, b: SchemaLikeWithoutArray<B>, c: SchemaLikeWithoutArray<C>, d: SchemaLikeWithoutArray<D>, e: SchemaLikeWithoutArray<E>, f: SchemaLikeWithoutArray<F>): AlternativesSchema<A | B | C| D | E |F>;
        try(...types: SchemaLikeWithoutArray[]): this;
    }

    interface LinkSchema<TSchema = any> extends AnySchema<TSchema> {
        
        concat(schema: Schema): this;

        
        ref(ref: string): this;
    }

    interface Reference extends Exclude<ReferenceOptions, 'prefix'> {
        depth: number;
        type: string;
        key: string;
        root: string;
        path: string[];
        display: string;
        toString(): string;
    }

    type ExtensionBoundSchema = Schema & SchemaInternals;

    interface RuleArgs {
        name: string;
        ref?: boolean;
        assert?: ((value: any) => boolean) | AnySchema;
        message?: string;

        
        normalize?(value: any): any;
    }

    type RuleMethod = (...args: any[]) => any;

    interface ExtensionRule {
        
        alias?: string;
        
        multi?: boolean;
        
        convert?: boolean;
        
        args?: Array<RuleArgs | string>;
        
        method?: RuleMethod | false;
        
        validate?(value: any, helpers: any, args: Record<string, any>, options: any): any;

        
        priority?: boolean;
        manifest?: boolean;
    }

    interface CoerceResult {
        errors?: ErrorReport[];
        value?: any;
    }

    type CoerceFunction = (value: any, helpers: CustomHelpers) => CoerceResult;

    interface CoerceObject {
        method: CoerceFunction;
        from?: string | string[];
    }

    interface ExtensionFlag {
        setter?: string;
        default?: any;
    }

    interface ExtensionTermManifest {
        mapped: {
            from: string;
            to: string;
        };
    }

    interface ExtensionTerm {
        init: any[] | null;
        register?: any;
        manifest?: Record<string, 'schema' | 'single' | ExtensionTermManifest>;
    }

    interface Extension {
        type: string | RegExp;
        args?(...args: SchemaLike[]): Schema;
        base?: Schema;
        coerce?: CoerceFunction | CoerceObject;
        flags?: Record<string, ExtensionFlag>;
        manifest?: {
            build?(obj: ExtensionBoundSchema, desc: Record<string, any>): any;
        };
        messages?: LanguageMessages | string;
        modifiers?: Record<string, (rule: any, enabled?: boolean) => any>;
        overrides?: Record<string, (value: any) => Schema>;
        prepare?(value: any, helpers: CustomHelpers): any;
        rebuild?(schema: ExtensionBoundSchema): void;
        rules?: Record<string, ExtensionRule & ThisType<SchemaInternals>>;
        terms?: Record<string, ExtensionTerm>;
        validate?(value: any, helpers: CustomHelpers): any;

        
        cast?: Record<string, { from(value: any): any; to(value: any, helpers: CustomHelpers): any }>;
        properties?: Record<string, any>;
    }

    type ExtensionFactory = (joi: Root) => Extension;

    interface Err {
        toString(): string;
    }

    

    interface Root {
        
        version: string;

        ValidationError: new (message: string, details: ValidationErrorItem[], original: any) => ValidationError;

        
        any<TSchema = any>(): AnySchema<TSchema>;

        
        array<TSchema = any[]>(): ArraySchema<TSchema>;

        
        bool<TSchema = boolean>(): BooleanSchema<TSchema>;

        
        boolean<TSchema = boolean>(): BooleanSchema<TSchema>;

        
        binary<TSchema = Buffer>(): BinarySchema<TSchema>;

        
        date<TSchema = Date>(): DateSchema<TSchema>;

        
        func<TSchema = Function>(): FunctionSchema<TSchema>;

        
        function<TSchema = Function>(): FunctionSchema<TSchema>;

        
        number<TSchema = number>(): NumberSchema<TSchema>;

        
        
        object<TSchema = any, isStrict = false, T = TSchema>(schema?: SchemaMap<T, isStrict>): ObjectSchema<TSchema>;

        
        string<TSchema = string>(): StringSchema<TSchema>;

        
        symbol<TSchema = Symbol>(): SymbolSchema<TSchema>;

        
        alternatives<A,B>(params: [SchemaLike<A>,SchemaLike<B>]): AlternativesSchema<A | B>;
        alternatives<A,B,C>(params: [SchemaLike<A>, SchemaLike<B>, SchemaLike<C>]): AlternativesSchema<A | B | C>;
        alternatives<A,B,C,D>(params: [SchemaLike<A>, SchemaLike<B>, SchemaLike<C>,  SchemaLike<D>]): AlternativesSchema<A | B | C | D>;
        alternatives<A,B,C,D, E>(params: [SchemaLike<A>,SchemaLike<B>, SchemaLike<C>,  SchemaLike<D>,  SchemaLike<E>]): AlternativesSchema<A | B | C | D|E>;
        alternatives<A,B>(a: SchemaLike<A>,b: SchemaLike<B>): AlternativesSchema<A | B>;
        alternatives<A,B,C>(a: SchemaLike<A>,b: SchemaLike<B>, c:SchemaLike<C>): AlternativesSchema<A | B | C>;
        alternatives<A,B,C,D>(a: SchemaLike<A>,b: SchemaLike<B>, c:SchemaLike<C>, d: SchemaLike<D>): AlternativesSchema<A | B | C | D>;
        alternatives<A,B,C,D, E>(a: SchemaLike<A>,b: SchemaLike<B>, c:SchemaLike<C>, d: SchemaLike<D>, e: SchemaLike<E>): AlternativesSchema<A | B | C | D|E>;
        alternatives<TSchema = any>(types: SchemaLike<TSchema>[]): AlternativesSchema<TSchema>;
        alternatives<TSchema = any>(...types: SchemaLike<TSchema>[]): AlternativesSchema<TSchema>;

        
        alt<A,B>(params: [SchemaLike<A>,SchemaLike<B>]): AlternativesSchema<A | B>;
        alt<A,B,C>(params: [SchemaLike<A>, SchemaLike<B>, SchemaLike<C>]): AlternativesSchema<A | B | C>;
        alt<A,B,C,D>(params: [SchemaLike<A>, SchemaLike<B>, SchemaLike<C>,  SchemaLike<D>]): AlternativesSchema<A | B | C | D>;
        alt<A,B,C,D, E>(params: [SchemaLike<A>,SchemaLike<B>, SchemaLike<C>,  SchemaLike<D>,  SchemaLike<E>]): AlternativesSchema<A | B | C | D|E>;
        alt<A,B>(a: SchemaLike<A>,b: SchemaLike<B>): AlternativesSchema<A | B>;
        alt<A,B,C>(a: SchemaLike<A>,b: SchemaLike<B>, c:SchemaLike<C>): AlternativesSchema<A | B | C>;
        alt<A,B,C,D>(a: SchemaLike<A>,b: SchemaLike<B>, c:SchemaLike<C>, d: SchemaLike<D>): AlternativesSchema<A | B | C | D>;
        alt<A,B,C,D, E>(a: SchemaLike<A>,b: SchemaLike<B>, c:SchemaLike<C>, d: SchemaLike<D>, e: SchemaLike<E>): AlternativesSchema<A | B | C | D|E>;
        alt<TSchema = any>(types: SchemaLike[]): AlternativesSchema<TSchema>;
        alt<TSchema = any>(...types: SchemaLike[]): AlternativesSchema<TSchema>;

        
        link<TSchema = any>(ref?: string): LinkSchema<TSchema>;

        
        assert(value: any, schema: Schema, options?: ValidationOptions): void;
        assert(value: any, schema: Schema, message: string | Error, options?: ValidationOptions): void;

        
        attempt<TSchema extends Schema>(value: any, schema: TSchema, options?: ValidationOptions): TSchema extends Schema<infer Value> ? Value : never;
        attempt<TSchema extends Schema>(value: any, schema: TSchema, message: string | Error, options?: ValidationOptions): TSchema extends Schema<infer Value> ? Value : never;

        cache: CacheConfiguration;

        
        compile(schema: SchemaLike, options?: CompileOptions): Schema;

        
        checkPreferences(prefs: ValidationOptions): void;

        
        custom(fn: CustomValidator, description?: string): Schema;

        
        defaults(fn: SchemaFunction): Root;

        
        expression(template: string, options?: ReferenceOptions): any;

        
        extend(...extensions: Array<Extension | ExtensionFactory>): any;

        
        in(ref: string, options?: ReferenceOptions): Reference;

        
        isError(error: any): error is ValidationError;

        
        isExpression(expression: any): boolean;

        
        isRef(ref: any): ref is Reference;

        
        isSchema(schema: any, options?: CompileOptions): schema is AnySchema;

        
        override: symbol;

        
        ref(key: string, options?: ReferenceOptions): Reference;

        
        types(): {
            alternatives: AlternativesSchema;
            any: AnySchema;
            array: ArraySchema;
            binary: BinarySchema;
            boolean: BooleanSchema;
            date: DateSchema;
            function: FunctionSchema;
            link: LinkSchema;
            number: NumberSchema;
            object: ObjectSchema;
            string: StringSchema;
            symbol: SymbolSchema;
        };

        
        x(template: string, options?: ReferenceOptions): any;

        
        
        

        
        allow(...values: any[]): Schema;

        
        valid(...values: any[]): Schema;
        equal(...values: any[]): Schema;

        
        invalid(...values: any[]): Schema;
        disallow(...values: any[]): Schema;
        not(...values: any[]): Schema;

        
        required(): Schema;

        
        exist(): Schema;

        
        optional(): Schema;

        
        forbidden(): Schema;

        
        preferences(options: ValidationOptions): Schema;

        
        prefs(options: ValidationOptions): Schema;

        
        when(ref: string | Reference, options: WhenOptions | WhenOptions[]): AlternativesSchema;
        when(ref: Schema, options: WhenSchemaOptions): AlternativesSchema;

        
        build(...args: any[]): any;

        
        options(...args: any[]): any;

        
        trace(...args: any[]): any;
        untrace(...args: any[]): any;
    }
}

declare const Joi: Joi.Root;
export = Joi;
