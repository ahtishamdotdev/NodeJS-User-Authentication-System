import { Binary, UUID } from './binary';
import { Code } from './code';
import { DBRef } from './db_ref';
import { Decimal128 } from './decimal128';
import { Double } from './double';
import { Int32 } from './int_32';
import { Long } from './long';
import { MaxKey } from './max_key';
import { MinKey } from './min_key';
import { ObjectId } from './objectid';
import { internalCalculateObjectSize } from './parser/calculate_size';

import { internalDeserialize, type DeserializeOptions } from './parser/deserializer';
import { serializeInto, type SerializeOptions } from './parser/serializer';
import { BSONRegExp } from './regexp';
import { BSONSymbol } from './symbol';
import { Timestamp } from './timestamp';
import { ByteUtils } from './utils/byte_utils';
import { NumberUtils } from './utils/number_utils';
export type { UUIDExtended, BinaryExtended, BinaryExtendedLegacy, BinarySequence } from './binary';
export type { CodeExtended } from './code';
export type { DBRefLike } from './db_ref';
export type { Decimal128Extended } from './decimal128';
export type { DoubleExtended } from './double';
export type { EJSONOptions } from './extended_json';
export type { Int32Extended } from './int_32';
export type { LongExtended } from './long';
export type { MaxKeyExtended } from './max_key';
export type { MinKeyExtended } from './min_key';
export type { ObjectIdExtended, ObjectIdLike } from './objectid';
export type { BSONRegExpExtended, BSONRegExpExtendedLegacy } from './regexp';
export type { BSONSymbolExtended } from './symbol';
export type { LongWithoutOverrides, TimestampExtended, TimestampOverrides } from './timestamp';
export type { LongWithoutOverridesClass } from './timestamp';
export type { SerializeOptions, DeserializeOptions };

export {
  Code,
  BSONSymbol,
  DBRef,
  Binary,
  ObjectId,
  UUID,
  Long,
  Timestamp,
  Double,
  Int32,
  MinKey,
  MaxKey,
  BSONRegExp,
  Decimal128
};
export { BSONValue } from './bson_value';
export { BSONError, BSONVersionError, BSONRuntimeError, BSONOffsetError } from './error';
export { BSONType } from './constants';
export { EJSON } from './extended_json';
export { onDemand, type OnDemand } from './parser/on_demand/index';


export interface Document {
  
  [key: string]: any;
}



const MAXSIZE = 1024 * 1024 * 17;


let buffer = ByteUtils.allocate(MAXSIZE);


export function setInternalBufferSize(size: number): void {
  
  if (buffer.length < size) {
    buffer = ByteUtils.allocate(size);
  }
}


export function serialize(object: Document, options: SerializeOptions = {}): Uint8Array {
  
  const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
  const serializeFunctions =
    typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  const ignoreUndefined =
    typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
  const minInternalBufferSize =
    typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;

  
  if (buffer.length < minInternalBufferSize) {
    buffer = ByteUtils.allocate(minInternalBufferSize);
  }

  
  const serializationIndex = serializeInto(
    buffer,
    object,
    checkKeys,
    0,
    0,
    serializeFunctions,
    ignoreUndefined,
    null
  );

  
  const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);

  
  finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);

  
  return finishedBuffer;
}


export function serializeWithBufferAndIndex(
  object: Document,
  finalBuffer: Uint8Array,
  options: SerializeOptions = {}
): number {
  
  const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
  const serializeFunctions =
    typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  const ignoreUndefined =
    typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
  const startIndex = typeof options.index === 'number' ? options.index : 0;

  
  const serializationIndex = serializeInto(
    buffer,
    object,
    checkKeys,
    0,
    0,
    serializeFunctions,
    ignoreUndefined,
    null
  );

  finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);

  
  return startIndex + serializationIndex - 1;
}


export function deserialize(buffer: Uint8Array, options: DeserializeOptions = {}): Document {
  return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);
}


export type CalculateObjectSizeOptions = Pick<
  SerializeOptions,
  'serializeFunctions' | 'ignoreUndefined'
>;


export function calculateObjectSize(
  object: Document,
  options: CalculateObjectSizeOptions = {}
): number {
  options = options || {};

  const serializeFunctions =
    typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  const ignoreUndefined =
    typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;

  return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
}


export function deserializeStream(
  data: Uint8Array | ArrayBuffer,
  startIndex: number,
  numberOfDocuments: number,
  documents: Document[],
  docStartIndex: number,
  options: DeserializeOptions
): number {
  const internalOptions = Object.assign(
    { allowObjectSmallerThanBufferSize: true, index: 0 },
    options
  );
  const bufferData = ByteUtils.toLocalBufferType(data);

  let index = startIndex;
  
  for (let i = 0; i < numberOfDocuments; i++) {
    
    const size = NumberUtils.getInt32LE(bufferData, index);
    
    internalOptions.index = index;
    
    documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
    
    index = index + size;
  }

  
  return index;
}
