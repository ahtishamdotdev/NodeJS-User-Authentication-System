
export declare class Binary extends BSONValue {
    get _bsontype(): 'Binary';
    
    
    static readonly BUFFER_SIZE = 256;
    
    static readonly SUBTYPE_DEFAULT = 0;
    
    static readonly SUBTYPE_FUNCTION = 1;
    
    static readonly SUBTYPE_BYTE_ARRAY = 2;
    
    static readonly SUBTYPE_UUID_OLD = 3;
    
    static readonly SUBTYPE_UUID = 4;
    
    static readonly SUBTYPE_MD5 = 5;
    
    static readonly SUBTYPE_ENCRYPTED = 6;
    
    static readonly SUBTYPE_COLUMN = 7;
    
    static readonly SUBTYPE_SENSITIVE = 8;
    
    static readonly SUBTYPE_VECTOR = 9;
    
    static readonly SUBTYPE_USER_DEFINED = 128;
    
    static readonly VECTOR_TYPE: Readonly<{
        readonly Int8: 3;
        readonly Float32: 39;
        readonly PackedBit: 16;
    }>;
    
    buffer: Uint8Array;
    
    sub_type: number;
    
    position: number;
    
    constructor(buffer?: BinarySequence, subType?: number);
    
    put(byteValue: string | number | Uint8Array | number[]): void;
    
    write(sequence: BinarySequence, offset: number): void;
    
    read(position: number, length: number): Uint8Array;
    
    value(): Uint8Array;
    
    length(): number;
    toJSON(): string;
    toString(encoding?: 'hex' | 'base64' | 'utf8' | 'utf-8'): string;
    
    toUUID(): UUID;
    
    static createFromHexString(hex: string, subType?: number): Binary;
    
    static createFromBase64(base64: string, subType?: number): Binary;
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
    
    toInt8Array(): Int8Array;
    
    toFloat32Array(): Float32Array;
    
    toPackedBits(): Uint8Array;
    
    toBits(): Int8Array;
    
    static fromInt8Array(array: Int8Array): Binary;
    
    static fromFloat32Array(array: Float32Array): Binary;
    
    static fromPackedBits(array: Uint8Array, padding?: number): Binary;
    
    static fromBits(bits: ArrayLike<number>): Binary;
}


export declare interface BinaryExtended {
    $binary: {
        subType: string;
        base64: string;
    };
}


export declare interface BinaryExtendedLegacy {
    $type: string;
    $binary: string;
}


export declare type BinarySequence = Uint8Array | number[];

declare namespace BSON {
    export {
        setInternalBufferSize,
        serialize,
        serializeWithBufferAndIndex,
        deserialize,
        calculateObjectSize,
        deserializeStream,
        UUIDExtended,
        BinaryExtended,
        BinaryExtendedLegacy,
        BinarySequence,
        CodeExtended,
        DBRefLike,
        Decimal128Extended,
        DoubleExtended,
        EJSONOptions,
        Int32Extended,
        LongExtended,
        MaxKeyExtended,
        MinKeyExtended,
        ObjectIdExtended,
        ObjectIdLike,
        BSONRegExpExtended,
        BSONRegExpExtendedLegacy,
        BSONSymbolExtended,
        LongWithoutOverrides,
        TimestampExtended,
        TimestampOverrides,
        LongWithoutOverridesClass,
        SerializeOptions,
        DeserializeOptions,
        Code,
        BSONSymbol,
        DBRef,
        Binary,
        ObjectId,
        UUID,
        Long,
        Timestamp,
        Double,
        Int32,
        MinKey,
        MaxKey,
        BSONRegExp,
        Decimal128,
        BSONValue,
        BSONError,
        BSONVersionError,
        BSONRuntimeError,
        BSONOffsetError,
        BSONType,
        EJSON,
        onDemand,
        OnDemand,
        Document,
        CalculateObjectSizeOptions
    }
}
export { BSON }






declare type BSONElement = [
type: number,
nameOffset: number,
nameLength: number,
offset: number,
length: number
];


export declare class BSONError extends Error {
    
    get name(): string;
    constructor(message: string, options?: {
        cause?: unknown;
    });
    
    static isBSONError(value: unknown): value is BSONError;
}


export declare class BSONOffsetError extends BSONError {
    get name(): 'BSONOffsetError';
    offset: number;
    constructor(message: string, offset: number, options?: {
        cause?: unknown;
    });
}


export declare class BSONRegExp extends BSONValue {
    get _bsontype(): 'BSONRegExp';
    pattern: string;
    options: string;
    
    constructor(pattern: string, options?: string);
    static parseOptions(options?: string): string;
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface BSONRegExpExtended {
    $regularExpression: {
        pattern: string;
        options: string;
    };
}


export declare interface BSONRegExpExtendedLegacy {
    $regex: string | BSONRegExp;
    $options: string;
}


export declare class BSONRuntimeError extends BSONError {
    get name(): 'BSONRuntimeError';
    constructor(message: string);
}


export declare class BSONSymbol extends BSONValue {
    get _bsontype(): 'BSONSymbol';
    value: string;
    
    constructor(value: string);
    
    valueOf(): string;
    toString(): string;
    toJSON(): string;
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface BSONSymbolExtended {
    $symbol: string;
}


export declare const BSONType: Readonly<{
    readonly double: 1;
    readonly string: 2;
    readonly object: 3;
    readonly array: 4;
    readonly binData: 5;
    readonly undefined: 6;
    readonly objectId: 7;
    readonly bool: 8;
    readonly date: 9;
    readonly null: 10;
    readonly regex: 11;
    readonly dbPointer: 12;
    readonly javascript: 13;
    readonly symbol: 14;
    readonly javascriptWithScope: 15;
    readonly int: 16;
    readonly timestamp: 17;
    readonly long: 18;
    readonly decimal: 19;
    readonly minKey: -1;
    readonly maxKey: 127;
}>;


export declare type BSONType = (typeof BSONType)[keyof typeof BSONType];


export declare abstract class BSONValue {
    
    abstract get _bsontype(): string;
    
    
    abstract inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
    
}


export declare class BSONVersionError extends BSONError {
    get name(): 'BSONVersionError';
    constructor();
}


declare type ByteUtils = {
    
    toLocalBufferType: (buffer: Uint8Array | ArrayBufferView | ArrayBuffer) => Uint8Array;
    
    allocate: (size: number) => Uint8Array;
    
    allocateUnsafe: (size: number) => Uint8Array;
    
    equals: (a: Uint8Array, b: Uint8Array) => boolean;
    
    fromNumberArray: (array: number[]) => Uint8Array;
    
    fromBase64: (base64: string) => Uint8Array;
    
    toBase64: (buffer: Uint8Array) => string;
    
    fromISO88591: (codePoints: string) => Uint8Array;
    
    toISO88591: (buffer: Uint8Array) => string;
    
    fromHex: (hex: string) => Uint8Array;
    
    toHex: (buffer: Uint8Array) => string;
    
    toUTF8: (buffer: Uint8Array, start: number, end: number, fatal: boolean) => string;
    
    utf8ByteLength: (input: string) => number;
    
    encodeUTF8Into: (destination: Uint8Array, source: string, byteOffset: number) => number;
    
    randomBytes: (byteLength: number) => Uint8Array;
    
    swap32: (buffer: Uint8Array) => Uint8Array;
};




export declare function calculateObjectSize(object: Document, options?: CalculateObjectSizeOptions): number;


export declare type CalculateObjectSizeOptions = Pick<SerializeOptions, 'serializeFunctions' | 'ignoreUndefined'>;


export declare class Code extends BSONValue {
    get _bsontype(): 'Code';
    code: string;
    scope: Document | null;
    
    constructor(code: string | Function, scope?: Document | null);
    toJSON(): {
        code: string;
        scope?: Document;
    };
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface CodeExtended {
    $code: string;
    $scope?: Document;
}


export declare class DBRef extends BSONValue {
    get _bsontype(): 'DBRef';
    collection: string;
    oid: ObjectId;
    db?: string;
    fields: Document;
    
    constructor(collection: string, oid: ObjectId, db?: string, fields?: Document);
    
    
    toJSON(): DBRefLike & Document;
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface DBRefLike {
    $ref: string;
    $id: ObjectId;
    $db?: string;
}


export declare class Decimal128 extends BSONValue {
    get _bsontype(): 'Decimal128';
    readonly bytes: Uint8Array;
    
    constructor(bytes: Uint8Array | string);
    
    static fromString(representation: string): Decimal128;
    
    static fromStringWithRounding(representation: string): Decimal128;
    private static _fromString;
    
    toString(): string;
    toJSON(): Decimal128Extended;
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface Decimal128Extended {
    $numberDecimal: string;
}


export declare function deserialize(buffer: Uint8Array, options?: DeserializeOptions): Document;


export declare interface DeserializeOptions {
    
    useBigInt64?: boolean;
    
    promoteLongs?: boolean;
    
    promoteBuffers?: boolean;
    
    promoteValues?: boolean;
    
    fieldsAsRaw?: Document;
    
    bsonRegExp?: boolean;
    
    allowObjectSmallerThanBufferSize?: boolean;
    
    index?: number;
    raw?: boolean;
    
    validation?: {
        utf8: boolean | Record<string, true> | Record<string, false>;
    };
}


export declare function deserializeStream(data: Uint8Array | ArrayBuffer, startIndex: number, numberOfDocuments: number, documents: Document[], docStartIndex: number, options: DeserializeOptions): number;


export declare interface Document {
    [key: string]: any;
}


export declare class Double extends BSONValue {
    get _bsontype(): 'Double';
    value: number;
    
    constructor(value: number);
    
    static fromString(value: string): Double;
    
    valueOf(): number;
    toJSON(): number;
    toString(radix?: number): string;
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface DoubleExtended {
    $numberDouble: string;
}


export declare const EJSON: {
    parse: typeof parse;
    stringify: typeof stringify;
    serialize: typeof EJSONserialize;
    deserialize: typeof EJSONdeserialize;
};


declare function EJSONdeserialize(ejson: Document, options?: EJSONOptions): any;


export declare type EJSONOptions = {
    
    legacy?: boolean;
    
    relaxed?: boolean;
    
    useBigInt64?: boolean;
};


declare function EJSONserialize(value: any, options?: EJSONOptions): Document;

declare type InspectFn = (x: unknown, options?: unknown) => string;


export declare class Int32 extends BSONValue {
    get _bsontype(): 'Int32';
    value: number;
    
    constructor(value: number | string);
    
    static fromString(value: string): Int32;
    
    valueOf(): number;
    toString(radix?: number): string;
    toJSON(): number;
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface Int32Extended {
    $numberInt: string;
}


export declare class Long extends BSONValue {
    get _bsontype(): 'Long';
    
    get __isLong__(): boolean;
    
    high: number;
    
    low: number;
    
    unsigned: boolean;
    
    constructor(low: number, high?: number, unsigned?: boolean);
    
    constructor(value: bigint, unsigned?: boolean);
    
    constructor(value: string, unsigned?: boolean);
    static TWO_PWR_24: Long;
    
    static MAX_UNSIGNED_VALUE: Long;
    
    static ZERO: Long;
    
    static UZERO: Long;
    
    static ONE: Long;
    
    static UONE: Long;
    
    static NEG_ONE: Long;
    
    static MAX_VALUE: Long;
    
    static MIN_VALUE: Long;
    
    static fromBits(lowBits: number, highBits: number, unsigned?: boolean): Long;
    
    static fromInt(value: number, unsigned?: boolean): Long;
    
    static fromNumber(value: number, unsigned?: boolean): Long;
    
    static fromBigInt(value: bigint, unsigned?: boolean): Long;
    
    
    static fromStringStrict(str: string): Long;
    
    static fromStringStrict(str: string, unsigned?: boolean): Long;
    
    static fromStringStrict(str: string, radix?: boolean): Long;
    
    static fromStringStrict(str: string, unsigned?: boolean, radix?: number): Long;
    
    static fromString(str: string): Long;
    
    static fromString(str: string, radix?: number): Long;
    
    static fromString(str: string, unsigned?: boolean): Long;
    
    static fromString(str: string, unsigned?: boolean, radix?: number): Long;
    
    static fromBytes(bytes: number[], unsigned?: boolean, le?: boolean): Long;
    
    static fromBytesLE(bytes: number[], unsigned?: boolean): Long;
    
    static fromBytesBE(bytes: number[], unsigned?: boolean): Long;
    
    static isLong(value: unknown): value is Long;
    
    static fromValue(val: number | string | {
        low: number;
        high: number;
        unsigned?: boolean;
    }, unsigned?: boolean): Long;
    
    add(addend: string | number | Long | Timestamp): Long;
    
    and(other: string | number | Long | Timestamp): Long;
    
    compare(other: string | number | Long | Timestamp): 0 | 1 | -1;
    
    comp(other: string | number | Long | Timestamp): 0 | 1 | -1;
    
    divide(divisor: string | number | Long | Timestamp): Long;
    
    div(divisor: string | number | Long | Timestamp): Long;
    
    equals(other: string | number | Long | Timestamp): boolean;
    
    eq(other: string | number | Long | Timestamp): boolean;
    
    getHighBits(): number;
    
    getHighBitsUnsigned(): number;
    
    getLowBits(): number;
    
    getLowBitsUnsigned(): number;
    
    getNumBitsAbs(): number;
    
    greaterThan(other: string | number | Long | Timestamp): boolean;
    
    gt(other: string | number | Long | Timestamp): boolean;
    
    greaterThanOrEqual(other: string | number | Long | Timestamp): boolean;
    
    gte(other: string | number | Long | Timestamp): boolean;
    
    ge(other: string | number | Long | Timestamp): boolean;
    
    isEven(): boolean;
    
    isNegative(): boolean;
    
    isOdd(): boolean;
    
    isPositive(): boolean;
    
    isZero(): boolean;
    
    lessThan(other: string | number | Long | Timestamp): boolean;
    
    lt(other: string | number | Long | Timestamp): boolean;
    
    lessThanOrEqual(other: string | number | Long | Timestamp): boolean;
    
    lte(other: string | number | Long | Timestamp): boolean;
    
    modulo(divisor: string | number | Long | Timestamp): Long;
    
    mod(divisor: string | number | Long | Timestamp): Long;
    
    rem(divisor: string | number | Long | Timestamp): Long;
    
    multiply(multiplier: string | number | Long | Timestamp): Long;
    
    mul(multiplier: string | number | Long | Timestamp): Long;
    
    negate(): Long;
    
    neg(): Long;
    
    not(): Long;
    
    notEquals(other: string | number | Long | Timestamp): boolean;
    
    neq(other: string | number | Long | Timestamp): boolean;
    
    ne(other: string | number | Long | Timestamp): boolean;
    
    or(other: number | string | Long): Long;
    
    shiftLeft(numBits: number | Long): Long;
    
    shl(numBits: number | Long): Long;
    
    shiftRight(numBits: number | Long): Long;
    
    shr(numBits: number | Long): Long;
    
    shiftRightUnsigned(numBits: Long | number): Long;
    
    shr_u(numBits: number | Long): Long;
    
    shru(numBits: number | Long): Long;
    
    subtract(subtrahend: string | number | Long | Timestamp): Long;
    
    sub(subtrahend: string | number | Long | Timestamp): Long;
    
    toInt(): number;
    
    toNumber(): number;
    
    toBigInt(): bigint;
    
    toBytes(le?: boolean): number[];
    
    toBytesLE(): number[];
    
    toBytesBE(): number[];
    
    toSigned(): Long;
    
    toString(radix?: number): string;
    
    toUnsigned(): Long;
    
    xor(other: Long | number | string): Long;
    
    eqz(): boolean;
    
    le(other: string | number | Long | Timestamp): boolean;
    toExtendedJSON(options?: EJSONOptions): number | LongExtended;
    static fromExtendedJSON(doc: {
        $numberLong: string;
    }, options?: EJSONOptions): number | Long | bigint;
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface LongExtended {
    $numberLong: string;
}


export declare type LongWithoutOverrides = new (low: unknown, high?: number | boolean, unsigned?: boolean) => {
    [P in Exclude<keyof Long, TimestampOverrides>]: Long[P];
};


export declare const LongWithoutOverridesClass: LongWithoutOverrides;


export declare class MaxKey extends BSONValue {
    get _bsontype(): 'MaxKey';
    
    
    inspect(): string;
}


export declare interface MaxKeyExtended {
    $maxKey: 1;
}


export declare class MinKey extends BSONValue {
    get _bsontype(): 'MinKey';
    
    
    inspect(): string;
}


export declare interface MinKeyExtended {
    $minKey: 1;
}


declare type NumberUtils = {
    
    isBigEndian: boolean;
    
    getNonnegativeInt32LE: (source: Uint8Array, offset: number) => number;
    getInt32LE: (source: Uint8Array, offset: number) => number;
    getUint32LE: (source: Uint8Array, offset: number) => number;
    getUint32BE: (source: Uint8Array, offset: number) => number;
    getBigInt64LE: (source: Uint8Array, offset: number) => bigint;
    getFloat64LE: (source: Uint8Array, offset: number) => number;
    setInt32BE: (destination: Uint8Array, offset: number, value: number) => 4;
    setInt32LE: (destination: Uint8Array, offset: number, value: number) => 4;
    setBigInt64LE: (destination: Uint8Array, offset: number, value: bigint) => 8;
    setFloat64LE: (destination: Uint8Array, offset: number, value: number) => 8;
};


declare const NumberUtils: NumberUtils;


export declare class ObjectId extends BSONValue {
    get _bsontype(): 'ObjectId';
    
    static cacheHexString: boolean;
    
    
    constructor(inputId: number);
    
    constructor(inputId: string);
    
    constructor(inputId: ObjectId);
    
    constructor(inputId: ObjectIdLike);
    
    constructor(inputId: Uint8Array);
    
    constructor();
    
    constructor(inputId?: string | number | ObjectId | ObjectIdLike | Uint8Array);
    
    get id(): Uint8Array;
    set id(value: Uint8Array);
    
    
    toHexString(): string;
    
    
    static generate(time?: number): Uint8Array;
    
    toString(encoding?: 'hex' | 'base64'): string;
    
    toJSON(): string;
    
    
    equals(otherId: string | ObjectId | ObjectIdLike | undefined | null): boolean;
    
    getTimestamp(): Date;
    
    
    
    static createFromTime(time: number): ObjectId;
    
    static createFromHexString(hexString: string): ObjectId;
    
    static createFromBase64(base64: string): ObjectId;
    
    static isValid(id: string | number | ObjectId | ObjectIdLike | Uint8Array): boolean;
    
    
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface ObjectIdExtended {
    $oid: string;
}


export declare interface ObjectIdLike {
    id: string | Uint8Array;
    __id?: string;
    toHexString(): string;
}


export declare type OnDemand = {
    parseToElements: (this: void, bytes: Uint8Array, startOffset?: number) => Iterable<BSONElement>;
    BSONElement: BSONElement;
    ByteUtils: ByteUtils;
    NumberUtils: NumberUtils;
};


export declare const onDemand: OnDemand;


declare function parse(text: string, options?: EJSONOptions): any;


export declare function serialize(object: Document, options?: SerializeOptions): Uint8Array;


export declare interface SerializeOptions {
    
    checkKeys?: boolean;
    
    serializeFunctions?: boolean;
    
    ignoreUndefined?: boolean;
    
    
    index?: number;
}


export declare function serializeWithBufferAndIndex(object: Document, finalBuffer: Uint8Array, options?: SerializeOptions): number;


export declare function setInternalBufferSize(size: number): void;


declare function stringify(value: any, replacer?: (number | string)[] | ((this: any, key: string, value: any) => any) | EJSONOptions, space?: string | number, options?: EJSONOptions): string;


export declare class Timestamp extends LongWithoutOverridesClass {
    get _bsontype(): 'Timestamp';
    static readonly MAX_VALUE: Long;
    
    get i(): number;
    
    get t(): number;
    
    constructor(int: bigint);
    
    constructor(long: Long);
    
    constructor(value: {
        t: number;
        i: number;
    });
    toJSON(): {
        $timestamp: string;
    };
    
    static fromInt(value: number): Timestamp;
    
    static fromNumber(value: number): Timestamp;
    
    static fromBits(lowBits: number, highBits: number): Timestamp;
    
    static fromString(str: string, optRadix: number): Timestamp;
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare interface TimestampExtended {
    $timestamp: {
        t: number;
        i: number;
    };
}


export declare type TimestampOverrides = '_bsontype' | 'toExtendedJSON' | 'fromExtendedJSON' | 'inspect';


export declare class UUID extends Binary {
    
    constructor(input?: string | Uint8Array | UUID);
    
    get id(): Uint8Array;
    set id(value: Uint8Array);
    
    toHexString(includeDashes?: boolean): string;
    
    toString(encoding?: 'hex' | 'base64'): string;
    
    toJSON(): string;
    
    equals(otherId: string | Uint8Array | UUID): boolean;
    
    toBinary(): Binary;
    
    static generate(): Uint8Array;
    
    static isValid(input: string | Uint8Array | UUID | Binary): boolean;
    
    static createFromHexString(hexString: string): UUID;
    
    static createFromBase64(base64: string): UUID;
    
    
    
    inspect(depth?: number, options?: unknown, inspect?: InspectFn): string;
}


export declare type UUIDExtended = {
    $uuid: string;
};

export { }
