



export function deepEqual(obj: any, ref: any, options?: deepEqual.Options): boolean;

export namespace deepEqual {

    interface Options {

        
        readonly deepFunction?: boolean;

        
        readonly part?: boolean;

        
        readonly prototype?: boolean;

        
        readonly skip?: (string | symbol)[];

        
        readonly symbols?: boolean;
    }
}



export function clone<T>(obj: T, options?: clone.Options): T;

export namespace clone {

    interface Options {

        
        readonly prototype?: boolean;

        
        readonly symbols?: boolean;

        
        readonly shallow?: string[] | string[][] | boolean;
    }
}



export function merge<T1 extends object, T2 extends object>(target: T1, source: T2, options?: merge.Options): T1 & T2;

export namespace merge {

    interface Options {

        
        readonly nullOverride?: boolean;

        
        readonly mergeArrays?: boolean;

        
        readonly symbols?: boolean;
    }
}



export function applyToDefaults<T extends object>(defaults: Partial<T>, source: Partial<T> | boolean | null, options?: applyToDefaults.Options): Partial<T>;

export namespace applyToDefaults {

    interface Options {

        
        readonly nullOverride?: boolean;

        
        readonly shallow?: string[] | string[][];
    }
}



export function intersect<T1, T2>(array1: intersect.Array<T1>, array2: intersect.Array<T2>, options?: intersect.Options): Array<T1 | T2>;
export function intersect<T1, T2>(array1: intersect.Array<T1>, array2: intersect.Array<T2>, options?: intersect.Options): T1 | T2;

export namespace intersect {

    type Array<T> = ArrayLike<T> | Set<T> | null;

    interface Options {

        
        readonly first?: boolean;
    }
}



export function contain(ref: string, values: string | string[], options?: contain.Options): boolean;
export function contain(ref: any[], values: any, options?: contain.Options): boolean;
export function contain(ref: object, values: string | string[] | object, options?: Omit<contain.Options, 'once'>): boolean;

export namespace contain {

    interface Options {

        
        readonly deep?: boolean;

        
        readonly once?: boolean;

        
        readonly only?: boolean;

        
        readonly part?: boolean;

        
        readonly symbols?: boolean;
    }
}



export function flatten<T>(array: ArrayLike<T | ReadonlyArray<T>>, target?: ArrayLike<T | ReadonlyArray<T>>): T[];



export function reach(obj: object | null, chain: string | (string | number)[] | false | null | undefined, options?: reach.Options): any;

export namespace reach {

    interface Options {

        
        readonly separator?: string;

        
        readonly default?: any;

        
        readonly strict?: boolean;

        
        readonly functions?: boolean;

        
        readonly iterables?: boolean;
    }
}



export function reachTemplate(obj: object | null, template: string, options?: reach.Options): string;



export function assert(condition: any, error: Error): asserts condition;



export function assert(condition: any, ...args: any): asserts condition;



export class AssertError extends Error {

    name: 'AssertError';
}



export class Bench {

    constructor();

    
    ts: number;

    
    elapsed(): number;

    
    reset(): void;

    
    static now(): number;
}



export function escapeRegex(string: string): string;



export function escapeHeaderAttribute(attribute: string): string;



export function escapeHtml(string: string): string;



export function escapeJson(string: string): string;



export function once<T extends Function>(method: T): T;



export function ignore(...ignore: any): void;



export function stringify(value: any, replacer?: any, space?: string | number): string;



export function wait<T>(timeout?: number, returnValue?: T): Promise<T>;



export function block(): Promise<void>;



export function isPromise(promise: any): boolean;


export namespace ts {

    
    type XOR<T, U> = (T | U) extends object ? (internals.Without<T, U> & U) | (internals.Without<U, T> & T) : T | U;
}


declare namespace internals {

    type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
}
