import * as Util from 'util';

import { analyzeDomain, Analysis, DomainOptions } from './domain';
import { errorCode } from './errors';

const NON_ASCII_RX = /[^\x00-\x7f]/;
const ENCODER_IMPL = new (Util.TextEncoder || TextEncoder)(); 

export interface EmailOptions extends DomainOptions {
    
    readonly ignoreLength?: boolean;
}


export function analyzeEmail(email: string, options?: EmailOptions): Analysis | null {
    return validateEmail(email, options);
}


export function isEmailValid(email: string, options?: EmailOptions) {
    return !validateEmail(email, options);
}

function validateEmail(email: string, options: EmailOptions = {}) {
    if (typeof email !== 'string') {
        throw new Error('Invalid input: email must be a string');
    }

    if (!email) {
        return errorCode('EMPTY_STRING');
    }

    

    const ascii = !NON_ASCII_RX.test(email);
    if (!ascii) {
        if (options.allowUnicode === false) {
            
            return errorCode('FORBIDDEN_UNICODE');
        }

        email = email.normalize('NFC');
    }

    

    const parts = email.split('@');
    if (parts.length !== 2) {
        return parts.length > 2 ? errorCode('MULTIPLE_AT_CHAR') : errorCode('MISSING_AT_CHAR');
    }

    const [local, domain] = parts;

    if (!local) {
        return errorCode('EMPTY_LOCAL');
    }

    if (!options.ignoreLength) {
        if (email.length > 254) {
            
            return errorCode('ADDRESS_TOO_LONG');
        }

        if (ENCODER_IMPL.encode(local).length > 64) {
            
            return errorCode('LOCAL_TOO_LONG');
        }
    }

    

    return validateLocal(local, ascii) || analyzeDomain(domain, options);
}

function validateLocal(local: string, ascii: boolean) {
    const segments = local.split('.');
    for (const segment of segments) {
        if (!segment.length) {
            return errorCode('EMPTY_LOCAL_SEGMENT');
        }

        if (ascii) {
            if (!ATEXT_RX.test(segment)) {
                return errorCode('INVALID_LOCAL_CHARS');
            }

            continue;
        }

        for (const char of segment) {
            if (ATEXT_RX.test(char)) {
                continue;
            }

            const binary = toBinary(char);
            if (!ATOM_RX.test(binary)) {
                return errorCode('INVALID_LOCAL_CHARS');
            }
        }
    }

    return null;
}

function toBinary(char: string) {
    return Array.from(ENCODER_IMPL.encode(char), (v) => String.fromCharCode(v)).join('');
}



const ATEXT_RX = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/; 

const ATOM_RX = new RegExp(
    [
        
        '(?:[\\xc2-\\xdf][\\x80-\\xbf])',

        
        '(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})',

        
        '(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})'
    ].join('|')
);
