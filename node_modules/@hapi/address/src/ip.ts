import { assert } from '@hapi/hoek';

import { ipVersions } from './uri';

interface Options {
    
    readonly cidr?: Cidr;

    
    readonly version?: Version | Version[];
}

type Cidr = 'optional' | 'required' | 'forbidden';
type Version = 'ipv4' | 'ipv6' | 'ipvfuture';

interface Expression {
    
    cidr: Cidr;

    
    raw: string;

    
    regex: RegExp;

    
    versions: Version[];
}


export function ipRegex(options: Options = {}): Expression {
    

    const cidr = options.cidr || 'optional';
    assert(
        ['required', 'optional', 'forbidden'].includes(cidr),
        'options.cidr must be one of required, optional, forbidden'
    );

    

    assert(
        options.version === undefined || typeof options.version === 'string' || Array.isArray(options.version),
        'options.version must be a string or an array of string'
    );

    let versions = options.version || ['ipv4', 'ipv6', 'ipvfuture'];
    if (!Array.isArray(versions)) {
        versions = [versions];
    }

    assert(versions.length >= 1, 'options.version must have at least 1 version specified');

    for (const version of versions) {
        assert(typeof version === 'string' && version === version.toLowerCase(), 'Invalid options.version value');

        assert(
            ['ipv4', 'ipv6', 'ipvfuture'].includes(version),
            'options.version contains unknown version ' + version + ' - must be one of ipv4, ipv6, ipvfuture'
        );
    }

    versions = Array.from(new Set(versions));

    

    const parts = versions.map((version) => {
        

        if (cidr === 'forbidden') {
            return ipVersions[version];
        }

        

        const cidrpart = `\\/${version === 'ipv4' ? ipVersions.v4Cidr : ipVersions.v6Cidr}`;

        if (cidr === 'required') {
            return `${ipVersions[version]}${cidrpart}`;
        }

        

        return `${ipVersions[version]}(?:${cidrpart})?`;
    });

    const raw = `(?:${parts.join('|')})`;
    const regex = new RegExp(`^${raw}$`);
    return { cidr, versions, regex, raw };
}
