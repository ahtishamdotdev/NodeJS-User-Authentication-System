import * as Util from 'util';
import { analyzeDomain } from './domain';
import { errorCode } from './errors';
const NON_ASCII_RX = /[^\x00-\x7f]/;
const ENCODER_IMPL = new (Util.TextEncoder || TextEncoder)(); 

export function analyzeEmail(email, options) {
    return validateEmail(email, options);
}

export function isEmailValid(email, options) {
    return !validateEmail(email, options);
}
function validateEmail(email, options = {}) {
    if (typeof email !== 'string') {
        throw new Error('Invalid input: email must be a string');
    }
    if (!email) {
        return errorCode('EMPTY_STRING');
    }
    
    const ascii = !NON_ASCII_RX.test(email);
    if (!ascii) {
        if (options.allowUnicode === false) {
            
            return errorCode('FORBIDDEN_UNICODE');
        }
        email = email.normalize('NFC');
    }
    
    const parts = email.split('@');
    if (parts.length !== 2) {
        return parts.length > 2 ? errorCode('MULTIPLE_AT_CHAR') : errorCode('MISSING_AT_CHAR');
    }
    const [local, domain] = parts;
    if (!local) {
        return errorCode('EMPTY_LOCAL');
    }
    if (!options.ignoreLength) {
        if (email.length > 254) {
            
            return errorCode('ADDRESS_TOO_LONG');
        }
        if (ENCODER_IMPL.encode(local).length > 64) {
            
            return errorCode('LOCAL_TOO_LONG');
        }
    }
    
    return validateLocal(local, ascii) || analyzeDomain(domain, options);
}
function validateLocal(local, ascii) {
    const segments = local.split('.');
    for (const segment of segments) {
        if (!segment.length) {
            return errorCode('EMPTY_LOCAL_SEGMENT');
        }
        if (ascii) {
            if (!ATEXT_RX.test(segment)) {
                return errorCode('INVALID_LOCAL_CHARS');
            }
            continue;
        }
        for (const char of segment) {
            if (ATEXT_RX.test(char)) {
                continue;
            }
            const binary = toBinary(char);
            if (!ATOM_RX.test(binary)) {
                return errorCode('INVALID_LOCAL_CHARS');
            }
        }
    }
    return null;
}
function toBinary(char) {
    return Array.from(ENCODER_IMPL.encode(char), (v) => String.fromCharCode(v)).join('');
}

const ATEXT_RX = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/; 
const ATOM_RX = new RegExp([
    
    '(?:[\\xc2-\\xdf][\\x80-\\xbf])',
    
    '(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})',
    
    '(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})'
].join('|'));
