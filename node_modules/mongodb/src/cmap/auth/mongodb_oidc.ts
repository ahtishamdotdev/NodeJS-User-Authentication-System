import type { Document } from '../../bson';
import { MongoInvalidArgumentError, MongoMissingCredentialsError } from '../../error';
import type { HandshakeDocument } from '../connect';
import type { Connection } from '../connection';
import { type AuthContext, AuthProvider } from './auth_provider';
import type { MongoCredentials } from './mongo_credentials';
import { AutomatedCallbackWorkflow } from './mongodb_oidc/automated_callback_workflow';
import { callback as azureCallback } from './mongodb_oidc/azure_machine_workflow';
import { callback as gcpCallback } from './mongodb_oidc/gcp_machine_workflow';
import { callback as k8sCallback } from './mongodb_oidc/k8s_machine_workflow';
import { TokenCache } from './mongodb_oidc/token_cache';
import { callback as testCallback } from './mongodb_oidc/token_machine_workflow';


const MISSING_CREDENTIALS_ERROR = 'AuthContext must provide credentials.';


export interface IdPInfo {
  
  issuer: string;
  
  clientId: string;
  
  requestScopes?: string[];
}


export interface IdPServerResponse {
  
  accessToken: string;
  
  expiresInSeconds?: number;
  
  refreshToken?: string;
}


export interface OIDCResponse {
  
  accessToken: string;
  
  expiresInSeconds?: number;
  
  refreshToken?: string;
}


export interface OIDCCallbackParams {
  
  username?: string;
  
  timeoutContext: AbortSignal;
  
  version: 1;
  
  idpInfo?: IdPInfo;
  
  refreshToken?: string;
  
  tokenAudience?: string;
}


export type OIDCCallbackFunction = (params: OIDCCallbackParams) => Promise<OIDCResponse>;


export const OIDC_VERSION = 1;

type EnvironmentName = 'test' | 'azure' | 'gcp' | 'k8s' | undefined;


export interface Workflow {
  cache: TokenCache;

  
  execute(
    connection: Connection,
    credentials: MongoCredentials,
    response?: Document
  ): Promise<void>;

  
  reauthenticate(connection: Connection, credentials: MongoCredentials): Promise<void>;

  
  speculativeAuth(connection: Connection, credentials: MongoCredentials): Promise<Document>;
}


export const OIDC_WORKFLOWS: Map<EnvironmentName, () => Workflow> = new Map();
OIDC_WORKFLOWS.set('test', () => new AutomatedCallbackWorkflow(new TokenCache(), testCallback));
OIDC_WORKFLOWS.set('azure', () => new AutomatedCallbackWorkflow(new TokenCache(), azureCallback));
OIDC_WORKFLOWS.set('gcp', () => new AutomatedCallbackWorkflow(new TokenCache(), gcpCallback));
OIDC_WORKFLOWS.set('k8s', () => new AutomatedCallbackWorkflow(new TokenCache(), k8sCallback));


export class MongoDBOIDC extends AuthProvider {
  workflow: Workflow;

  
  constructor(workflow?: Workflow) {
    super();
    if (!workflow) {
      throw new MongoInvalidArgumentError('No workflow provided to the OIDC auth provider.');
    }
    this.workflow = workflow;
  }

  
  override async auth(authContext: AuthContext): Promise<void> {
    const { connection, reauthenticating, response } = authContext;
    if (response?.speculativeAuthenticate?.done && !reauthenticating) {
      return;
    }
    const credentials = getCredentials(authContext);
    if (reauthenticating) {
      await this.workflow.reauthenticate(connection, credentials);
    } else {
      await this.workflow.execute(connection, credentials, response);
    }
  }

  
  override async prepare(
    handshakeDoc: HandshakeDocument,
    authContext: AuthContext
  ): Promise<HandshakeDocument> {
    const { connection } = authContext;
    const credentials = getCredentials(authContext);
    const result = await this.workflow.speculativeAuth(connection, credentials);
    return { ...handshakeDoc, ...result };
  }
}


function getCredentials(authContext: AuthContext): MongoCredentials {
  const { credentials } = authContext;
  if (!credentials) {
    throw new MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
  }
  return credentials;
}
