import { type Document } from './bson';
import { MongoDBResponse } from './cmap/wire_protocol/responses';
import { MongoWriteConcernError } from './error';


export type W = number | 'majority';


export interface WriteConcernOptions {
  
  writeConcern?: WriteConcern | WriteConcernSettings;
}


export interface WriteConcernSettings {
  
  w?: W;
  
  wtimeoutMS?: number;
  
  journal?: boolean;

  
  
  j?: boolean;
  
  wtimeout?: number;
  
  fsync?: boolean | 1;
}

export const WRITE_CONCERN_KEYS = ['w', 'wtimeout', 'j', 'journal', 'fsync'];


interface CommandWriteConcernOptions {
  
  w?: W;
  
  j?: boolean;
  
  wtimeout?: number;
}


export class WriteConcern {
  
  readonly w?: W;
  
  readonly journal?: boolean;
  
  readonly wtimeoutMS?: number;
  
  wtimeout?: number;
  
  j?: boolean;
  
  fsync?: boolean | 1;

  
  constructor(w?: W, wtimeoutMS?: number, journal?: boolean, fsync?: boolean | 1) {
    if (w != null) {
      if (!Number.isNaN(Number(w))) {
        this.w = Number(w);
      } else {
        this.w = w;
      }
    }
    if (wtimeoutMS != null) {
      this.wtimeoutMS = this.wtimeout = wtimeoutMS;
    }
    if (journal != null) {
      this.journal = this.j = journal;
    }
    if (fsync != null) {
      this.journal = this.j = fsync ? true : false;
    }
  }

  
  static apply(command: Document, writeConcern: WriteConcern): Document {
    const wc: CommandWriteConcernOptions = {};
    
    if (writeConcern.w != null) wc.w = writeConcern.w;
    if (writeConcern.wtimeoutMS != null) wc.wtimeout = writeConcern.wtimeoutMS;
    if (writeConcern.journal != null) wc.j = writeConcern.j;
    command.writeConcern = wc;
    return command;
  }

  
  static fromOptions(
    options?: WriteConcernOptions | WriteConcern | W,
    inherit?: WriteConcernOptions | WriteConcern
  ): WriteConcern | undefined {
    if (options == null) return undefined;
    inherit = inherit ?? {};
    let opts: WriteConcernSettings | WriteConcern | undefined;
    if (typeof options === 'string' || typeof options === 'number') {
      opts = { w: options };
    } else if (options instanceof WriteConcern) {
      opts = options;
    } else {
      opts = options.writeConcern;
    }
    const parentOpts: WriteConcern | WriteConcernSettings | undefined =
      inherit instanceof WriteConcern ? inherit : inherit.writeConcern;

    const mergedOpts = { ...parentOpts, ...opts } as WriteConcernSettings;
    const {
      w = undefined,
      wtimeout = undefined,
      j = undefined,
      fsync = undefined,
      journal = undefined,
      wtimeoutMS = undefined
    } = mergedOpts;
    if (
      w != null ||
      wtimeout != null ||
      wtimeoutMS != null ||
      j != null ||
      journal != null ||
      fsync != null
    ) {
      return new WriteConcern(w, wtimeout ?? wtimeoutMS, j ?? journal, fsync);
    }
    return undefined;
  }
}


export function throwIfWriteConcernError(response: unknown): void {
  if (typeof response === 'object' && response != null) {
    const writeConcernError: object | null =
      MongoDBResponse.is(response) && response.has('writeConcernError')
        ? response.toObject()
        : !MongoDBResponse.is(response) && 'writeConcernError' in response
          ? response
          : null;

    if (writeConcernError != null) {
      throw new MongoWriteConcernError(writeConcernError as any);
    }
  }
}
