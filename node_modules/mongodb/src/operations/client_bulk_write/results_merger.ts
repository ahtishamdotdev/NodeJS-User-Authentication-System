import { MongoWriteConcernError } from '../..';
import { type Document } from '../../bson';
import { type ClientBulkWriteCursor } from '../../cursor/client_bulk_write_cursor';
import { MongoClientBulkWriteError } from '../../error';
import {
  type ClientBulkWriteError,
  type ClientBulkWriteOptions,
  type ClientBulkWriteResult,
  type ClientDeleteResult,
  type ClientInsertOneResult,
  type ClientUpdateResult
} from './common';


const UNACKNOWLEDGED = {
  acknowledged: false,
  insertedCount: 0,
  upsertedCount: 0,
  matchedCount: 0,
  modifiedCount: 0,
  deletedCount: 0,
  insertResults: undefined,
  updateResults: undefined,
  deleteResults: undefined
};

interface ClientBulkWriteResultAccumulation {
  
  acknowledged: boolean;
  
  insertedCount: number;
  
  upsertedCount: number;
  
  matchedCount: number;
  
  modifiedCount: number;
  
  deletedCount: number;
  
  insertResults?: Map<number, ClientInsertOneResult>;
  
  updateResults?: Map<number, ClientUpdateResult>;
  
  deleteResults?: Map<number, ClientDeleteResult>;
}


export class ClientBulkWriteResultsMerger {
  private result: ClientBulkWriteResultAccumulation;
  private options: ClientBulkWriteOptions;
  private currentBatchOffset: number;
  writeConcernErrors: Document[];
  writeErrors: Map<number, ClientBulkWriteError>;

  
  static unacknowledged(): ClientBulkWriteResult {
    return UNACKNOWLEDGED;
  }

  
  constructor(options: ClientBulkWriteOptions) {
    this.options = options;
    this.currentBatchOffset = 0;
    this.writeConcernErrors = [];
    this.writeErrors = new Map();
    this.result = {
      acknowledged: true,
      insertedCount: 0,
      upsertedCount: 0,
      matchedCount: 0,
      modifiedCount: 0,
      deletedCount: 0,
      insertResults: undefined,
      updateResults: undefined,
      deleteResults: undefined
    };

    if (options.verboseResults) {
      this.result.insertResults = new Map<number, ClientInsertOneResult>();
      this.result.updateResults = new Map<number, ClientUpdateResult>();
      this.result.deleteResults = new Map<number, ClientDeleteResult>();
    }
  }

  
  get bulkWriteResult(): ClientBulkWriteResult {
    return {
      acknowledged: this.result.acknowledged,
      insertedCount: this.result.insertedCount,
      upsertedCount: this.result.upsertedCount,
      matchedCount: this.result.matchedCount,
      modifiedCount: this.result.modifiedCount,
      deletedCount: this.result.deletedCount,
      insertResults: this.result.insertResults,
      updateResults: this.result.updateResults,
      deleteResults: this.result.deleteResults
    };
  }

  
  async merge(cursor: ClientBulkWriteCursor): Promise<ClientBulkWriteResult> {
    let writeConcernErrorResult;
    try {
      for await (const document of cursor) {
        
        if (document.ok === 1) {
          if (this.options.verboseResults) {
            this.processDocument(cursor, document);
          }
        } else {
          
          
          
          if (this.options.ordered) {
            const error = new MongoClientBulkWriteError({
              message: 'Mongo client ordered bulk write encountered a write error.'
            });
            error.writeErrors.set(document.idx + this.currentBatchOffset, {
              code: document.code,
              message: document.errmsg
            });
            error.partialResult = this.result;
            throw error;
          } else {
            this.writeErrors.set(document.idx + this.currentBatchOffset, {
              code: document.code,
              message: document.errmsg
            });
          }
        }
      }
    } catch (error) {
      if (error instanceof MongoWriteConcernError) {
        const result = error.result;
        writeConcernErrorResult = {
          insertedCount: result.nInserted,
          upsertedCount: result.nUpserted,
          matchedCount: result.nMatched,
          modifiedCount: result.nModified,
          deletedCount: result.nDeleted,
          writeConcernError: result.writeConcernError
        };
        if (this.options.verboseResults && result.cursor.firstBatch) {
          for (const document of result.cursor.firstBatch) {
            if (document.ok === 1) {
              this.processDocument(cursor, document);
            }
          }
        }
      } else {
        throw error;
      }
    } finally {
      
      if (cursor.response) {
        const response = cursor.response;
        this.incrementCounts(response);
      }

      
      this.currentBatchOffset += cursor.operations.length;
    }

    
    if (writeConcernErrorResult) {
      const writeConcernError = writeConcernErrorResult.writeConcernError as Document;
      this.incrementCounts(writeConcernErrorResult);
      this.writeConcernErrors.push({
        code: writeConcernError.code,
        message: writeConcernError.errmsg
      });
    }

    return this.result;
  }

  
  private processDocument(cursor: ClientBulkWriteCursor, document: Document) {
    
    const operation = cursor.operations[document.idx];
    
    if ('insert' in operation) {
      this.result.insertResults?.set(document.idx + this.currentBatchOffset, {
        insertedId: operation.document._id
      });
    }
    
    if ('update' in operation) {
      const result: ClientUpdateResult = {
        matchedCount: document.n,
        modifiedCount: document.nModified ?? 0,
        
        didUpsert: document.upserted != null
      };
      if (document.upserted) {
        result.upsertedId = document.upserted._id;
      }
      this.result.updateResults?.set(document.idx + this.currentBatchOffset, result);
    }
    
    if ('delete' in operation) {
      this.result.deleteResults?.set(document.idx + this.currentBatchOffset, {
        deletedCount: document.n
      });
    }
  }

  
  private incrementCounts(document: Document) {
    this.result.insertedCount += document.insertedCount;
    this.result.upsertedCount += document.upsertedCount;
    this.result.matchedCount += document.matchedCount;
    this.result.modifiedCount += document.modifiedCount;
    this.result.deletedCount += document.deletedCount;
  }
}
