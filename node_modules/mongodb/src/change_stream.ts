import type { Readable } from 'stream';

import type { Binary, Document, Timestamp } from './bson';
import { Collection } from './collection';
import { CHANGE, CLOSE, END, ERROR, INIT, MORE, RESPONSE, RESUME_TOKEN_CHANGED } from './constants';
import { type CursorStreamOptions, CursorTimeoutContext } from './cursor/abstract_cursor';
import { ChangeStreamCursor, type ChangeStreamCursorOptions } from './cursor/change_stream_cursor';
import { Db } from './db';
import {
  type AnyError,
  isResumableError,
  MongoAPIError,
  MongoChangeStreamError,
  MongoOperationTimeoutError,
  MongoRuntimeError
} from './error';
import { MongoClient } from './mongo_client';
import { type InferIdType, TypedEventEmitter } from './mongo_types';
import type { AggregateOptions } from './operations/aggregate';
import type { CollationOptions, OperationParent } from './operations/command';
import type { ReadPreference } from './read_preference';
import { type AsyncDisposable, configureResourceManagement } from './resource_management';
import type { ServerSessionId } from './sessions';
import { CSOTTimeoutContext, type TimeoutContext } from './timeout';
import { filterOptions, getTopology, type MongoDBNamespace, squashError } from './utils';

const CHANGE_STREAM_OPTIONS = [
  'resumeAfter',
  'startAfter',
  'startAtOperationTime',
  'fullDocument',
  'fullDocumentBeforeChange',
  'showExpandedEvents'
] as const;

const CHANGE_DOMAIN_TYPES = {
  COLLECTION: Symbol('Collection'),
  DATABASE: Symbol('Database'),
  CLUSTER: Symbol('Cluster')
};

const CHANGE_STREAM_EVENTS = [RESUME_TOKEN_CHANGED, END, CLOSE] as const;

const NO_RESUME_TOKEN_ERROR =
  'A change stream document has been received that lacks a resume token (_id).';
const CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';


export interface ResumeOptions {
  startAtOperationTime?: Timestamp;
  batchSize?: number;
  maxAwaitTimeMS?: number;
  collation?: CollationOptions;
  readPreference?: ReadPreference;
  resumeAfter?: ResumeToken;
  startAfter?: ResumeToken;
  fullDocument?: string;
}


export type ResumeToken = unknown;


export type OperationTime = Timestamp;


export interface ChangeStreamOptions extends Omit<AggregateOptions, 'writeConcern'> {
  
  fullDocument?: string;

  
  fullDocumentBeforeChange?: string;
  
  maxAwaitTimeMS?: number;
  
  resumeAfter?: ResumeToken;
  
  startAfter?: ResumeToken;
  
  startAtOperationTime?: OperationTime;
  
  batchSize?: number;

  
  showExpandedEvents?: boolean;
}


export interface ChangeStreamNameSpace {
  db: string;
  coll: string;
}


export interface ChangeStreamDocumentKey<TSchema extends Document = Document> {
  
  documentKey: { _id: InferIdType<TSchema>; [shardKey: string]: any };
}


export interface ChangeStreamSplitEvent {
  
  fragment: number;
  
  of: number;
}


export interface ChangeStreamDocumentCommon {
  
  _id: ResumeToken;
  
  clusterTime?: Timestamp;

  
  txnNumber?: number;

  
  lsid?: ServerSessionId;

  
  splitEvent?: ChangeStreamSplitEvent;
}


export interface ChangeStreamDocumentWallTime {
  
  wallTime?: Date;
}


export interface ChangeStreamDocumentCollectionUUID {
  
  collectionUUID: Binary;
}


export interface ChangeStreamDocumentOperationDescription {
  
  operationDescription?: Document;
}


export interface ChangeStreamInsertDocument<TSchema extends Document = Document>
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentKey<TSchema>,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentWallTime {
  
  operationType: 'insert';
  
  fullDocument: TSchema;
  
  ns: ChangeStreamNameSpace;
}


export interface ChangeStreamUpdateDocument<TSchema extends Document = Document>
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentKey<TSchema>,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentWallTime {
  
  operationType: 'update';
  
  fullDocument?: TSchema;
  
  updateDescription: UpdateDescription<TSchema>;
  
  ns: ChangeStreamNameSpace;
  
  fullDocumentBeforeChange?: TSchema;
}


export interface ChangeStreamReplaceDocument<TSchema extends Document = Document>
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentKey<TSchema>,
    ChangeStreamDocumentWallTime {
  
  operationType: 'replace';
  
  fullDocument: TSchema;
  
  ns: ChangeStreamNameSpace;
  
  fullDocumentBeforeChange?: TSchema;
}


export interface ChangeStreamDeleteDocument<TSchema extends Document = Document>
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentKey<TSchema>,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentWallTime {
  
  operationType: 'delete';
  
  ns: ChangeStreamNameSpace;
  
  fullDocumentBeforeChange?: TSchema;
}


export interface ChangeStreamDropDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentWallTime {
  
  operationType: 'drop';
  
  ns: ChangeStreamNameSpace;
}


export interface ChangeStreamRenameDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentWallTime {
  
  operationType: 'rename';
  
  to: { db: string; coll: string };
  
  ns: ChangeStreamNameSpace;
}


export interface ChangeStreamDropDatabaseDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentWallTime {
  
  operationType: 'dropDatabase';
  
  ns: { db: string };
}


export interface ChangeStreamInvalidateDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentWallTime {
  
  operationType: 'invalidate';
}


export interface ChangeStreamCreateIndexDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentOperationDescription,
    ChangeStreamDocumentWallTime {
  
  operationType: 'createIndexes';
}


export interface ChangeStreamDropIndexDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentOperationDescription,
    ChangeStreamDocumentWallTime {
  
  operationType: 'dropIndexes';
}


export interface ChangeStreamCollModDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentWallTime {
  
  operationType: 'modify';
}


export interface ChangeStreamCreateDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentWallTime {
  
  operationType: 'create';

  
  nsType?: 'collection' | 'timeseries' | 'view';
}


export interface ChangeStreamShardCollectionDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentOperationDescription,
    ChangeStreamDocumentWallTime {
  
  operationType: 'shardCollection';
}


export interface ChangeStreamReshardCollectionDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentOperationDescription {
  
  operationType: 'reshardCollection';
}


export interface ChangeStreamRefineCollectionShardKeyDocument
  extends ChangeStreamDocumentCommon,
    ChangeStreamDocumentCollectionUUID,
    ChangeStreamDocumentOperationDescription {
  
  operationType: 'refineCollectionShardKey';
}


export type ChangeStreamDocument<TSchema extends Document = Document> =
  | ChangeStreamInsertDocument<TSchema>
  | ChangeStreamUpdateDocument<TSchema>
  | ChangeStreamReplaceDocument<TSchema>
  | ChangeStreamDeleteDocument<TSchema>
  | ChangeStreamDropDocument
  | ChangeStreamRenameDocument
  | ChangeStreamDropDatabaseDocument
  | ChangeStreamInvalidateDocument
  | ChangeStreamCreateIndexDocument
  | ChangeStreamCreateDocument
  | ChangeStreamCollModDocument
  | ChangeStreamDropIndexDocument
  | ChangeStreamShardCollectionDocument
  | ChangeStreamReshardCollectionDocument
  | ChangeStreamRefineCollectionShardKeyDocument;


export interface UpdateDescription<TSchema extends Document = Document> {
  
  updatedFields?: Partial<TSchema>;

  
  removedFields?: string[];

  
  truncatedArrays?: Array<{
    
    field: string;
    
    newSize: number;
  }>;

  
  disambiguatedPaths?: Document;
}


export type ChangeStreamEvents<
  TSchema extends Document = Document,
  TChange extends Document = ChangeStreamDocument<TSchema>
> = {
  resumeTokenChanged(token: ResumeToken): void;
  init(response: any): void;
  more(response?: any): void;
  response(): void;
  end(): void;
  error(error: Error): void;
  change(change: TChange): void;
  
  close(): void;
};


export class ChangeStream<
    TSchema extends Document = Document,
    TChange extends Document = ChangeStreamDocument<TSchema>
  >
  extends TypedEventEmitter<ChangeStreamEvents<TSchema, TChange>>
  implements AsyncDisposable
{
  
  declare [Symbol.asyncDispose]: () => Promise<void>;
  
  async asyncDispose() {
    await this.close();
  }

  pipeline: Document[];
  
  options: ChangeStreamOptions & { writeConcern?: never };
  parent: MongoClient | Db | Collection;
  namespace: MongoDBNamespace;
  type: symbol;
  
  private cursor: ChangeStreamCursor<TSchema, TChange>;
  streamOptions?: CursorStreamOptions;
  
  private cursorStream?: Readable & AsyncIterable<TChange>;
  
  private isClosed: boolean;
  
  private mode: false | 'iterator' | 'emitter';

  
  static readonly RESPONSE = RESPONSE;
  
  static readonly MORE = MORE;
  
  static readonly INIT = INIT;
  
  static readonly CLOSE = CLOSE;
  
  static readonly CHANGE = CHANGE;
  
  static readonly END = END;
  
  static readonly ERROR = ERROR;
  
  static readonly RESUME_TOKEN_CHANGED = RESUME_TOKEN_CHANGED;

  private timeoutContext?: TimeoutContext;
  
  private contextOwner: symbol;
  
  constructor(
    parent: OperationParent,
    pipeline: Document[] = [],
    options: ChangeStreamOptions = {}
  ) {
    super();

    this.pipeline = pipeline;
    this.options = { ...options };
    let serverSelectionTimeoutMS: number;
    delete this.options.writeConcern;

    if (parent instanceof Collection) {
      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
      serverSelectionTimeoutMS = parent.s.db.client.options.serverSelectionTimeoutMS;
    } else if (parent instanceof Db) {
      this.type = CHANGE_DOMAIN_TYPES.DATABASE;
      serverSelectionTimeoutMS = parent.client.options.serverSelectionTimeoutMS;
    } else if (parent instanceof MongoClient) {
      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
      serverSelectionTimeoutMS = parent.options.serverSelectionTimeoutMS;
    } else {
      throw new MongoChangeStreamError(
        'Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient'
      );
    }

    this.contextOwner = Symbol();
    this.parent = parent;
    this.namespace = parent.s.namespace;
    if (!this.options.readPreference && parent.readPreference) {
      this.options.readPreference = parent.readPreference;
    }

    
    this.cursor = this._createChangeStreamCursor(options);

    this.isClosed = false;
    this.mode = false;

    
    this.on('newListener', eventName => {
      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {
        this._streamEvents(this.cursor);
      }
    });

    this.on('removeListener', eventName => {
      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {
        this.cursorStream?.removeAllListeners('data');
      }
    });

    if (this.options.timeoutMS != null) {
      this.timeoutContext = new CSOTTimeoutContext({
        timeoutMS: this.options.timeoutMS,
        serverSelectionTimeoutMS
      });
    }
  }

  
  get resumeToken(): ResumeToken {
    return this.cursor?.resumeToken;
  }

  
  async hasNext(): Promise<boolean> {
    this._setIsIterator();
    
    
    

    this.timeoutContext?.refresh();
    try {
      while (true) {
        try {
          const hasNext = await this.cursor.hasNext();
          return hasNext;
        } catch (error) {
          try {
            await this._processErrorIteratorMode(error, this.cursor.id != null);
          } catch (error) {
            if (error instanceof MongoOperationTimeoutError && this.cursor.id == null) {
              throw error;
            }
            try {
              await this.close();
            } catch (error) {
              squashError(error);
            }
            throw error;
          }
        }
      }
    } finally {
      this.timeoutContext?.clear();
    }
  }

  
  async next(): Promise<TChange> {
    this._setIsIterator();
    
    
    
    this.timeoutContext?.refresh();

    try {
      while (true) {
        try {
          const change = await this.cursor.next();
          const processedChange = this._processChange(change ?? null);
          return processedChange;
        } catch (error) {
          try {
            await this._processErrorIteratorMode(error, this.cursor.id != null);
          } catch (error) {
            if (error instanceof MongoOperationTimeoutError && this.cursor.id == null) {
              throw error;
            }
            try {
              await this.close();
            } catch (error) {
              squashError(error);
            }
            throw error;
          }
        }
      }
    } finally {
      this.timeoutContext?.clear();
    }
  }

  
  async tryNext(): Promise<TChange | null> {
    this._setIsIterator();
    
    
    
    this.timeoutContext?.refresh();

    try {
      while (true) {
        try {
          const change = await this.cursor.tryNext();
          return change ?? null;
        } catch (error) {
          try {
            await this._processErrorIteratorMode(error, this.cursor.id != null);
          } catch (error) {
            if (error instanceof MongoOperationTimeoutError && this.cursor.id == null) throw error;
            try {
              await this.close();
            } catch (error) {
              squashError(error);
            }
            throw error;
          }
        }
      }
    } finally {
      this.timeoutContext?.clear();
    }
  }

  async *[Symbol.asyncIterator](): AsyncGenerator<TChange, void, void> {
    if (this.closed) {
      return;
    }

    try {
      
      
      while (true) {
        yield await this.next();
      }
    } finally {
      try {
        await this.close();
      } catch (error) {
        squashError(error);
      }
    }
  }

  
  public get closed(): boolean {
    return this.isClosed || this.cursor.closed;
  }

  
  async close(): Promise<void> {
    this.timeoutContext?.clear();
    this.timeoutContext = undefined;
    this.isClosed = true;

    const cursor = this.cursor;
    try {
      await cursor.close();
    } finally {
      this._endStream();
    }
  }

  
  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TChange> {
    if (this.closed) {
      throw new MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
    }

    this.streamOptions = options;
    return this.cursor.stream(options);
  }

  
  private _setIsEmitter(): void {
    if (this.mode === 'iterator') {
      
      throw new MongoAPIError(
        'ChangeStream cannot be used as an EventEmitter after being used as an iterator'
      );
    }
    this.mode = 'emitter';
  }

  
  private _setIsIterator(): void {
    if (this.mode === 'emitter') {
      
      throw new MongoAPIError(
        'ChangeStream cannot be used as an iterator after being used as an EventEmitter'
      );
    }
    this.mode = 'iterator';
  }

  
  private _createChangeStreamCursor(
    options: ChangeStreamOptions | ChangeStreamCursorOptions
  ): ChangeStreamCursor<TSchema, TChange> {
    const changeStreamStageOptions = filterOptions(options, CHANGE_STREAM_OPTIONS);
    if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
      changeStreamStageOptions.allChangesForCluster = true;
    }
    const pipeline = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];

    const client: MongoClient | null =
      this.type === CHANGE_DOMAIN_TYPES.CLUSTER
        ? (this.parent as MongoClient)
        : this.type === CHANGE_DOMAIN_TYPES.DATABASE
          ? (this.parent as Db).client
          : this.type === CHANGE_DOMAIN_TYPES.COLLECTION
            ? (this.parent as Collection).client
            : null;

    if (client == null) {
      
      throw new MongoRuntimeError(
        `Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`
      );
    }

    const changeStreamCursor = new ChangeStreamCursor<TSchema, TChange>(
      client,
      this.namespace,
      pipeline,
      {
        ...options,
        timeoutContext: this.timeoutContext
          ? new CursorTimeoutContext(this.timeoutContext, this.contextOwner)
          : undefined
      }
    );

    for (const event of CHANGE_STREAM_EVENTS) {
      changeStreamCursor.on(event, e => this.emit(event, e));
    }

    if (this.listenerCount(ChangeStream.CHANGE) > 0) {
      this._streamEvents(changeStreamCursor);
    }

    return changeStreamCursor;
  }

  
  private _closeEmitterModeWithError(error: AnyError): void {
    this.emit(ChangeStream.ERROR, error);

    this.close().then(undefined, squashError);
  }

  
  private _streamEvents(cursor: ChangeStreamCursor<TSchema, TChange>): void {
    this._setIsEmitter();
    const stream = this.cursorStream ?? cursor.stream();
    this.cursorStream = stream;
    stream.on('data', change => {
      try {
        const processedChange = this._processChange(change);
        this.emit(ChangeStream.CHANGE, processedChange);
      } catch (error) {
        this.emit(ChangeStream.ERROR, error);
      }
      this.timeoutContext?.refresh();
    });
    stream.on('error', error => this._processErrorStreamMode(error, this.cursor.id != null));
  }

  
  private _endStream(): void {
    this.cursorStream?.removeAllListeners('data');
    this.cursorStream?.removeAllListeners('close');
    this.cursorStream?.removeAllListeners('end');
    this.cursorStream?.destroy();
    this.cursorStream = undefined;
  }

  
  private _processChange(change: TChange | null): TChange {
    if (this.isClosed) {
      
      throw new MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
    }

    
    if (change == null) {
      
      throw new MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
    }

    if (change && !change._id) {
      throw new MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
    }

    
    this.cursor.cacheResumeToken(change._id);

    
    
    this.options.startAtOperationTime = undefined;

    return change;
  }

  
  private _processErrorStreamMode(changeStreamError: AnyError, cursorInitialized: boolean) {
    
    if (this.isClosed) return;

    if (
      cursorInitialized &&
      (isResumableError(changeStreamError, this.cursor.maxWireVersion) ||
        changeStreamError instanceof MongoOperationTimeoutError)
    ) {
      this._endStream();

      this.cursor
        .close()
        .then(
          () => this._resume(changeStreamError),
          e => {
            squashError(e);
            return this._resume(changeStreamError);
          }
        )
        .then(
          () => {
            if (changeStreamError instanceof MongoOperationTimeoutError)
              this.emit(ChangeStream.ERROR, changeStreamError);
          },
          () => this._closeEmitterModeWithError(changeStreamError)
        );
    } else {
      this._closeEmitterModeWithError(changeStreamError);
    }
  }

  
  private async _processErrorIteratorMode(changeStreamError: AnyError, cursorInitialized: boolean) {
    if (this.isClosed) {
      
      throw new MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
    }

    if (
      cursorInitialized &&
      (isResumableError(changeStreamError, this.cursor.maxWireVersion) ||
        changeStreamError instanceof MongoOperationTimeoutError)
    ) {
      try {
        await this.cursor.close();
      } catch (error) {
        squashError(error);
      }

      await this._resume(changeStreamError);

      if (changeStreamError instanceof MongoOperationTimeoutError) throw changeStreamError;
    } else {
      try {
        await this.close();
      } catch (error) {
        squashError(error);
      }

      throw changeStreamError;
    }
  }

  private async _resume(changeStreamError: AnyError) {
    this.timeoutContext?.refresh();
    const topology = getTopology(this.parent);
    try {
      await topology.selectServer(this.cursor.readPreference, {
        operationName: 'reconnect topology in change stream',
        timeoutContext: this.timeoutContext
      });
      this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
    } catch {
      
      await this.close();
      throw changeStreamError;
    }
  }
}

configureResourceManagement(ChangeStream.prototype);
