import type { Document } from './bson';
import {
  type ClientBulkWriteError,
  type ClientBulkWriteResult
} from './operations/client_bulk_write/common';
import type { ServerType } from './sdam/common';
import type { TopologyVersion } from './sdam/server_description';
import type { TopologyDescription } from './sdam/topology_description';


export type AnyError = MongoError | Error;


export const LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp('not master', 'i');


export const LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp(
  'not master or secondary',
  'i'
);


export const NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp('node is recovering', 'i');


export const MONGODB_ERROR_CODES = Object.freeze({
  HostUnreachable: 6,
  HostNotFound: 7,
  AuthenticationFailed: 18,
  NetworkTimeout: 89,
  ShutdownInProgress: 91,
  PrimarySteppedDown: 189,
  ExceededTimeLimit: 262,
  SocketException: 9001,
  NotWritablePrimary: 10107,
  InterruptedAtShutdown: 11600,
  InterruptedDueToReplStateChange: 11602,
  NotPrimaryNoSecondaryOk: 13435,
  NotPrimaryOrSecondary: 13436,
  StaleShardVersion: 63,
  StaleEpoch: 150,
  StaleConfig: 13388,
  RetryChangeStream: 234,
  FailedToSatisfyReadPreference: 133,
  CursorNotFound: 43,
  LegacyNotPrimary: 10058,
  
  WriteConcernTimeout: 64,
  NamespaceNotFound: 26,
  IllegalOperation: 20,
  MaxTimeMSExpired: 50,
  UnknownReplWriteConcern: 79,
  UnsatisfiableWriteConcern: 100,
  Reauthenticate: 391,
  ReadConcernMajorityNotAvailableYet: 134
} as const);


export const GET_MORE_RESUMABLE_CODES = new Set<number>([
  MONGODB_ERROR_CODES.HostUnreachable,
  MONGODB_ERROR_CODES.HostNotFound,
  MONGODB_ERROR_CODES.NetworkTimeout,
  MONGODB_ERROR_CODES.ShutdownInProgress,
  MONGODB_ERROR_CODES.PrimarySteppedDown,
  MONGODB_ERROR_CODES.ExceededTimeLimit,
  MONGODB_ERROR_CODES.SocketException,
  MONGODB_ERROR_CODES.NotWritablePrimary,
  MONGODB_ERROR_CODES.InterruptedAtShutdown,
  MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
  MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
  MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
  MONGODB_ERROR_CODES.StaleShardVersion,
  MONGODB_ERROR_CODES.StaleEpoch,
  MONGODB_ERROR_CODES.StaleConfig,
  MONGODB_ERROR_CODES.RetryChangeStream,
  MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
  MONGODB_ERROR_CODES.CursorNotFound
]);


export const MongoErrorLabel = Object.freeze({
  RetryableWriteError: 'RetryableWriteError',
  TransientTransactionError: 'TransientTransactionError',
  UnknownTransactionCommitResult: 'UnknownTransactionCommitResult',
  ResumableChangeStreamError: 'ResumableChangeStreamError',
  HandshakeError: 'HandshakeError',
  ResetPool: 'ResetPool',
  PoolRequstedRetry: 'PoolRequstedRetry',
  InterruptInUseConnections: 'InterruptInUseConnections',
  NoWritesPerformed: 'NoWritesPerformed'
} as const);


export type MongoErrorLabel = (typeof MongoErrorLabel)[keyof typeof MongoErrorLabel];


export interface ErrorDescription extends Document {
  message?: string;
  errmsg?: string;
  $err?: string;
  errorLabels?: string[];
  errInfo?: Document;
}

function isAggregateError(e: unknown): e is Error & { errors: Error[] } {
  return e != null && typeof e === 'object' && 'errors' in e && Array.isArray(e.errors);
}


export class MongoError extends Error {
  
  private readonly errorLabelSet: Set<string> = new Set();
  public get errorLabels(): string[] {
    return Array.from(this.errorLabelSet);
  }

  
  code?: number | string;
  topologyVersion?: TopologyVersion;
  connectionGeneration?: number;
  override cause?: Error;

  
  constructor(message: string, options?: { cause?: Error }) {
    super(message, options);
  }

  
  static buildErrorMessage(e: unknown): string {
    if (typeof e === 'string') {
      return e;
    }
    if (isAggregateError(e) && e.message.length === 0) {
      return e.errors.length === 0
        ? 'AggregateError has an empty errors array. Please check the `cause` property for more information.'
        : e.errors.map(({ message }) => message).join(', ');
    }

    return e != null && typeof e === 'object' && 'message' in e && typeof e.message === 'string'
      ? e.message
      : 'empty error message';
  }

  override get name(): string {
    return 'MongoError';
  }

  
  get errmsg(): string {
    return this.message;
  }

  
  hasErrorLabel(label: string): boolean {
    return this.errorLabelSet.has(label);
  }

  addErrorLabel(label: string): void {
    this.errorLabelSet.add(label);
  }
}


export class MongoServerError extends MongoError {
  
  errorResponse: ErrorDescription;
  codeName?: string;
  writeConcernError?: Document;
  errInfo?: Document;
  ok?: number;
  [key: string]: any;

  
  constructor(message: ErrorDescription) {
    super(message.message || message.errmsg || message.$err || 'n/a');

    if (message.errorLabels) {
      for (const label of message.errorLabels) this.addErrorLabel(label);
    }

    this.errorResponse = message;

    for (const name in message) {
      if (
        name !== 'errorLabels' &&
        name !== 'errmsg' &&
        name !== 'message' &&
        name !== 'errorResponse'
      ) {
        this[name] = message[name];
      }
    }
  }

  override get name(): string {
    return 'MongoServerError';
  }
}


export class MongoDriverError extends MongoError {
  
  constructor(message: string, options?: { cause?: Error }) {
    super(message, options);
  }

  override get name(): string {
    return 'MongoDriverError';
  }
}



export class MongoAPIError extends MongoDriverError {
  
  constructor(message: string, options?: { cause?: Error }) {
    super(message, options);
  }

  override get name(): string {
    return 'MongoAPIError';
  }
}


export class MongoRuntimeError extends MongoDriverError {
  
  constructor(message: string, options?: { cause?: Error }) {
    super(message, options);
  }

  override get name(): string {
    return 'MongoRuntimeError';
  }
}


export class MongoStalePrimaryError extends MongoRuntimeError {
  
  constructor(message: string, options?: { cause?: Error }) {
    super(message, options);
  }

  override get name(): string {
    return 'MongoStalePrimaryError';
  }
}


export class MongoBatchReExecutionError extends MongoAPIError {
  
  constructor(message = 'This batch has already been executed, create new batch to execute') {
    super(message);
  }

  override get name(): string {
    return 'MongoBatchReExecutionError';
  }
}


export class MongoDecompressionError extends MongoRuntimeError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoDecompressionError';
  }
}


export class MongoNotConnectedError extends MongoAPIError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoNotConnectedError';
  }
}


export class MongoTransactionError extends MongoAPIError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoTransactionError';
  }
}


export class MongoExpiredSessionError extends MongoAPIError {
  
  constructor(message = 'Cannot use a session that has ended') {
    super(message);
  }

  override get name(): string {
    return 'MongoExpiredSessionError';
  }
}


export class MongoKerberosError extends MongoRuntimeError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoKerberosError';
  }
}


export class MongoAWSError extends MongoRuntimeError {
  
  constructor(message: string, options?: { cause?: Error }) {
    super(message, options);
  }

  override get name(): string {
    return 'MongoAWSError';
  }
}


export class MongoOIDCError extends MongoRuntimeError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoOIDCError';
  }
}


export class MongoAzureError extends MongoOIDCError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoAzureError';
  }
}


export class MongoGCPError extends MongoOIDCError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoGCPError';
  }
}


export class MongoClientBulkWriteError extends MongoServerError {
  
  writeConcernErrors: Document[];
  
  writeErrors: Map<number, ClientBulkWriteError>;
  
  partialResult?: ClientBulkWriteResult;

  
  constructor(message: ErrorDescription) {
    super(message);
    this.writeConcernErrors = [];
    this.writeErrors = new Map();
  }

  override get name(): string {
    return 'MongoClientBulkWriteError';
  }
}


export class MongoClientBulkWriteCursorError extends MongoRuntimeError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoClientBulkWriteCursorError';
  }
}


export class MongoClientBulkWriteExecutionError extends MongoRuntimeError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoClientBulkWriteExecutionError';
  }
}


export class MongoChangeStreamError extends MongoRuntimeError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoChangeStreamError';
  }
}


export class MongoTailableCursorError extends MongoAPIError {
  
  constructor(message = 'Tailable cursor does not support this operation') {
    super(message);
  }

  override get name(): string {
    return 'MongoTailableCursorError';
  }
}


export class MongoGridFSStreamError extends MongoRuntimeError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoGridFSStreamError';
  }
}


export class MongoGridFSChunkError extends MongoRuntimeError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoGridFSChunkError';
  }
}


export class MongoUnexpectedServerResponseError extends MongoRuntimeError {
  
  constructor(message: string, options?: { cause?: Error }) {
    super(message, options);
  }

  override get name(): string {
    return 'MongoUnexpectedServerResponseError';
  }
}


export class MongoOperationTimeoutError extends MongoDriverError {
  override get name(): string {
    return 'MongoOperationTimeoutError';
  }
}


export class MongoCursorInUseError extends MongoAPIError {
  
  constructor(message = 'Cursor is already initialized') {
    super(message);
  }

  override get name(): string {
    return 'MongoCursorInUseError';
  }
}


export class MongoServerClosedError extends MongoAPIError {
  
  constructor(message = 'Server is closed') {
    super(message);
  }

  override get name(): string {
    return 'MongoServerClosedError';
  }
}


export class MongoCursorExhaustedError extends MongoAPIError {
  
  constructor(message?: string) {
    super(message || 'Cursor is exhausted');
  }

  override get name(): string {
    return 'MongoCursorExhaustedError';
  }
}


export class MongoTopologyClosedError extends MongoAPIError {
  
  constructor(message = 'Topology is closed') {
    super(message);
  }

  override get name(): string {
    return 'MongoTopologyClosedError';
  }
}


export class MongoClientClosedError extends MongoAPIError {
  
  constructor() {
    super('Operation interrupted because client was closed');
  }

  override get name(): string {
    return 'MongoClientClosedError';
  }
}


export interface MongoNetworkErrorOptions {
  
  beforeHandshake?: boolean;
  cause?: Error;
}


export class MongoNetworkError extends MongoError {
  
  public readonly beforeHandshake: boolean;

  
  constructor(message: string, options?: MongoNetworkErrorOptions) {
    super(message, { cause: options?.cause });
    this.beforeHandshake = !!options?.beforeHandshake;
  }

  override get name(): string {
    return 'MongoNetworkError';
  }
}


export class MongoNetworkTimeoutError extends MongoNetworkError {
  
  constructor(message: string, options?: MongoNetworkErrorOptions) {
    super(message, options);
  }

  override get name(): string {
    return 'MongoNetworkTimeoutError';
  }
}


export class MongoParseError extends MongoDriverError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoParseError';
  }
}


export class MongoInvalidArgumentError extends MongoAPIError {
  
  constructor(message: string, options?: { cause?: Error }) {
    super(message, options);
  }

  override get name(): string {
    return 'MongoInvalidArgumentError';
  }
}


export class MongoCompatibilityError extends MongoAPIError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoCompatibilityError';
  }
}


export class MongoMissingCredentialsError extends MongoAPIError {
  
  constructor(message: string) {
    super(message);
  }

  override get name(): string {
    return 'MongoMissingCredentialsError';
  }
}


export class MongoMissingDependencyError extends MongoAPIError {
  dependencyName: string;

  
  declare cause: Error;

  
  constructor(message: string, options: { cause: Error; dependencyName: string }) {
    super(message, options);
    this.dependencyName = options.dependencyName;
  }

  override get name(): string {
    return 'MongoMissingDependencyError';
  }
}

export class MongoSystemError extends MongoError {
  
  reason?: TopologyDescription;

  
  constructor(message: string, reason: TopologyDescription) {
    if (reason && reason.error) {
      super(MongoError.buildErrorMessage(reason.error.message || reason.error), {
        cause: reason.error
      });
    } else {
      super(message);
    }

    if (reason) {
      this.reason = reason;
    }

    this.code = reason.error?.code;
  }

  override get name(): string {
    return 'MongoSystemError';
  }
}


export class MongoServerSelectionError extends MongoSystemError {
  
  constructor(message: string, reason: TopologyDescription) {
    super(message, reason);
  }

  override get name(): string {
    return 'MongoServerSelectionError';
  }
}


export interface WriteConcernErrorResult {
  writeConcernError: {
    code: number;
    errmsg: string;
    codeName?: string;
    errInfo?: Document;
  };
  ok: number;
  code?: number;
  errorLabels?: string[];
  [x: string | number]: unknown;
}


export class MongoWriteConcernError extends MongoServerError {
  
  result: Document;

  
  constructor(result: WriteConcernErrorResult) {
    super({ ...result.writeConcernError, ...result });
    this.errInfo = result.writeConcernError.errInfo;
    this.result = result;
  }

  override get name(): string {
    return 'MongoWriteConcernError';
  }
}


const RETRYABLE_READ_ERROR_CODES = new Set<number>([
  MONGODB_ERROR_CODES.HostUnreachable,
  MONGODB_ERROR_CODES.HostNotFound,
  MONGODB_ERROR_CODES.NetworkTimeout,
  MONGODB_ERROR_CODES.ShutdownInProgress,
  MONGODB_ERROR_CODES.PrimarySteppedDown,
  MONGODB_ERROR_CODES.SocketException,
  MONGODB_ERROR_CODES.NotWritablePrimary,
  MONGODB_ERROR_CODES.InterruptedAtShutdown,
  MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
  MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
  MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
  MONGODB_ERROR_CODES.ExceededTimeLimit,
  MONGODB_ERROR_CODES.ReadConcernMajorityNotAvailableYet
]);


const RETRYABLE_WRITE_ERROR_CODES = RETRYABLE_READ_ERROR_CODES;

export function needsRetryableWriteLabel(
  error: Error,
  maxWireVersion: number,
  serverType: ServerType
): boolean {
  
  
  if (error instanceof MongoNetworkError) {
    return true;
  }

  if (error instanceof MongoError) {
    if (
      (maxWireVersion >= 9 || isRetryableWriteError(error)) &&
      !error.hasErrorLabel(MongoErrorLabel.HandshakeError)
    ) {
      
      
      
      return false;
    }
  }

  if (error instanceof MongoWriteConcernError) {
    if (serverType === 'Mongos' && maxWireVersion < 9) {
      
      return RETRYABLE_WRITE_ERROR_CODES.has(error.result.code ?? 0);
    }
    const code = error.result.writeConcernError.code ?? Number(error.code);
    return RETRYABLE_WRITE_ERROR_CODES.has(Number.isNaN(code) ? 0 : code);
  }

  if (error instanceof MongoError) {
    return RETRYABLE_WRITE_ERROR_CODES.has(Number(error.code));
  }

  const isNotWritablePrimaryError = LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
  if (isNotWritablePrimaryError) {
    return true;
  }

  const isNodeIsRecoveringError = NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
  if (isNodeIsRecoveringError) {
    return true;
  }

  return false;
}

export function isRetryableWriteError(error: MongoError): boolean {
  return (
    error.hasErrorLabel(MongoErrorLabel.RetryableWriteError) ||
    error.hasErrorLabel(MongoErrorLabel.PoolRequstedRetry)
  );
}


export function isRetryableReadError(error: MongoError): boolean {
  const hasRetryableErrorCode =
    typeof error.code === 'number' ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;
  if (hasRetryableErrorCode) {
    return true;
  }

  if (error instanceof MongoNetworkError) {
    return true;
  }

  const isNotWritablePrimaryError = LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
  if (isNotWritablePrimaryError) {
    return true;
  }

  const isNodeIsRecoveringError = NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
  if (isNodeIsRecoveringError) {
    return true;
  }

  return false;
}

const SDAM_RECOVERING_CODES = new Set<number>([
  MONGODB_ERROR_CODES.ShutdownInProgress,
  MONGODB_ERROR_CODES.PrimarySteppedDown,
  MONGODB_ERROR_CODES.InterruptedAtShutdown,
  MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
  MONGODB_ERROR_CODES.NotPrimaryOrSecondary
]);

const SDAM_NOT_PRIMARY_CODES = new Set<number>([
  MONGODB_ERROR_CODES.NotWritablePrimary,
  MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
  MONGODB_ERROR_CODES.LegacyNotPrimary
]);

const SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set<number>([
  MONGODB_ERROR_CODES.InterruptedAtShutdown,
  MONGODB_ERROR_CODES.ShutdownInProgress
]);

function isRecoveringError(err: MongoError) {
  if (typeof err.code === 'number') {
    
    return SDAM_RECOVERING_CODES.has(err.code);
  }

  return (
    LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) ||
    NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message)
  );
}

function isNotWritablePrimaryError(err: MongoError) {
  if (typeof err.code === 'number') {
    
    return SDAM_NOT_PRIMARY_CODES.has(err.code);
  }

  if (isRecoveringError(err)) {
    return false;
  }

  return LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
}

export function isNodeShuttingDownError(err: MongoError): boolean {
  return !!(typeof err.code === 'number' && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
}


export function isSDAMUnrecoverableError(error: MongoError): boolean {
  
  
  if (error instanceof MongoParseError || error == null) {
    return true;
  }

  return isRecoveringError(error) || isNotWritablePrimaryError(error);
}

export function isNetworkTimeoutError(err: MongoError): err is MongoNetworkError {
  return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
}

export function isResumableError(error?: Error, wireVersion?: number): boolean {
  if (error == null || !(error instanceof MongoError)) {
    return false;
  }

  if (error instanceof MongoNetworkError) {
    return true;
  }

  if (wireVersion != null && wireVersion >= 9) {
    
    if (error.code === MONGODB_ERROR_CODES.CursorNotFound) {
      return true;
    }
    return error.hasErrorLabel(MongoErrorLabel.ResumableChangeStreamError);
  }

  if (typeof error.code === 'number') {
    return GET_MORE_RESUMABLE_CODES.has(error.code);
  }

  return false;
}
