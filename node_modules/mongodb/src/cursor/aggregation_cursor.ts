import type { Document } from '../bson';
import { MongoAPIError } from '../error';
import {
  Explain,
  ExplainableCursor,
  type ExplainCommandOptions,
  type ExplainVerbosityLike,
  validateExplainTimeoutOptions
} from '../explain';
import type { MongoClient } from '../mongo_client';
import { type Abortable } from '../mongo_types';
import { AggregateOperation, type AggregateOptions } from '../operations/aggregate';
import { executeOperation } from '../operations/execute_operation';
import type { ClientSession } from '../sessions';
import type { Sort } from '../sort';
import { mergeOptions, type MongoDBNamespace } from '../utils';
import {
  type AbstractCursorOptions,
  CursorTimeoutMode,
  type InitialCursorResponse
} from './abstract_cursor';


export interface AggregationCursorOptions extends AbstractCursorOptions, AggregateOptions {}


export class AggregationCursor<TSchema = any> extends ExplainableCursor<TSchema> {
  public readonly pipeline: Document[];
  
  private aggregateOptions: AggregateOptions & Abortable;

  
  constructor(
    client: MongoClient,
    namespace: MongoDBNamespace,
    pipeline: Document[] = [],
    options: AggregateOptions & Abortable = {}
  ) {
    super(client, namespace, options);

    this.pipeline = pipeline;
    this.aggregateOptions = options;

    const lastStage: Document | undefined = this.pipeline[this.pipeline.length - 1];

    if (
      this.cursorOptions.timeoutMS != null &&
      this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&
      (lastStage?.$merge != null || lastStage?.$out != null)
    )
      throw new MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');
  }

  clone(): AggregationCursor<TSchema> {
    const clonedOptions = mergeOptions({}, this.aggregateOptions);
    delete clonedOptions.session;
    return new AggregationCursor(this.client, this.namespace, this.pipeline, {
      ...clonedOptions
    });
  }

  override map<T>(transform: (doc: TSchema) => T): AggregationCursor<T> {
    return super.map(transform) as AggregationCursor<T>;
  }

  
  async _initialize(session: ClientSession): Promise<InitialCursorResponse> {
    const options = {
      ...this.aggregateOptions,
      ...this.cursorOptions,
      session,
      signal: this.signal
    };
    if (options.explain) {
      try {
        validateExplainTimeoutOptions(options, Explain.fromOptions(options));
      } catch {
        throw new MongoAPIError(
          'timeoutMS cannot be used with explain when explain is specified in aggregateOptions'
        );
      }
    }

    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, options);

    const response = await executeOperation(this.client, aggregateOperation, this.timeoutContext);

    return { server: aggregateOperation.server, session, response };
  }

  
  async explain(): Promise<Document>;
  async explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document>;
  async explain(options: { timeoutMS?: number }): Promise<Document>;
  async explain(
    verbosity: ExplainVerbosityLike | ExplainCommandOptions,
    options: { timeoutMS?: number }
  ): Promise<Document>;
  async explain(
    verbosity?: ExplainVerbosityLike | ExplainCommandOptions | { timeoutMS?: number },
    options?: { timeoutMS?: number }
  ): Promise<Document> {
    const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
    return (
      await executeOperation(
        this.client,
        new AggregateOperation(this.namespace, this.pipeline, {
          ...this.aggregateOptions, 
          ...this.cursorOptions,
          ...timeout,
          explain: explain ?? true
        })
      )
    ).shift(this.deserializationOptions);
  }

  
  addStage(stage: Document): this;
  addStage<T = Document>(stage: Document): AggregationCursor<T>;
  addStage<T = Document>(stage: Document): AggregationCursor<T> {
    this.throwIfInitialized();
    if (
      this.cursorOptions.timeoutMS != null &&
      this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&
      (stage.$out != null || stage.$merge != null)
    ) {
      throw new MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');
    }
    this.pipeline.push(stage);
    return this as unknown as AggregationCursor<T>;
  }

  
  group<T = TSchema>($group: Document): AggregationCursor<T>;
  group($group: Document): this {
    return this.addStage({ $group });
  }

  
  limit($limit: number): this {
    return this.addStage({ $limit });
  }

  
  match($match: Document): this {
    return this.addStage({ $match });
  }

  
  out($out: { db: string; coll: string } | string): this {
    return this.addStage({ $out });
  }

  
  project<T extends Document = Document>($project: Document): AggregationCursor<T> {
    return this.addStage<T>({ $project });
  }

  
  lookup($lookup: Document): this {
    return this.addStage({ $lookup });
  }

  
  redact($redact: Document): this {
    return this.addStage({ $redact });
  }

  
  skip($skip: number): this {
    return this.addStage({ $skip });
  }

  
  sort($sort: Sort): this {
    return this.addStage({ $sort });
  }

  
  unwind($unwind: Document | string): this {
    return this.addStage({ $unwind });
  }

  
  geoNear($geoNear: Document): this {
    return this.addStage({ $geoNear });
  }
}
