import { promises as fs } from 'fs';
import type { TcpNetConnectOpts } from 'net';
import type { ConnectionOptions as TLSConnectionOptions, TLSSocketOptions } from 'tls';

import { type BSONSerializeOptions, type Document, resolveBSONOptions } from './bson';
import { ChangeStream, type ChangeStreamDocument, type ChangeStreamOptions } from './change_stream';
import type { AutoEncrypter, AutoEncryptionOptions } from './client-side-encryption/auto_encrypter';
import {
  type AuthMechanismProperties,
  DEFAULT_ALLOWED_HOSTS,
  type MongoCredentials
} from './cmap/auth/mongo_credentials';
import { type TokenCache } from './cmap/auth/mongodb_oidc/token_cache';
import { AuthMechanism } from './cmap/auth/providers';
import type { LEGAL_TCP_SOCKET_OPTIONS, LEGAL_TLS_SOCKET_OPTIONS } from './cmap/connect';
import type { Connection } from './cmap/connection';
import {
  addContainerMetadata,
  type ClientMetadata,
  makeClientMetadata
} from './cmap/handshake/client_metadata';
import type { CompressorName } from './cmap/wire_protocol/compression';
import { parseOptions, resolveSRVRecord } from './connection_string';
import { MONGO_CLIENT_EVENTS } from './constants';
import { type AbstractCursor } from './cursor/abstract_cursor';
import { Db, type DbOptions } from './db';
import type { Encrypter } from './encrypter';
import { MongoInvalidArgumentError } from './error';
import { MongoClientAuthProviders } from './mongo_client_auth_providers';
import {
  type LogComponentSeveritiesClientOptions,
  type MongoDBLogWritable,
  MongoLogger,
  type MongoLoggerOptions,
  SeverityLevel
} from './mongo_logger';
import { TypedEventEmitter } from './mongo_types';
import {
  type ClientBulkWriteModel,
  type ClientBulkWriteOptions,
  type ClientBulkWriteResult
} from './operations/client_bulk_write/common';
import { ClientBulkWriteExecutor } from './operations/client_bulk_write/executor';
import { executeOperation } from './operations/execute_operation';
import { RunAdminCommandOperation } from './operations/run_command';
import type { ReadConcern, ReadConcernLevel, ReadConcernLike } from './read_concern';
import { ReadPreference, type ReadPreferenceMode } from './read_preference';
import { type AsyncDisposable, configureResourceManagement } from './resource_management';
import type { ServerMonitoringMode } from './sdam/monitor';
import type { TagSet } from './sdam/server_description';
import { readPreferenceServerSelector } from './sdam/server_selection';
import type { SrvPoller } from './sdam/srv_polling';
import { Topology, type TopologyEvents } from './sdam/topology';
import { ClientSession, type ClientSessionOptions, ServerSessionPool } from './sessions';
import {
  COSMOS_DB_CHECK,
  COSMOS_DB_MSG,
  DOCUMENT_DB_CHECK,
  DOCUMENT_DB_MSG,
  type HostAddress,
  hostMatchesWildcards,
  isHostMatch,
  type MongoDBNamespace,
  noop,
  ns,
  resolveOptions,
  squashError
} from './utils';
import type { W, WriteConcern, WriteConcernSettings } from './write_concern';


export const ServerApiVersion = Object.freeze({
  v1: '1'
} as const);


export type ServerApiVersion = (typeof ServerApiVersion)[keyof typeof ServerApiVersion];


export interface ServerApi {
  version: ServerApiVersion;
  strict?: boolean;
  deprecationErrors?: boolean;
}


export interface DriverInfo {
  name?: string;
  version?: string;
  platform?: string;
}


export interface Auth {
  
  username?: string;
  
  password?: string;
}


export interface PkFactory {
  createPk(): any;
}


export type SupportedTLSConnectionOptions = Pick<
  TLSConnectionOptions & {
    allowPartialTrustChain?: boolean;
  },
  (typeof LEGAL_TLS_SOCKET_OPTIONS)[number]
>;


export type SupportedTLSSocketOptions = Pick<
  TLSSocketOptions,
  Extract<keyof TLSSocketOptions, (typeof LEGAL_TLS_SOCKET_OPTIONS)[number]>
>;


export type SupportedSocketOptions = Pick<
  TcpNetConnectOpts & {
    autoSelectFamily?: boolean;
    autoSelectFamilyAttemptTimeout?: number;
    
    keepAliveInitialDelay?: number;
  },
  (typeof LEGAL_TCP_SOCKET_OPTIONS)[number]
>;


export type SupportedNodeConnectionOptions = SupportedTLSConnectionOptions &
  SupportedTLSSocketOptions &
  SupportedSocketOptions;


export interface MongoClientOptions extends BSONSerializeOptions, SupportedNodeConnectionOptions {
  
  replicaSet?: string;
  
  timeoutMS?: number;
  
  tls?: boolean;
  
  ssl?: boolean;
  
  tlsCertificateKeyFile?: string;
  
  tlsCertificateKeyFilePassword?: string;
  
  tlsCAFile?: string;
  
  tlsCRLFile?: string;
  
  tlsAllowInvalidCertificates?: boolean;
  
  tlsAllowInvalidHostnames?: boolean;
  
  tlsInsecure?: boolean;
  
  connectTimeoutMS?: number;
  
  socketTimeoutMS?: number;
  
  compressors?: CompressorName[] | string;
  
  zlibCompressionLevel?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | undefined;
  
  srvMaxHosts?: number;
  
  srvServiceName?: string;
  
  maxPoolSize?: number;
  
  minPoolSize?: number;
  
  maxConnecting?: number;
  
  maxIdleTimeMS?: number;
  
  waitQueueTimeoutMS?: number;
  
  readConcern?: ReadConcernLike;
  
  readConcernLevel?: ReadConcernLevel;
  
  readPreference?: ReadPreferenceMode | ReadPreference;
  
  maxStalenessSeconds?: number;
  
  readPreferenceTags?: TagSet[];
  
  auth?: Auth;
  
  authSource?: string;
  
  authMechanism?: AuthMechanism;
  
  authMechanismProperties?: AuthMechanismProperties;
  
  localThresholdMS?: number;
  
  serverSelectionTimeoutMS?: number;
  
  heartbeatFrequencyMS?: number;
  
  minHeartbeatFrequencyMS?: number;
  
  appName?: string;
  
  retryReads?: boolean;
  
  retryWrites?: boolean;
  
  directConnection?: boolean;
  
  loadBalanced?: boolean;
  
  w?: W;
  
  wtimeoutMS?: number;
  
  journal?: boolean;
  
  writeConcern?: WriteConcern | WriteConcernSettings;
  
  noDelay?: boolean;
  
  forceServerObjectId?: boolean;
  
  pkFactory?: PkFactory;
  
  monitorCommands?: boolean;
  
  serverApi?: ServerApi | ServerApiVersion;
  
  autoEncryption?: AutoEncryptionOptions;
  
  driverInfo?: DriverInfo;
  
  proxyHost?: string;
  
  proxyPort?: number;
  
  proxyUsername?: string;
  
  proxyPassword?: string;
  
  serverMonitoringMode?: ServerMonitoringMode;
  
  mongodbLogPath?: 'stderr' | 'stdout' | MongoDBLogWritable;
  
  mongodbLogComponentSeverities?: LogComponentSeveritiesClientOptions;
  
  mongodbLogMaxDocumentLength?: number;

  
  srvPoller?: SrvPoller;
  
  connectionType?: typeof Connection;
  
  __skipPingOnConnect?: boolean;
}


export type WithSessionCallback<T = unknown> = (session: ClientSession) => Promise<T>;


export interface MongoClientPrivate {
  url: string;
  bsonOptions: BSONSerializeOptions;
  namespace: MongoDBNamespace;
  hasBeenClosed: boolean;
  authProviders: MongoClientAuthProviders;
  
  readonly activeSessions: Set<ClientSession>;
  
  readonly activeCursors: Set<AbstractCursor>;
  readonly sessionPool: ServerSessionPool;
  readonly options: MongoOptions;
  readonly readConcern?: ReadConcern;
  readonly writeConcern?: WriteConcern;
  readonly readPreference: ReadPreference;
  readonly isMongoClient: true;
}


export type MongoClientEvents = Pick<TopologyEvents, (typeof MONGO_CLIENT_EVENTS)[number]> & {
  
  
  open(mongoClient: MongoClient): void;
};


export class MongoClient extends TypedEventEmitter<MongoClientEvents> implements AsyncDisposable {
  
  s: MongoClientPrivate;
  
  topology?: Topology;
  
  override readonly mongoLogger: MongoLogger | undefined;
  
  private connectionLock?: Promise<this>;
  
  private closeLock?: Promise<void>;

  
  public readonly options: Readonly<
    Omit<
      MongoOptions,
      | 'monitorCommands'
      | 'ca'
      | 'crl'
      | 'key'
      | 'cert'
      | 'driverInfo'
      | 'additionalDriverInfo'
      | 'metadata'
      | 'extendedMetadata'
    >
  > &
    Pick<
      MongoOptions,
      | 'monitorCommands'
      | 'ca'
      | 'crl'
      | 'key'
      | 'cert'
      | 'driverInfo'
      | 'additionalDriverInfo'
      | 'metadata'
      | 'extendedMetadata'
    >;

  constructor(url: string, options?: MongoClientOptions) {
    super();
    this.on('error', noop);

    this.options = parseOptions(url, this, options);

    const shouldSetLogger = Object.values(this.options.mongoLoggerOptions.componentSeverities).some(
      value => value !== SeverityLevel.OFF
    );
    this.mongoLogger = shouldSetLogger
      ? new MongoLogger(this.options.mongoLoggerOptions)
      : undefined;

    
    const client = this;

    
    this.s = {
      url,
      bsonOptions: resolveBSONOptions(this.options),
      namespace: ns('admin'),
      hasBeenClosed: false,
      sessionPool: new ServerSessionPool(this),
      activeSessions: new Set(),
      activeCursors: new Set(),
      authProviders: new MongoClientAuthProviders(),

      get options() {
        return client.options;
      },
      get readConcern() {
        return client.options.readConcern;
      },
      get writeConcern() {
        return client.options.writeConcern;
      },
      get readPreference() {
        return client.options.readPreference;
      },
      get isMongoClient(): true {
        return true;
      }
    };
    this.checkForNonGenuineHosts();
  }

  
  declare [Symbol.asyncDispose]: () => Promise<void>;
  
  async asyncDispose() {
    await this.close();
  }

  
  appendMetadata(driverInfo: DriverInfo) {
    this.options.additionalDriverInfo.push(driverInfo);
    this.options.metadata = makeClientMetadata(this.options);
    this.options.extendedMetadata = addContainerMetadata(this.options.metadata)
      .then(undefined, squashError)
      .then(result => result ?? {}); 
  }

  
  private checkForNonGenuineHosts() {
    const documentDBHostnames = this.options.hosts.filter((hostAddress: HostAddress) =>
      isHostMatch(DOCUMENT_DB_CHECK, hostAddress.host)
    );
    const srvHostIsDocumentDB = isHostMatch(DOCUMENT_DB_CHECK, this.options.srvHost);

    const cosmosDBHostnames = this.options.hosts.filter((hostAddress: HostAddress) =>
      isHostMatch(COSMOS_DB_CHECK, hostAddress.host)
    );
    const srvHostIsCosmosDB = isHostMatch(COSMOS_DB_CHECK, this.options.srvHost);

    if (documentDBHostnames.length !== 0 || srvHostIsDocumentDB) {
      this.mongoLogger?.info('client', DOCUMENT_DB_MSG);
    } else if (cosmosDBHostnames.length !== 0 || srvHostIsCosmosDB) {
      this.mongoLogger?.info('client', COSMOS_DB_MSG);
    }
  }

  get serverApi(): Readonly<ServerApi | undefined> {
    return this.options.serverApi && Object.freeze({ ...this.options.serverApi });
  }
  
  get monitorCommands(): boolean {
    return this.options.monitorCommands;
  }
  set monitorCommands(value: boolean) {
    this.options.monitorCommands = value;
  }

  
  get autoEncrypter(): AutoEncrypter | undefined {
    return this.options.autoEncrypter;
  }

  get readConcern(): ReadConcern | undefined {
    return this.s.readConcern;
  }

  get writeConcern(): WriteConcern | undefined {
    return this.s.writeConcern;
  }

  get readPreference(): ReadPreference {
    return this.s.readPreference;
  }

  get bsonOptions(): BSONSerializeOptions {
    return this.s.bsonOptions;
  }

  get timeoutMS(): number | undefined {
    return this.s.options.timeoutMS;
  }

  
  async bulkWrite<SchemaMap extends Record<string, Document> = Record<string, Document>>(
    models: ReadonlyArray<ClientBulkWriteModel<SchemaMap>>,
    options?: ClientBulkWriteOptions
  ): Promise<ClientBulkWriteResult> {
    if (this.autoEncrypter) {
      throw new MongoInvalidArgumentError(
        'MongoClient bulkWrite does not currently support automatic encryption.'
      );
    }
    
    return await new ClientBulkWriteExecutor(
      this,
      models as any,
      resolveOptions(this, options)
    ).execute();
  }

  
  async connect(): Promise<this> {
    if (this.connectionLock) {
      return await this.connectionLock;
    }

    try {
      this.connectionLock = this._connect();
      await this.connectionLock;
    } finally {
      
      this.connectionLock = undefined;
    }

    return this;
  }

  
  private async _connect(): Promise<this> {
    if (this.topology && this.topology.isConnected()) {
      return this;
    }

    const options = this.options;

    if (options.tls) {
      if (typeof options.tlsCAFile === 'string') {
        options.ca ??= await fs.readFile(options.tlsCAFile);
      }
      if (typeof options.tlsCRLFile === 'string') {
        options.crl ??= await fs.readFile(options.tlsCRLFile);
      }
      if (typeof options.tlsCertificateKeyFile === 'string') {
        if (!options.key || !options.cert) {
          const contents = await fs.readFile(options.tlsCertificateKeyFile);
          options.key ??= contents;
          options.cert ??= contents;
        }
      }
    }
    if (typeof options.srvHost === 'string') {
      const hosts = await resolveSRVRecord(options);

      for (const [index, host] of hosts.entries()) {
        options.hosts[index] = host;
      }
    }

    
    
    if (options.credentials?.mechanism === AuthMechanism.MONGODB_OIDC) {
      const allowedHosts =
        options.credentials?.mechanismProperties?.ALLOWED_HOSTS || DEFAULT_ALLOWED_HOSTS;
      const isServiceAuth = !!options.credentials?.mechanismProperties?.ENVIRONMENT;
      if (!isServiceAuth) {
        for (const host of options.hosts) {
          if (!hostMatchesWildcards(host.toHostPort().host, allowedHosts)) {
            throw new MongoInvalidArgumentError(
              `Host '${host}' is not valid for OIDC authentication with ALLOWED_HOSTS of '${allowedHosts.join(
                ','
              )}'`
            );
          }
        }
      }
    }

    this.topology = new Topology(this, options.hosts, options);
    
    

    this.topology.once(Topology.OPEN, () => this.emit('open', this));

    for (const event of MONGO_CLIENT_EVENTS) {
      this.topology.on(event, (...args: any[]) => this.emit(event, ...(args as any)));
    }

    const topologyConnect = async () => {
      try {
        await this.topology?.connect(options);
      } catch (error) {
        this.topology?.close();
        throw error;
      }
    };

    if (this.autoEncrypter) {
      await this.autoEncrypter?.init();
      await topologyConnect();
      await options.encrypter.connectInternalClient();
    } else {
      await topologyConnect();
    }

    return this;
  }

  
  async close(_force = false): Promise<void> {
    if (this.closeLock) {
      return await this.closeLock;
    }

    try {
      this.closeLock = this._close();
      await this.closeLock;
    } finally {
      
      this.closeLock = undefined;
    }
  }

  
  private async _close(): Promise<void> {
    
    Object.defineProperty(this.s, 'hasBeenClosed', {
      value: true,
      enumerable: true,
      configurable: false,
      writable: false
    });

    this.topology?.closeCheckedOutConnections();

    const activeCursorCloses = Array.from(this.s.activeCursors, cursor => cursor.close());
    this.s.activeCursors.clear();

    await Promise.all(activeCursorCloses);

    const activeSessionEnds = Array.from(this.s.activeSessions, session => session.endSession());
    this.s.activeSessions.clear();

    await Promise.all(activeSessionEnds);

    if (this.topology == null) {
      return;
    }

    
    
    const selector = readPreferenceServerSelector(ReadPreference.primaryPreferred);
    const topologyDescription = this.topology.description;
    const serverDescriptions = Array.from(topologyDescription.servers.values());
    const servers = selector(topologyDescription, serverDescriptions);
    if (servers.length !== 0) {
      const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
      if (endSessions.length !== 0) {
        try {
          await executeOperation(
            this,
            new RunAdminCommandOperation(
              { endSessions },
              { readPreference: ReadPreference.primaryPreferred, noResponse: true }
            )
          );
        } catch (error) {
          squashError(error);
        }
      }
    }

    
    const topology = this.topology;
    this.topology = undefined;

    topology.close();

    const { encrypter } = this.options;
    if (encrypter) {
      await encrypter.close(this);
    }
  }

  
  db(dbName?: string, options?: DbOptions): Db {
    options = options ?? {};

    
    if (!dbName) {
      dbName = this.s.options.dbName;
    }

    
    const finalOptions = Object.assign({}, this.options, options);

    
    const db = new Db(this, dbName, finalOptions);

    
    return db;
  }

  
  static async connect(url: string, options?: MongoClientOptions): Promise<MongoClient> {
    const client = new this(url, options);
    return await client.connect();
  }

  
  startSession(options?: ClientSessionOptions): ClientSession {
    const session = new ClientSession(
      this,
      this.s.sessionPool,
      { explicit: true, ...options },
      this.options
    );
    this.s.activeSessions.add(session);
    session.once('ended', () => {
      this.s.activeSessions.delete(session);
    });
    return session;
  }

  
  async withSession<T = any>(executor: WithSessionCallback<T>): Promise<T>;
  async withSession<T = any>(
    options: ClientSessionOptions,
    executor: WithSessionCallback<T>
  ): Promise<T>;
  async withSession<T = any>(
    optionsOrExecutor: ClientSessionOptions | WithSessionCallback<T>,
    executor?: WithSessionCallback<T>
  ): Promise<T> {
    const options = {
      
      owner: Symbol(),
      
      ...(typeof optionsOrExecutor === 'object' ? optionsOrExecutor : {})
    };

    const withSessionCallback =
      typeof optionsOrExecutor === 'function' ? optionsOrExecutor : executor;

    if (withSessionCallback == null) {
      throw new MongoInvalidArgumentError('Missing required callback parameter');
    }

    const session = this.startSession(options);

    try {
      return await withSessionCallback(session);
    } finally {
      try {
        await session.endSession();
      } catch (error) {
        squashError(error);
      }
    }
  }

  
  watch<
    TSchema extends Document = Document,
    TChange extends Document = ChangeStreamDocument<TSchema>
  >(pipeline: Document[] = [], options: ChangeStreamOptions = {}): ChangeStream<TSchema, TChange> {
    
    if (!Array.isArray(pipeline)) {
      options = pipeline;
      pipeline = [];
    }

    return new ChangeStream<TSchema, TChange>(this, pipeline, resolveOptions(this, options));
  }
}

configureResourceManagement(MongoClient.prototype);


export interface MongoOptions
  extends Required<
      Pick<
        MongoClientOptions,
        | 'autoEncryption'
        | 'connectTimeoutMS'
        | 'directConnection'
        | 'driverInfo'
        | 'forceServerObjectId'
        | 'minHeartbeatFrequencyMS'
        | 'heartbeatFrequencyMS'
        | 'localThresholdMS'
        | 'maxConnecting'
        | 'maxIdleTimeMS'
        | 'maxPoolSize'
        | 'minPoolSize'
        | 'monitorCommands'
        | 'noDelay'
        | 'pkFactory'
        | 'raw'
        | 'replicaSet'
        | 'retryReads'
        | 'retryWrites'
        | 'serverSelectionTimeoutMS'
        | 'socketTimeoutMS'
        | 'srvMaxHosts'
        | 'srvServiceName'
        | 'tlsAllowInvalidCertificates'
        | 'tlsAllowInvalidHostnames'
        | 'tlsInsecure'
        | 'waitQueueTimeoutMS'
        | 'zlibCompressionLevel'
      >
    >,
    SupportedNodeConnectionOptions {
  appName?: string;
  hosts: HostAddress[];
  srvHost?: string;
  credentials?: MongoCredentials;
  readPreference: ReadPreference;
  readConcern: ReadConcern;
  loadBalanced: boolean;
  directConnection: boolean;
  serverApi: ServerApi;
  compressors: CompressorName[];
  writeConcern: WriteConcern;
  dbName: string;
  
  metadata: ClientMetadata;
  extendedMetadata: Promise<Document>;
  additionalDriverInfo: DriverInfo[];
  
  autoEncrypter?: AutoEncrypter;
  
  tokenCache?: TokenCache;
  proxyHost?: string;
  proxyPort?: number;
  proxyUsername?: string;
  proxyPassword?: string;
  serverMonitoringMode: ServerMonitoringMode;
  
  connectionType?: typeof Connection;
  
  authProviders: MongoClientAuthProviders;
  
  encrypter: Encrypter;
  
  userSpecifiedAuthSource: boolean;
  
  userSpecifiedReplicaSet: boolean;

  
  tls: boolean;
  tlsCAFile?: string;
  tlsCRLFile?: string;
  tlsCertificateKeyFile?: string;

  
  mongoLoggerOptions: MongoLoggerOptions;
  
  mongodbLogPath?: 'stderr' | 'stdout' | MongoDBLogWritable;
  timeoutMS?: number;
  
  __skipPingOnConnect?: boolean;
}
