import type { DeserializeOptions } from 'bson';
import type { ObjectIdLike } from 'bson';
import type { SerializeOptions } from 'bson';
import { Binary } from 'bson';
import { BSON } from 'bson';
import { BSONRegExp } from 'bson';
import { BSONSymbol } from 'bson';
import { BSONType } from 'bson';
import { Code } from 'bson';
import { DBRef } from 'bson';
import { Decimal128 } from 'bson';
import { deserialize } from 'bson';
import { Document } from 'bson';
import { Double } from 'bson';
import { Int32 } from 'bson';
import { Long } from 'bson';
import { MaxKey } from 'bson';
import { MinKey } from 'bson';
import { ObjectId } from 'bson';
import { serialize } from 'bson';
import { Timestamp } from 'bson';
import { UUID } from 'bson';
import type { SrvRecord } from 'dns';
import { EventEmitter } from 'events';
import type { Socket } from 'net';
import type { TcpNetConnectOpts } from 'net';
import { Readable } from 'stream';
import { Writable } from 'stream';
import type { ConnectionOptions as ConnectionOptions_2 } from 'tls';
import type { TLSSocket } from 'tls';
import type { TLSSocketOptions } from 'tls';


export declare type Abortable = {
    
    signal?: AbortSignal | undefined;
};


export declare abstract class AbstractCursor<TSchema = any, CursorEvents extends AbstractCursorEvents = AbstractCursorEvents> extends TypedEventEmitter<CursorEvents> implements AsyncDisposable_2 {
    
    
    
    
    
    
    
    
    
    
    
    
    
    static readonly CLOSE: "close";
    
    protected signal: AbortSignal | undefined;
    private abortListener;
    
    
    get id(): Long | undefined;
    
    
    
    get namespace(): MongoDBNamespace;
    get readPreference(): ReadPreference;
    get readConcern(): ReadConcern | undefined;
    
    
    
    get closed(): boolean;
    
    get killed(): boolean;
    get loadBalanced(): boolean;
    
    [Symbol.asyncDispose]: () => Promise<void>;
    
    
    private trackCursor;
    
    bufferedCount(): number;
    
    readBufferedDocuments(number?: number): NonNullable<TSchema>[];
    [Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void>;
    stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema>;
    hasNext(): Promise<boolean>;
    
    next(): Promise<TSchema | null>;
    
    tryNext(): Promise<TSchema | null>;
    
    forEach(iterator: (doc: TSchema) => boolean | void): Promise<void>;
    
    close(options?: {
        timeoutMS?: number;
    }): Promise<void>;
    
    toArray(): Promise<TSchema[]>;
    
    addCursorFlag(flag: CursorFlag, value: boolean): this;
    
    map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T>;
    
    withReadPreference(readPreference: ReadPreferenceLike): this;
    
    withReadConcern(readConcern: ReadConcernLike): this;
    
    maxTimeMS(value: number): this;
    
    batchSize(value: number): this;
    
    rewind(): void;
    
    abstract clone(): AbstractCursor<TSchema>;
    
    
    
    
    
    
    
    
    
}


export declare type AbstractCursorEvents = {
    [AbstractCursor.CLOSE](): void;
};


export declare interface AbstractCursorOptions extends BSONSerializeOptions {
    session?: ClientSession;
    readPreference?: ReadPreferenceLike;
    readConcern?: ReadConcernLike;
    
    batchSize?: number;
    
    maxTimeMS?: number;
    
    maxAwaitTimeMS?: number;
    
    comment?: unknown;
    
    tailable?: boolean;
    
    awaitData?: boolean;
    noCursorTimeout?: boolean;
    
    timeoutMS?: number;
    
    timeoutMode?: CursorTimeoutMode;
    
}




export declare type AcceptedFields<TSchema, FieldType, AssignableType> = {
    readonly [key in KeysOfAType<TSchema, FieldType>]?: AssignableType;
};


export declare type AddToSetOperators<Type> = {
    $each?: Array<Flatten<Type>>;
};


export declare class Admin {
    
    
    
    command(command: Document, options?: RunCommandOptions): Promise<Document>;
    
    buildInfo(options?: CommandOperationOptions): Promise<Document>;
    
    serverInfo(options?: CommandOperationOptions): Promise<Document>;
    
    serverStatus(options?: CommandOperationOptions): Promise<Document>;
    
    ping(options?: CommandOperationOptions): Promise<Document>;
    
    removeUser(username: string, options?: RemoveUserOptions): Promise<boolean>;
    
    validateCollection(collectionName: string, options?: ValidateCollectionOptions): Promise<Document>;
    
    listDatabases(options?: ListDatabasesOptions): Promise<ListDatabasesResult>;
    
    replSetGetStatus(options?: CommandOperationOptions): Promise<Document>;
}






export declare interface AggregateOptions extends Omit<CommandOperationOptions, 'explain'> {
    
    allowDiskUse?: boolean;
    
    batchSize?: number;
    
    bypassDocumentValidation?: boolean;
    
    cursor?: Document;
    
    maxTimeMS?: number;
    
    maxAwaitTimeMS?: number;
    
    collation?: CollationOptions;
    
    hint?: Hint;
    
    let?: Document;
    out?: string;
    
    explain?: ExplainOptions['explain'];
    
}


export declare class AggregationCursor<TSchema = any> extends ExplainableCursor<TSchema> {
    readonly pipeline: Document[];
    
    
    clone(): AggregationCursor<TSchema>;
    map<T>(transform: (doc: TSchema) => T): AggregationCursor<T>;
    
    
    explain(): Promise<Document>;
    explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document>;
    explain(options: {
        timeoutMS?: number;
    }): Promise<Document>;
    explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions, options: {
        timeoutMS?: number;
    }): Promise<Document>;
    
    addStage(stage: Document): this;
    addStage<T = Document>(stage: Document): AggregationCursor<T>;
    
    group<T = TSchema>($group: Document): AggregationCursor<T>;
    
    limit($limit: number): this;
    
    match($match: Document): this;
    
    out($out: {
        db: string;
        coll: string;
    } | string): this;
    
    project<T extends Document = Document>($project: Document): AggregationCursor<T>;
    
    lookup($lookup: Document): this;
    
    redact($redact: Document): this;
    
    skip($skip: number): this;
    
    sort($sort: Sort): this;
    
    unwind($unwind: Document | string): this;
    
    geoNear($geoNear: Document): this;
}


export declare interface AggregationCursorOptions extends AbstractCursorOptions, AggregateOptions {
}


export declare type AlternativeType<T> = T extends ReadonlyArray<infer U> ? T | RegExpOrString<U> : RegExpOrString<T>;


export declare type AnyBulkWriteOperation<TSchema extends Document = Document> = {
    insertOne: InsertOneModel<TSchema>;
} | {
    replaceOne: ReplaceOneModel<TSchema>;
} | {
    updateOne: UpdateOneModel<TSchema>;
} | {
    updateMany: UpdateManyModel<TSchema>;
} | {
    deleteOne: DeleteOneModel<TSchema>;
} | {
    deleteMany: DeleteManyModel<TSchema>;
};


export declare type AnyClientBulkWriteModel<TSchema extends Document> = ClientInsertOneModel<TSchema> | ClientReplaceOneModel<TSchema> | ClientUpdateOneModel<TSchema> | ClientUpdateManyModel<TSchema> | ClientDeleteOneModel<TSchema> | ClientDeleteManyModel<TSchema>;


export declare type AnyError = MongoError | Error;


export declare type ArrayElement<Type> = Type extends ReadonlyArray<infer Item> ? Item : never;


export declare type ArrayOperator<Type> = {
    $each?: Array<Flatten<Type>>;
    $slice?: number;
    $position?: number;
    $sort?: Sort;
};


declare interface AsyncDisposable_2 {
    
    [Symbol.asyncDispose](): Promise<void>;
    
}
export { AsyncDisposable_2 as AsyncDisposable }


export declare interface Auth {
    
    username?: string;
    
    password?: string;
}




export declare const AuthMechanism: Readonly<{
    readonly MONGODB_AWS: "MONGODB-AWS";
    readonly MONGODB_CR: "MONGODB-CR";
    readonly MONGODB_DEFAULT: "DEFAULT";
    readonly MONGODB_GSSAPI: "GSSAPI";
    readonly MONGODB_PLAIN: "PLAIN";
    readonly MONGODB_SCRAM_SHA1: "SCRAM-SHA-1";
    readonly MONGODB_SCRAM_SHA256: "SCRAM-SHA-256";
    readonly MONGODB_X509: "MONGODB-X509";
    readonly MONGODB_OIDC: "MONGODB-OIDC";
}>;


export declare type AuthMechanism = (typeof AuthMechanism)[keyof typeof AuthMechanism];


export declare interface AuthMechanismProperties extends Document {
    SERVICE_HOST?: string;
    SERVICE_NAME?: string;
    SERVICE_REALM?: string;
    CANONICALIZE_HOST_NAME?: GSSAPICanonicalizationValue;
    AWS_SESSION_TOKEN?: string;
    
    OIDC_CALLBACK?: OIDCCallbackFunction;
    
    OIDC_HUMAN_CALLBACK?: OIDCCallbackFunction;
    
    ENVIRONMENT?: 'test' | 'azure' | 'gcp' | 'k8s';
    
    ALLOWED_HOSTS?: string[];
    
    TOKEN_RESOURCE?: string;
    
    AWS_CREDENTIAL_PROVIDER?: AWSCredentialProvider;
}






export declare type AutoEncryptionExtraOptions = NonNullable<AutoEncryptionOptions['extraOptions']>;


export declare const AutoEncryptionLoggerLevel: Readonly<{
    readonly FatalError: 0;
    readonly Error: 1;
    readonly Warning: 2;
    readonly Info: 3;
    readonly Trace: 4;
}>;


export declare type AutoEncryptionLoggerLevel = (typeof AutoEncryptionLoggerLevel)[keyof typeof AutoEncryptionLoggerLevel];


export declare interface AutoEncryptionOptions {
    
    
    keyVaultClient?: MongoClient;
    
    keyVaultNamespace?: string;
    
    kmsProviders?: KMSProviders;
    
    credentialProviders?: CredentialProviders;
    
    schemaMap?: Document;
    
    encryptedFieldsMap?: Document;
    
    bypassAutoEncryption?: boolean;
    
    bypassQueryAnalysis?: boolean;
    
    keyExpirationMS?: number;
    options?: {
        
        logger?: (level: AutoEncryptionLoggerLevel, message: string) => void;
    };
    extraOptions?: {
        
        mongocryptdURI?: string;
        
        mongocryptdBypassSpawn?: boolean;
        
        mongocryptdSpawnPath?: string;
        
        mongocryptdSpawnArgs?: string[];
        
        cryptSharedLibPath?: string;
        
        cryptSharedLibRequired?: boolean;
        
    };
    proxyOptions?: ProxyOptions;
    
    tlsOptions?: CSFLEKMSTlsOptions;
}


export declare type AWSCredentialProvider = () => Promise<AWSCredentials>;


export declare interface AWSCredentials {
    accessKeyId: string;
    secretAccessKey: string;
    sessionToken?: string;
    expiration?: Date;
}


export declare interface AWSEncryptionKeyOptions {
    
    region: string;
    
    key: string;
    
    endpoint?: string | undefined;
}


export declare interface AWSKMSProviderConfiguration {
    
    accessKeyId: string;
    
    secretAccessKey: string;
    
    sessionToken?: string;
}


export declare interface AzureEncryptionKeyOptions {
    
    keyName: string;
    
    keyVaultEndpoint: string;
    
    keyVersion?: string | undefined;
}


export declare type AzureKMSProviderConfiguration = {
    
    tenantId: string;
    
    clientId: string;
    
    clientSecret: string;
    
    identityPlatformEndpoint?: string | undefined;
} | {
    
    accessToken: string;
};


export declare class Batch<T = Document> {
    originalZeroIndex: number;
    currentIndex: number;
    originalIndexes: number[];
    batchType: BatchType;
    operations: T[];
    size: number;
    sizeBytes: number;
    constructor(batchType: BatchType, originalZeroIndex: number);
}


export declare const BatchType: Readonly<{
    readonly INSERT: 1;
    readonly UPDATE: 2;
    readonly DELETE: 3;
}>;


export declare type BatchType = (typeof BatchType)[keyof typeof BatchType];

export { Binary }


export declare type BitwiseFilter = number  | Binary  | ReadonlyArray<number>;

export { BSON }


export { BSONRegExp }


export declare interface BSONSerializeOptions extends Omit<SerializeOptions, 'index'>, Omit<DeserializeOptions, 'evalFunctions' | 'cacheFunctions' | 'cacheFunctionsCrc32' | 'allowObjectSmallerThanBufferSize' | 'index' | 'validation'> {
    
    raw?: boolean;
    
    enableUtf8Validation?: boolean;
}

export { BSONSymbol }

export { BSONType }


export declare type BSONTypeAlias = keyof typeof BSONType;




export declare abstract class BulkOperationBase {
    isOrdered: boolean;
    
    operationId?: number;
    private collection;
    
    
    insert(document: Document): BulkOperationBase;
    
    find(selector: Document): FindOperators;
    
    raw(op: AnyBulkWriteOperation): this;
    get length(): number;
    get bsonOptions(): BSONSerializeOptions;
    get writeConcern(): WriteConcern | undefined;
    get batches(): Batch[];
    execute(options?: BulkWriteOptions): Promise<BulkWriteResult>;
    
    abstract addToOperationsList(batchType: BatchType, document: Document | UpdateStatement | DeleteStatement): this;
    private shouldForceServerObjectId;
}






export declare interface BulkWriteOperationError {
    index: number;
    code: number;
    errmsg: string;
    errInfo: Document;
    op: Document | UpdateStatement | DeleteStatement;
}


export declare interface BulkWriteOptions extends CommandOperationOptions {
    
    bypassDocumentValidation?: boolean;
    
    ordered?: boolean;
    
    forceServerObjectId?: boolean;
    
    let?: Document;
    
}


export declare class BulkWriteResult {
    private readonly result;
    
    readonly insertedCount: number;
    
    readonly matchedCount: number;
    
    readonly modifiedCount: number;
    
    readonly deletedCount: number;
    
    readonly upsertedCount: number;
    
    readonly upsertedIds: {
        [key: number]: any;
    };
    
    readonly insertedIds: {
        [key: number]: any;
    };
    private static generateIdMap;
    
    
    get ok(): number;
    
    
    getUpsertedIdAt(index: number): Document | undefined;
    
    getRawResponse(): Document;
    
    hasWriteErrors(): boolean;
    
    getWriteErrorCount(): number;
    
    getWriteErrorAt(index: number): WriteError | undefined;
    
    getWriteErrors(): WriteError[];
    
    getWriteConcernError(): WriteConcernError | undefined;
    toString(): string;
    isOk(): boolean;
}


export declare type Callback<T = any> = (error?: AnyError, result?: T) => void;


export declare class CancellationToken extends TypedEventEmitter<{
    cancel(): void;
}> {
    constructor(...args: any[]);
}


export declare class ChangeStream<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>> extends TypedEventEmitter<ChangeStreamEvents<TSchema, TChange>> implements AsyncDisposable_2 {
    
    [Symbol.asyncDispose]: () => Promise<void>;
    
    pipeline: Document[];
    
    options: ChangeStreamOptions & {
        writeConcern?: never;
    };
    parent: MongoClient | Db | Collection;
    namespace: MongoDBNamespace;
    type: symbol;
    
    streamOptions?: CursorStreamOptions;
    
    
    
    
    static readonly RESPONSE: "response";
    
    static readonly MORE: "more";
    
    static readonly INIT: "init";
    
    static readonly CLOSE: "close";
    
    static readonly CHANGE: "change";
    
    static readonly END: "end";
    
    static readonly ERROR: "error";
    
    static readonly RESUME_TOKEN_CHANGED: "resumeTokenChanged";
    private timeoutContext?;
    
    private contextOwner;
    
    
    get resumeToken(): ResumeToken;
    
    hasNext(): Promise<boolean>;
    
    next(): Promise<TChange>;
    
    tryNext(): Promise<TChange | null>;
    [Symbol.asyncIterator](): AsyncGenerator<TChange, void, void>;
    
    get closed(): boolean;
    
    close(): Promise<void>;
    
    stream(options?: CursorStreamOptions): Readable & AsyncIterable<TChange>;
    
    
    
    
    
    
    
    
    
    private _resume;
}


export declare interface ChangeStreamCollModDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentWallTime {
    
    operationType: 'modify';
}


export declare interface ChangeStreamCreateDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentWallTime {
    
    operationType: 'create';
    
    nsType?: 'collection' | 'timeseries' | 'view';
}


export declare interface ChangeStreamCreateIndexDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription, ChangeStreamDocumentWallTime {
    
    operationType: 'createIndexes';
}






export declare interface ChangeStreamDeleteDocument<TSchema extends Document = Document> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema>, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentWallTime {
    
    operationType: 'delete';
    
    ns: ChangeStreamNameSpace;
    
    fullDocumentBeforeChange?: TSchema;
}


export declare type ChangeStreamDocument<TSchema extends Document = Document> = ChangeStreamInsertDocument<TSchema> | ChangeStreamUpdateDocument<TSchema> | ChangeStreamReplaceDocument<TSchema> | ChangeStreamDeleteDocument<TSchema> | ChangeStreamDropDocument | ChangeStreamRenameDocument | ChangeStreamDropDatabaseDocument | ChangeStreamInvalidateDocument | ChangeStreamCreateIndexDocument | ChangeStreamCreateDocument | ChangeStreamCollModDocument | ChangeStreamDropIndexDocument | ChangeStreamShardCollectionDocument | ChangeStreamReshardCollectionDocument | ChangeStreamRefineCollectionShardKeyDocument;


export declare interface ChangeStreamDocumentCollectionUUID {
    
    collectionUUID: Binary;
}


export declare interface ChangeStreamDocumentCommon {
    
    _id: ResumeToken;
    
    clusterTime?: Timestamp;
    
    txnNumber?: number;
    
    lsid?: ServerSessionId;
    
    splitEvent?: ChangeStreamSplitEvent;
}


export declare interface ChangeStreamDocumentKey<TSchema extends Document = Document> {
    
    documentKey: {
        _id: InferIdType<TSchema>;
        [shardKey: string]: any;
    };
}


export declare interface ChangeStreamDocumentOperationDescription {
    
    operationDescription?: Document;
}


export declare interface ChangeStreamDocumentWallTime {
    
    wallTime?: Date;
}


export declare interface ChangeStreamDropDatabaseDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentWallTime {
    
    operationType: 'dropDatabase';
    
    ns: {
        db: string;
    };
}


export declare interface ChangeStreamDropDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentWallTime {
    
    operationType: 'drop';
    
    ns: ChangeStreamNameSpace;
}


export declare interface ChangeStreamDropIndexDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription, ChangeStreamDocumentWallTime {
    
    operationType: 'dropIndexes';
}


export declare type ChangeStreamEvents<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>> = {
    resumeTokenChanged(token: ResumeToken): void;
    init(response: any): void;
    more(response?: any): void;
    response(): void;
    end(): void;
    error(error: Error): void;
    change(change: TChange): void;
    
    close(): void;
};


export declare interface ChangeStreamInsertDocument<TSchema extends Document = Document> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema>, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentWallTime {
    
    operationType: 'insert';
    
    fullDocument: TSchema;
    
    ns: ChangeStreamNameSpace;
}


export declare interface ChangeStreamInvalidateDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentWallTime {
    
    operationType: 'invalidate';
}


export declare interface ChangeStreamNameSpace {
    db: string;
    coll: string;
}


export declare interface ChangeStreamOptions extends Omit<AggregateOptions, 'writeConcern'> {
    
    fullDocument?: string;
    
    fullDocumentBeforeChange?: string;
    
    maxAwaitTimeMS?: number;
    
    resumeAfter?: ResumeToken;
    
    startAfter?: ResumeToken;
    
    startAtOperationTime?: OperationTime;
    
    batchSize?: number;
    
    showExpandedEvents?: boolean;
}


export declare interface ChangeStreamRefineCollectionShardKeyDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription {
    
    operationType: 'refineCollectionShardKey';
}


export declare interface ChangeStreamRenameDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentWallTime {
    
    operationType: 'rename';
    
    to: {
        db: string;
        coll: string;
    };
    
    ns: ChangeStreamNameSpace;
}


export declare interface ChangeStreamReplaceDocument<TSchema extends Document = Document> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema>, ChangeStreamDocumentWallTime {
    
    operationType: 'replace';
    
    fullDocument: TSchema;
    
    ns: ChangeStreamNameSpace;
    
    fullDocumentBeforeChange?: TSchema;
}


export declare interface ChangeStreamReshardCollectionDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription {
    
    operationType: 'reshardCollection';
}


export declare interface ChangeStreamShardCollectionDocument extends ChangeStreamDocumentCommon, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentOperationDescription, ChangeStreamDocumentWallTime {
    
    operationType: 'shardCollection';
}


export declare interface ChangeStreamSplitEvent {
    
    fragment: number;
    
    of: number;
}


export declare interface ChangeStreamUpdateDocument<TSchema extends Document = Document> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema>, ChangeStreamDocumentCollectionUUID, ChangeStreamDocumentWallTime {
    
    operationType: 'update';
    
    fullDocument?: TSchema;
    
    updateDescription: UpdateDescription<TSchema>;
    
    ns: ChangeStreamNameSpace;
    
    fullDocumentBeforeChange?: TSchema;
}


export declare interface ClientBulkWriteError {
    code: number;
    message: string;
}


export declare type ClientBulkWriteModel<SchemaMap extends Record<string, Document> = Record<string, Document>> = {
    [Namespace in keyof SchemaMap]: AnyClientBulkWriteModel<SchemaMap[Namespace]> & {
        namespace: Namespace;
    };
}[keyof SchemaMap];


export declare interface ClientBulkWriteOptions extends CommandOperationOptions {
    
    ordered?: boolean;
    
    bypassDocumentValidation?: boolean;
    
    let?: Document;
    
    verboseResults?: boolean;
}


export declare interface ClientBulkWriteResult {
    
    readonly acknowledged: boolean;
    
    readonly insertedCount: number;
    
    readonly upsertedCount: number;
    
    readonly matchedCount: number;
    
    readonly modifiedCount: number;
    
    readonly deletedCount: number;
    
    readonly insertResults?: ReadonlyMap<number, ClientInsertOneResult>;
    
    readonly updateResults?: ReadonlyMap<number, ClientUpdateResult>;
    
    readonly deleteResults?: ReadonlyMap<number, ClientDeleteResult>;
}


export declare interface ClientDeleteManyModel<TSchema> extends ClientWriteModel {
    name: 'deleteMany';
    
    filter: Filter<TSchema>;
    
    collation?: CollationOptions;
    
    hint?: Hint;
}


export declare interface ClientDeleteOneModel<TSchema> extends ClientWriteModel {
    name: 'deleteOne';
    
    filter: Filter<TSchema>;
    
    collation?: CollationOptions;
    
    hint?: Hint;
}


export declare interface ClientDeleteResult {
    
    deletedCount: number;
}


export declare class ClientEncryption {
    
    
    
    
    
    
    
    
    
    
    
    constructor(client: MongoClient, options: ClientEncryptionOptions);
    
    createDataKey(provider: ClientEncryptionDataKeyProvider, options?: ClientEncryptionCreateDataKeyProviderOptions): Promise<UUID>;
    
    rewrapManyDataKey(filter: Filter<DataKey>, options: ClientEncryptionRewrapManyDataKeyProviderOptions): Promise<{
        bulkWriteResult?: BulkWriteResult;
    }>;
    
    deleteKey(_id: Binary): Promise<DeleteResult>;
    
    getKeys(): FindCursor<DataKey>;
    
    getKey(_id: Binary): Promise<DataKey | null>;
    
    getKeyByAltName(keyAltName: string): Promise<WithId<DataKey> | null>;
    
    addKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null>;
    
    removeKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null>;
    
    createEncryptedCollection<TSchema extends Document = Document>(db: Db, name: string, options: {
        provider: ClientEncryptionDataKeyProvider;
        createCollectionOptions: Omit<CreateCollectionOptions, 'encryptedFields'> & {
            encryptedFields: Document;
        };
        masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions;
    }): Promise<{
        collection: Collection<TSchema>;
        encryptedFields: Document;
    }>;
    
    encrypt(value: unknown, options: ClientEncryptionEncryptOptions): Promise<Binary>;
    
    encryptExpression(expression: Document, options: ClientEncryptionEncryptOptions): Promise<Binary>;
    
    decrypt<T = any>(value: Binary): Promise<T>;
    
    static get libmongocryptVersion(): string;
    
}


export declare interface ClientEncryptionCreateDataKeyProviderOptions {
    
    masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions | KMIPEncryptionKeyOptions | undefined;
    
    keyAltNames?: string[] | undefined;
    
    keyMaterial?: Buffer | Binary;
    
}


export declare type ClientEncryptionDataKeyProvider = keyof KMSProviders;


export declare interface ClientEncryptionEncryptOptions {
    
    algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' | 'AEAD_AES_256_CBC_HMAC_SHA_512-Random' | 'Indexed' | 'Unindexed' | 'Range';
    
    keyId?: Binary;
    
    keyAltName?: string;
    
    contentionFactor?: bigint | number;
    
    queryType?: 'equality' | 'range';
    
    rangeOptions?: RangeOptions;
}


export declare interface ClientEncryptionOptions {
    
    keyVaultNamespace: string;
    
    keyVaultClient?: MongoClient | undefined;
    
    kmsProviders?: KMSProviders;
    
    credentialProviders?: CredentialProviders;
    
    proxyOptions?: ProxyOptions;
    
    tlsOptions?: CSFLEKMSTlsOptions;
    
    keyExpirationMS?: number;
    
    timeoutMS?: number;
}


export declare interface ClientEncryptionRewrapManyDataKeyProviderOptions {
    provider: ClientEncryptionDataKeyProvider;
    masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions | KMIPEncryptionKeyOptions | undefined;
}


export declare interface ClientEncryptionRewrapManyDataKeyResult {
    
    bulkWriteResult?: BulkWriteResult;
}


export declare type ClientEncryptionSocketOptions = Pick<MongoClientOptions, 'autoSelectFamily' | 'autoSelectFamilyAttemptTimeout'>;


export declare type ClientEncryptionTlsOptions = Pick<MongoClientOptions, 'tlsCAFile' | 'tlsCertificateKeyFile' | 'tlsCertificateKeyFilePassword'>;


export declare interface ClientInsertOneModel<TSchema> extends ClientWriteModel {
    name: 'insertOne';
    
    document: OptionalId<TSchema>;
}


export declare interface ClientInsertOneResult {
    
    insertedId: any;
}


export declare interface ClientMetadata {
    driver: {
        name: string;
        version: string;
    };
    os: {
        type: string;
        name?: NodeJS.Platform;
        architecture?: string;
        version?: string;
    };
    platform: string;
    application?: {
        name: string;
    };
    
    env?: {
        name: 'aws.lambda' | 'gcp.func' | 'azure.func' | 'vercel';
        timeout_sec?: Int32;
        memory_mb?: Int32;
        region?: string;
        url?: string;
    };
}


export declare interface ClientMetadataOptions {
    driverInfo?: {
        name?: string;
        version?: string;
        platform?: string;
    };
    appName?: string;
}


export declare interface ClientReplaceOneModel<TSchema> extends ClientWriteModel {
    name: 'replaceOne';
    
    filter: Filter<TSchema>;
    
    replacement: WithoutId<TSchema>;
    
    collation?: CollationOptions;
    
    hint?: Hint;
    
    upsert?: boolean;
    
    sort?: Sort;
}


export declare class ClientSession extends TypedEventEmitter<ClientSessionEvents> implements AsyncDisposable_2 {
    
    
    hasEnded: boolean;
    clientOptions: MongoOptions;
    supports: {
        causalConsistency: boolean;
    };
    clusterTime?: ClusterTime;
    operationTime?: Timestamp;
    explicit: boolean;
    
    defaultTransactionOptions: TransactionOptions;
    
    transaction: Transaction;
    
    readonly snapshotEnabled: boolean;
    
    
    
    
    
    timeoutMS?: number;
    
    
    
    get id(): ServerSessionId | undefined;
    get serverSession(): ServerSession;
    get loadBalanced(): boolean;
    
    
    get isPinned(): boolean;
    
    endSession(options?: EndSessionOptions): Promise<void>;
    
    [Symbol.asyncDispose]: () => Promise<void>;
    
    
    advanceOperationTime(operationTime: Timestamp): void;
    
    advanceClusterTime(clusterTime: ClusterTime): void;
    
    equals(session: ClientSession): boolean;
    
    incrementTransactionNumber(): void;
    
    inTransaction(): boolean;
    
    startTransaction(options?: TransactionOptions): void;
    
    commitTransaction(options?: {
        timeoutMS?: number;
    }): Promise<void>;
    
    abortTransaction(options?: {
        timeoutMS?: number;
    }): Promise<void>;
    
    
    toBSON(): never;
    
    withTransaction<T = any>(fn: WithTransactionCallback<T>, options?: TransactionOptions & {
        
        timeoutMS?: number;
    }): Promise<T>;
}


export declare type ClientSessionEvents = {
    ended(session: ClientSession): void;
};


export declare interface ClientSessionOptions {
    
    causalConsistency?: boolean;
    
    snapshot?: boolean;
    
    defaultTransactionOptions?: TransactionOptions;
    
    defaultTimeoutMS?: number;
    
    
    
}


export declare interface ClientUpdateManyModel<TSchema> extends ClientWriteModel {
    name: 'updateMany';
    
    filter: Filter<TSchema>;
    
    update: UpdateFilter<TSchema> | Document[];
    
    arrayFilters?: Document[];
    
    collation?: CollationOptions;
    
    hint?: Hint;
    
    upsert?: boolean;
}


export declare interface ClientUpdateOneModel<TSchema> extends ClientWriteModel {
    name: 'updateOne';
    
    filter: Filter<TSchema>;
    
    update: UpdateFilter<TSchema> | Document[];
    
    arrayFilters?: Document[];
    
    collation?: CollationOptions;
    
    hint?: Hint;
    
    upsert?: boolean;
    
    sort?: Sort;
}


export declare interface ClientUpdateResult {
    
    matchedCount: number;
    
    modifiedCount: number;
    
    upsertedId?: any;
    
    didUpsert: boolean;
}


export declare interface ClientWriteModel {
    
    namespace: string;
}


export declare interface CloseOptions {
    force?: boolean;
}


export declare interface ClusteredCollectionOptions extends Document {
    name?: string;
    key: Document;
    unique: boolean;
}


export declare interface ClusterTime {
    clusterTime: Timestamp;
    
    signature?: {
        hash: Binary;
        keyId: Long;
    };
}

export { Code }


export declare interface CollationOptions {
    locale: string;
    caseLevel?: boolean;
    caseFirst?: string;
    strength?: number;
    numericOrdering?: boolean;
    alternate?: string;
    maxVariable?: string;
    backwards?: boolean;
    normalization?: boolean;
}


export declare class Collection<TSchema extends Document = Document> {
    
    
    
    
    get dbName(): string;
    
    get collectionName(): string;
    
    get namespace(): string;
    
    
    get readConcern(): ReadConcern | undefined;
    
    get readPreference(): ReadPreference | undefined;
    get bsonOptions(): BSONSerializeOptions;
    
    get writeConcern(): WriteConcern | undefined;
    
    get hint(): Hint | undefined;
    set hint(v: Hint | undefined);
    get timeoutMS(): number | undefined;
    
    insertOne(doc: OptionalUnlessRequiredId<TSchema>, options?: InsertOneOptions): Promise<InsertOneResult<TSchema>>;
    
    insertMany(docs: ReadonlyArray<OptionalUnlessRequiredId<TSchema>>, options?: BulkWriteOptions): Promise<InsertManyResult<TSchema>>;
    
    bulkWrite(operations: ReadonlyArray<AnyBulkWriteOperation<TSchema>>, options?: BulkWriteOptions): Promise<BulkWriteResult>;
    
    updateOne(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document[], options?: UpdateOptions & {
        sort?: Sort;
    }): Promise<UpdateResult<TSchema>>;
    
    replaceOne(filter: Filter<TSchema>, replacement: WithoutId<TSchema>, options?: ReplaceOptions): Promise<UpdateResult<TSchema>>;
    
    updateMany(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document[], options?: UpdateOptions): Promise<UpdateResult<TSchema>>;
    
    deleteOne(filter?: Filter<TSchema>, options?: DeleteOptions): Promise<DeleteResult>;
    
    deleteMany(filter?: Filter<TSchema>, options?: DeleteOptions): Promise<DeleteResult>;
    
    rename(newName: string, options?: RenameOptions): Promise<Collection>;
    
    drop(options?: DropCollectionOptions): Promise<boolean>;
    
    findOne(): Promise<WithId<TSchema> | null>;
    findOne(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;
    findOne(filter: Filter<TSchema>, options: Omit<FindOptions, 'timeoutMode'> & Abortable): Promise<WithId<TSchema> | null>;
    findOne<T = TSchema>(): Promise<T | null>;
    findOne<T = TSchema>(filter: Filter<TSchema>): Promise<T | null>;
    findOne<T = TSchema>(filter: Filter<TSchema>, options?: Omit<FindOptions, 'timeoutMode'> & Abortable): Promise<T | null>;
    
    find(): FindCursor<WithId<TSchema>>;
    find(filter: Filter<TSchema>, options?: FindOptions & Abortable): FindCursor<WithId<TSchema>>;
    find<T extends Document>(filter: Filter<TSchema>, options?: FindOptions & Abortable): FindCursor<T>;
    
    options(options?: OperationOptions): Promise<Document>;
    
    isCapped(options?: OperationOptions): Promise<boolean>;
    
    createIndex(indexSpec: IndexSpecification, options?: CreateIndexesOptions): Promise<string>;
    
    createIndexes(indexSpecs: IndexDescription[], options?: CreateIndexesOptions): Promise<string[]>;
    
    dropIndex(indexName: string, options?: DropIndexesOptions): Promise<Document>;
    
    dropIndexes(options?: DropIndexesOptions): Promise<boolean>;
    
    listIndexes(options?: ListIndexesOptions): ListIndexesCursor;
    
    indexExists(indexes: string | string[], options?: ListIndexesOptions): Promise<boolean>;
    
    indexInformation(options: IndexInformationOptions & {
        full: true;
    }): Promise<IndexDescriptionInfo[]>;
    indexInformation(options: IndexInformationOptions & {
        full?: false;
    }): Promise<IndexDescriptionCompact>;
    indexInformation(options: IndexInformationOptions): Promise<IndexDescriptionCompact | IndexDescriptionInfo[]>;
    indexInformation(): Promise<IndexDescriptionCompact>;
    
    estimatedDocumentCount(options?: EstimatedDocumentCountOptions): Promise<number>;
    
    countDocuments(filter?: Filter<TSchema>, options?: CountDocumentsOptions & Abortable): Promise<number>;
    
    distinct<Key extends keyof WithId<TSchema>>(key: Key): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;
    distinct<Key extends keyof WithId<TSchema>>(key: Key, filter: Filter<TSchema>): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;
    distinct<Key extends keyof WithId<TSchema>>(key: Key, filter: Filter<TSchema>, options: DistinctOptions): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;
    distinct(key: string): Promise<any[]>;
    distinct(key: string, filter: Filter<TSchema>): Promise<any[]>;
    distinct(key: string, filter: Filter<TSchema>, options: DistinctOptions): Promise<any[]>;
    
    indexes(options: IndexInformationOptions & {
        full?: true;
    }): Promise<IndexDescriptionInfo[]>;
    indexes(options: IndexInformationOptions & {
        full: false;
    }): Promise<IndexDescriptionCompact>;
    indexes(options: IndexInformationOptions): Promise<IndexDescriptionCompact | IndexDescriptionInfo[]>;
    indexes(options?: ListIndexesOptions): Promise<IndexDescriptionInfo[]>;
    
    findOneAndDelete(filter: Filter<TSchema>, options: FindOneAndDeleteOptions & {
        includeResultMetadata: true;
    }): Promise<ModifyResult<TSchema>>;
    findOneAndDelete(filter: Filter<TSchema>, options: FindOneAndDeleteOptions & {
        includeResultMetadata: false;
    }): Promise<WithId<TSchema> | null>;
    findOneAndDelete(filter: Filter<TSchema>, options: FindOneAndDeleteOptions): Promise<WithId<TSchema> | null>;
    findOneAndDelete(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;
    
    findOneAndReplace(filter: Filter<TSchema>, replacement: WithoutId<TSchema>, options: FindOneAndReplaceOptions & {
        includeResultMetadata: true;
    }): Promise<ModifyResult<TSchema>>;
    findOneAndReplace(filter: Filter<TSchema>, replacement: WithoutId<TSchema>, options: FindOneAndReplaceOptions & {
        includeResultMetadata: false;
    }): Promise<WithId<TSchema> | null>;
    findOneAndReplace(filter: Filter<TSchema>, replacement: WithoutId<TSchema>, options: FindOneAndReplaceOptions): Promise<WithId<TSchema> | null>;
    findOneAndReplace(filter: Filter<TSchema>, replacement: WithoutId<TSchema>): Promise<WithId<TSchema> | null>;
    
    findOneAndUpdate(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document[], options: FindOneAndUpdateOptions & {
        includeResultMetadata: true;
    }): Promise<ModifyResult<TSchema>>;
    findOneAndUpdate(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document[], options: FindOneAndUpdateOptions & {
        includeResultMetadata: false;
    }): Promise<WithId<TSchema> | null>;
    findOneAndUpdate(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document[], options: FindOneAndUpdateOptions): Promise<WithId<TSchema> | null>;
    findOneAndUpdate(filter: Filter<TSchema>, update: UpdateFilter<TSchema> | Document[]): Promise<WithId<TSchema> | null>;
    
    aggregate<T extends Document = Document>(pipeline?: Document[], options?: AggregateOptions & Abortable): AggregationCursor<T>;
    
    watch<TLocal extends Document = TSchema, TChange extends Document = ChangeStreamDocument<TLocal>>(pipeline?: Document[], options?: ChangeStreamOptions): ChangeStream<TLocal, TChange>;
    
    initializeUnorderedBulkOp(options?: BulkWriteOptions): UnorderedBulkOperation;
    
    initializeOrderedBulkOp(options?: BulkWriteOptions): OrderedBulkOperation;
    
    count(filter?: Filter<TSchema>, options?: CountOptions): Promise<number>;
    
    listSearchIndexes(options?: ListSearchIndexesOptions): ListSearchIndexesCursor;
    
    listSearchIndexes(name: string, options?: ListSearchIndexesOptions): ListSearchIndexesCursor;
    
    createSearchIndex(description: SearchIndexDescription): Promise<string>;
    
    createSearchIndexes(descriptions: SearchIndexDescription[]): Promise<string[]>;
    
    dropSearchIndex(name: string): Promise<void>;
    
    updateSearchIndex(name: string, definition: Document): Promise<void>;
}


export declare interface CollectionInfo extends Document {
    name: string;
    type?: string;
    options?: Document;
    info?: {
        readOnly?: false;
        uuid?: Binary;
    };
    idIndex?: Document;
}


export declare interface CollectionOptions extends BSONSerializeOptions, WriteConcernOptions {
    
    readConcern?: ReadConcernLike;
    
    readPreference?: ReadPreferenceLike;
    
    timeoutMS?: number;
}










export declare class CommandFailedEvent {
    address: string;
    
    connectionId?: string | number;
    
    serverConnectionId: bigint | null;
    requestId: number;
    duration: number;
    commandName: string;
    failure: Error;
    serviceId?: ObjectId;
    databaseName: string;
    
    
    get hasServiceId(): boolean;
}




export declare interface CommandOperationOptions extends OperationOptions, WriteConcernOptions, ExplainOptions {
    
    readConcern?: ReadConcernLike;
    
    collation?: CollationOptions;
    
    maxTimeMS?: number;
    
    comment?: unknown;
    
    retryWrites?: boolean;
    dbName?: string;
    authdb?: string;
    
    noResponse?: boolean;
}




export declare class CommandStartedEvent {
    commandObj?: Document;
    requestId: number;
    databaseName: string;
    commandName: string;
    command: Document;
    address: string;
    
    connectionId?: string | number;
    
    serverConnectionId: bigint | null;
    serviceId?: ObjectId;
    
    
    get hasServiceId(): boolean;
}


export declare class CommandSucceededEvent {
    address: string;
    
    connectionId?: string | number;
    
    serverConnectionId: bigint | null;
    requestId: number;
    duration: number;
    commandName: string;
    reply: unknown;
    serviceId?: ObjectId;
    databaseName: string;
    
    
    get hasServiceId(): boolean;
}


export declare type CommonEvents = 'newListener' | 'removeListener';


export declare const Compressor: Readonly<{
    readonly none: 0;
    readonly snappy: 1;
    readonly zlib: 2;
    readonly zstd: 3;
}>;


export declare type Compressor = (typeof Compressor)[CompressorName];


export declare type CompressorName = keyof typeof Compressor;


export declare type Condition<T> = AlternativeType<T> | FilterOperators<AlternativeType<T>>;


export declare function configureExplicitResourceManagement(): void;


























export declare class ConnectionCheckedInEvent extends ConnectionPoolMonitoringEvent {
    
    connectionId: number | '<monitor>';
    
    
}


export declare class ConnectionCheckedOutEvent extends ConnectionPoolMonitoringEvent {
    
    connectionId: number | '<monitor>';
    
    
    durationMS: number;
    
}


export declare class ConnectionCheckOutFailedEvent extends ConnectionPoolMonitoringEvent {
    
    reason: string;
    
    
    
    durationMS: number;
    
}


export declare class ConnectionCheckOutStartedEvent extends ConnectionPoolMonitoringEvent {
    
    
}


export declare class ConnectionClosedEvent extends ConnectionPoolMonitoringEvent {
    
    connectionId: number | '<monitor>';
    
    reason: string;
    serviceId?: ObjectId;
    
    
    
}


export declare class ConnectionCreatedEvent extends ConnectionPoolMonitoringEvent {
    
    connectionId: number | '<monitor>';
    
    
}


export declare type ConnectionEvents = {
    commandStarted(event: CommandStartedEvent): void;
    commandSucceeded(event: CommandSucceededEvent): void;
    commandFailed(event: CommandFailedEvent): void;
    clusterTimeReceived(clusterTime: Document): void;
    close(): void;
    pinned(pinType: string): void;
    unpinned(pinType: string): void;
};


export declare interface ConnectionOptions extends SupportedNodeConnectionOptions, StreamDescriptionOptions, ProxyOptions {
    id: number | '<monitor>';
    generation: number;
    hostAddress: HostAddress;
    
    serverApi?: ServerApi;
    monitorCommands: boolean;
    
    credentials?: MongoCredentials;
    
    connectTimeoutMS?: number;
    tls: boolean;
    noDelay?: boolean;
    socketTimeoutMS?: number;
    cancellationToken?: CancellationToken;
    metadata: ClientMetadata;
    
    
}




export declare class ConnectionPoolClearedEvent extends ConnectionPoolMonitoringEvent {
    
    interruptInUseConnections?: boolean;
    
    
}


export declare class ConnectionPoolClosedEvent extends ConnectionPoolMonitoringEvent {
    
    
}


export declare class ConnectionPoolCreatedEvent extends ConnectionPoolMonitoringEvent {
    
    options: Pick<ConnectionPoolOptions, 'maxPoolSize' | 'minPoolSize' | 'maxConnecting' | 'maxIdleTimeMS' | 'waitQueueTimeoutMS'>;
    
    
}


export declare type ConnectionPoolEvents = {
    connectionPoolCreated(event: ConnectionPoolCreatedEvent): void;
    connectionPoolReady(event: ConnectionPoolReadyEvent): void;
    connectionPoolClosed(event: ConnectionPoolClosedEvent): void;
    connectionPoolCleared(event: ConnectionPoolClearedEvent): void;
    connectionCreated(event: ConnectionCreatedEvent): void;
    connectionReady(event: ConnectionReadyEvent): void;
    connectionClosed(event: ConnectionClosedEvent): void;
    connectionCheckOutStarted(event: ConnectionCheckOutStartedEvent): void;
    connectionCheckOutFailed(event: ConnectionCheckOutFailedEvent): void;
    connectionCheckedOut(event: ConnectionCheckedOutEvent): void;
    connectionCheckedIn(event: ConnectionCheckedInEvent): void;
} & Omit<ConnectionEvents, 'close' | 'message'>;




export declare abstract class ConnectionPoolMonitoringEvent {
    
    time: Date;
    
    address: string;
    
    
}


export declare interface ConnectionPoolOptions extends Omit<ConnectionOptions, 'id' | 'generation'> {
    
    maxPoolSize: number;
    
    minPoolSize: number;
    
    maxConnecting: number;
    
    maxIdleTimeMS: number;
    
    waitQueueTimeoutMS: number;
    
    loadBalanced: boolean;
    
}


export declare class ConnectionPoolReadyEvent extends ConnectionPoolMonitoringEvent {
    
    
}


export declare class ConnectionReadyEvent extends ConnectionPoolMonitoringEvent {
    
    connectionId: number | '<monitor>';
    
    durationMS: number;
    
    
}


export declare interface ConnectOptions {
    readPreference?: ReadPreference;
}


export declare interface CountDocumentsOptions extends AggregateOptions {
    
    skip?: number;
    
    limit?: number;
}


export declare interface CountOptions extends CommandOperationOptions {
    
    skip?: number;
    
    limit?: number;
    
    maxTimeMS?: number;
    
    hint?: string | Document;
}


export declare interface CreateCollectionOptions extends CommandOperationOptions {
    
    capped?: boolean;
    
    autoIndexId?: boolean;
    
    size?: number;
    
    max?: number;
    
    flags?: number;
    
    storageEngine?: Document;
    
    validator?: Document;
    
    validationLevel?: string;
    
    validationAction?: string;
    
    indexOptionDefaults?: Document;
    
    viewOn?: string;
    
    pipeline?: Document[];
    
    pkFactory?: PkFactory;
    
    timeseries?: TimeSeriesCollectionOptions;
    
    clusteredIndex?: ClusteredCollectionOptions;
    
    expireAfterSeconds?: number;
    
    encryptedFields?: Document;
    
    changeStreamPreAndPostImages?: {
        enabled: boolean;
    };
}


export declare interface CreateIndexesOptions extends Omit<CommandOperationOptions, 'writeConcern'> {
    
    background?: boolean;
    
    unique?: boolean;
    
    name?: string;
    
    partialFilterExpression?: Document;
    
    sparse?: boolean;
    
    expireAfterSeconds?: number;
    
    storageEngine?: Document;
    
    commitQuorum?: number | string;
    
    version?: number;
    weights?: Document;
    default_language?: string;
    language_override?: string;
    textIndexVersion?: number;
    '2dsphereIndexVersion'?: number;
    bits?: number;
    
    min?: number;
    
    max?: number;
    bucketSize?: number;
    wildcardProjection?: Document;
    
    hidden?: boolean;
}


export declare interface CredentialProviders {
    aws?: AWSCredentialProvider;
}


export declare type CSFLEKMSTlsOptions = {
    aws?: ClientEncryptionTlsOptions;
    gcp?: ClientEncryptionTlsOptions;
    kmip?: ClientEncryptionTlsOptions;
    local?: ClientEncryptionTlsOptions;
    azure?: ClientEncryptionTlsOptions;
    [key: string]: ClientEncryptionTlsOptions | undefined;
};






export declare const CURSOR_FLAGS: readonly ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];


export declare type CursorFlag = (typeof CURSOR_FLAGS)[number];




export declare interface CursorStreamOptions {
    
    transform?(this: void, doc: Document): Document;
}




export declare const CursorTimeoutMode: Readonly<{
    readonly ITERATION: "iteration";
    readonly LIFETIME: "cursorLifetime";
}>;


export declare type CursorTimeoutMode = (typeof CursorTimeoutMode)[keyof typeof CursorTimeoutMode];


export declare interface DataKey {
    _id: UUID;
    version?: number;
    keyAltNames?: string[];
    keyMaterial: Binary;
    creationDate: Date;
    updateDate: Date;
    status: number;
    masterKey: Document;
}


export declare class Db {
    
    
    static SYSTEM_NAMESPACE_COLLECTION: string;
    static SYSTEM_INDEX_COLLECTION: string;
    static SYSTEM_PROFILE_COLLECTION: string;
    static SYSTEM_USER_COLLECTION: string;
    static SYSTEM_COMMAND_COLLECTION: string;
    static SYSTEM_JS_COLLECTION: string;
    
    constructor(client: MongoClient, databaseName: string, options?: DbOptions);
    get databaseName(): string;
    get options(): DbOptions | undefined;
    
    get secondaryOk(): boolean;
    get readConcern(): ReadConcern | undefined;
    
    get readPreference(): ReadPreference;
    get bsonOptions(): BSONSerializeOptions;
    get writeConcern(): WriteConcern | undefined;
    get namespace(): string;
    get timeoutMS(): number | undefined;
    
    createCollection<TSchema extends Document = Document>(name: string, options?: CreateCollectionOptions): Promise<Collection<TSchema>>;
    
    command(command: Document, options?: RunCommandOptions & Abortable): Promise<Document>;
    
    aggregate<T extends Document = Document>(pipeline?: Document[], options?: AggregateOptions): AggregationCursor<T>;
    
    admin(): Admin;
    
    collection<TSchema extends Document = Document>(name: string, options?: CollectionOptions): Collection<TSchema>;
    
    stats(options?: DbStatsOptions): Promise<Document>;
    
    listCollections(filter: Document, options: Exclude<ListCollectionsOptions, 'nameOnly'> & {
        nameOnly: true;
    } & Abortable): ListCollectionsCursor<Pick<CollectionInfo, 'name' | 'type'>>;
    listCollections(filter: Document, options: Exclude<ListCollectionsOptions, 'nameOnly'> & {
        nameOnly: false;
    } & Abortable): ListCollectionsCursor<CollectionInfo>;
    listCollections<T extends Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo = Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo>(filter?: Document, options?: ListCollectionsOptions & Abortable): ListCollectionsCursor<T>;
    
    renameCollection<TSchema extends Document = Document>(fromCollection: string, toCollection: string, options?: RenameOptions): Promise<Collection<TSchema>>;
    
    dropCollection(name: string, options?: DropCollectionOptions): Promise<boolean>;
    
    dropDatabase(options?: DropDatabaseOptions): Promise<boolean>;
    
    collections(options?: ListCollectionsOptions): Promise<Collection[]>;
    
    createIndex(name: string, indexSpec: IndexSpecification, options?: CreateIndexesOptions): Promise<string>;
    
    removeUser(username: string, options?: RemoveUserOptions): Promise<boolean>;
    
    setProfilingLevel(level: ProfilingLevel, options?: SetProfilingLevelOptions): Promise<ProfilingLevel>;
    
    profilingLevel(options?: ProfilingLevelOptions): Promise<string>;
    
    indexInformation(name: string, options: IndexInformationOptions & {
        full: true;
    }): Promise<IndexDescriptionInfo[]>;
    indexInformation(name: string, options: IndexInformationOptions & {
        full?: false;
    }): Promise<IndexDescriptionCompact>;
    indexInformation(name: string, options: IndexInformationOptions): Promise<IndexDescriptionCompact | IndexDescriptionInfo[]>;
    indexInformation(name: string): Promise<IndexDescriptionCompact>;
    
    watch<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>>(pipeline?: Document[], options?: ChangeStreamOptions): ChangeStream<TSchema, TChange>;
    
    runCursorCommand(command: Document, options?: RunCursorCommandOptions): RunCommandCursor;
}




export declare interface DbOptions extends BSONSerializeOptions, WriteConcernOptions {
    
    authSource?: string;
    
    forceServerObjectId?: boolean;
    
    readPreference?: ReadPreferenceLike;
    
    pkFactory?: PkFactory;
    
    readConcern?: ReadConcern;
    
    retryWrites?: boolean;
    
    timeoutMS?: number;
}


export { DBRef }


export declare interface DbStatsOptions extends CommandOperationOptions {
    
    scale?: number;
}

export { Decimal128 }


export declare interface DeleteManyModel<TSchema extends Document = Document> {
    
    filter: Filter<TSchema>;
    
    collation?: CollationOptions;
    
    hint?: Hint;
}


export declare interface DeleteOneModel<TSchema extends Document = Document> {
    
    filter: Filter<TSchema>;
    
    collation?: CollationOptions;
    
    hint?: Hint;
}


export declare interface DeleteOptions extends CommandOperationOptions, WriteConcernOptions {
    
    ordered?: boolean;
    
    collation?: CollationOptions;
    
    hint?: string | Document;
    
    let?: Document;
}


export declare interface DeleteResult {
    
    acknowledged: boolean;
    
    deletedCount: number;
}


export declare interface DeleteStatement {
    
    q: Document;
    
    limit: number;
    
    collation?: CollationOptions;
    
    hint?: Hint;
}

export { deserialize }


export declare type DistinctOptions = CommandOperationOptions & {
    
    hint?: Document | string;
};

export { Document }

export { Double }


export declare interface DriverInfo {
    name?: string;
    version?: string;
    platform?: string;
}


export declare interface DropCollectionOptions extends CommandOperationOptions {
    
    encryptedFields?: Document;
}


export declare type DropDatabaseOptions = CommandOperationOptions;


export declare type DropIndexesOptions = CommandOperationOptions;






export declare interface EndSessionOptions {
    
    force?: boolean;
    forceClear?: boolean;
    
    timeoutMS?: number;
}


export declare type EnhancedOmit<TRecordOrUnion, KeyUnion> = string extends keyof TRecordOrUnion ? TRecordOrUnion : TRecordOrUnion extends any ? Pick<TRecordOrUnion, Exclude<keyof TRecordOrUnion, KeyUnion>> : never;


export declare interface ErrorDescription extends Document {
    message?: string;
    errmsg?: string;
    $err?: string;
    errorLabels?: string[];
    errInfo?: Document;
}


export declare interface EstimatedDocumentCountOptions extends CommandOperationOptions {
    
    maxTimeMS?: number;
}


export declare type EventEmitterWithState = {
    
};


export declare type EventsDescription = Record<string, GenericListener>;




export declare abstract class ExplainableCursor<TSchema> extends AbstractCursor<TSchema> {
    
    abstract explain(): Promise<Document>;
    abstract explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document>;
    abstract explain(options: {
        timeoutMS?: number;
    }): Promise<Document>;
    abstract explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions, options: {
        timeoutMS?: number;
    }): Promise<Document>;
    abstract explain(verbosity?: ExplainVerbosityLike | ExplainCommandOptions | {
        timeoutMS?: number;
    }, options?: {
        timeoutMS?: number;
    }): Promise<Document>;
    protected resolveExplainTimeoutOptions(verbosity?: ExplainVerbosityLike | ExplainCommandOptions | {
        timeoutMS?: number;
    }, options?: {
        timeoutMS?: number;
    }): {
        timeout?: {
            timeoutMS?: number;
        };
        explain?: ExplainVerbosityLike | ExplainCommandOptions;
    };
}


export declare interface ExplainCommandOptions {
    
    verbosity: ExplainVerbosity;
    
    maxTimeMS?: number;
}


export declare interface ExplainOptions {
    
    explain?: ExplainVerbosityLike | ExplainCommandOptions;
}


export declare const ExplainVerbosity: Readonly<{
    readonly queryPlanner: "queryPlanner";
    readonly queryPlannerExtended: "queryPlannerExtended";
    readonly executionStats: "executionStats";
    readonly allPlansExecution: "allPlansExecution";
}>;


export declare type ExplainVerbosity = string;


export declare type ExplainVerbosityLike = ExplainVerbosity | boolean;


export declare type Filter<TSchema> = {
    [P in keyof WithId<TSchema>]?: Condition<WithId<TSchema>[P]>;
} & RootFilterOperators<WithId<TSchema>>;


export declare type FilterOperations<T> = T extends Record<string, any> ? {
    [key in keyof T]?: FilterOperators<T[key]>;
} : FilterOperators<T>;


export declare interface FilterOperators<TValue> extends NonObjectIdLikeDocument {
    $eq?: TValue;
    $gt?: TValue;
    $gte?: TValue;
    $in?: ReadonlyArray<TValue>;
    $lt?: TValue;
    $lte?: TValue;
    $ne?: TValue;
    $nin?: ReadonlyArray<TValue>;
    $not?: TValue extends string ? FilterOperators<TValue> | RegExp : FilterOperators<TValue>;
    
    $exists?: boolean;
    $type?: BSONType | BSONTypeAlias;
    $expr?: Record<string, any>;
    $jsonSchema?: Record<string, any>;
    $mod?: TValue extends number ? [number, number] : never;
    $regex?: TValue extends string ? RegExp | BSONRegExp | string : never;
    $options?: TValue extends string ? string : never;
    $geoIntersects?: {
        $geometry: Document;
    };
    $geoWithin?: Document;
    $near?: Document;
    $nearSphere?: Document;
    $maxDistance?: number;
    $all?: ReadonlyArray<any>;
    $elemMatch?: Document;
    $size?: TValue extends ReadonlyArray<any> ? number : never;
    $bitsAllClear?: BitwiseFilter;
    $bitsAllSet?: BitwiseFilter;
    $bitsAnyClear?: BitwiseFilter;
    $bitsAnySet?: BitwiseFilter;
    $rand?: Record<string, never>;
}


export declare class FindCursor<TSchema = any> extends ExplainableCursor<TSchema> {
    
    
    
    
    clone(): FindCursor<TSchema>;
    map<T>(transform: (doc: TSchema) => T): FindCursor<T>;
    
    
    
    count(options?: CountOptions): Promise<number>;
    
    explain(): Promise<Document>;
    explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document>;
    explain(options: {
        timeoutMS?: number;
    }): Promise<Document>;
    explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions, options: {
        timeoutMS?: number;
    }): Promise<Document>;
    
    filter(filter: Document): this;
    
    hint(hint: Hint): this;
    
    min(min: Document): this;
    
    max(max: Document): this;
    
    returnKey(value: boolean): this;
    
    showRecordId(value: boolean): this;
    
    addQueryModifier(name: string, value: string | boolean | number | Document): this;
    
    comment(value: string): this;
    
    maxAwaitTimeMS(value: number): this;
    
    maxTimeMS(value: number): this;
    
    project<T extends Document = Document>(value: Document): FindCursor<T>;
    
    sort(sort: Sort | string, direction?: SortDirection): this;
    
    allowDiskUse(allow?: boolean): this;
    
    collation(value: CollationOptions): this;
    
    limit(value: number): this;
    
    skip(value: number): this;
}


export declare interface FindOneAndDeleteOptions extends CommandOperationOptions {
    
    hint?: Document;
    
    projection?: Document;
    
    sort?: Sort;
    
    let?: Document;
    
    includeResultMetadata?: boolean;
}


export declare interface FindOneAndReplaceOptions extends CommandOperationOptions {
    
    bypassDocumentValidation?: boolean;
    
    hint?: Document;
    
    projection?: Document;
    
    returnDocument?: ReturnDocument;
    
    sort?: Sort;
    
    upsert?: boolean;
    
    let?: Document;
    
    includeResultMetadata?: boolean;
}


export declare interface FindOneAndUpdateOptions extends CommandOperationOptions {
    
    arrayFilters?: Document[];
    
    bypassDocumentValidation?: boolean;
    
    hint?: Document;
    
    projection?: Document;
    
    returnDocument?: ReturnDocument;
    
    sort?: Sort;
    
    upsert?: boolean;
    
    let?: Document;
    
    includeResultMetadata?: boolean;
}


export declare class FindOperators {
    bulkOperation: BulkOperationBase;
    
    
    update(updateDocument: Document | Document[]): BulkOperationBase;
    
    updateOne(updateDocument: Document | Document[]): BulkOperationBase;
    
    replaceOne(replacement: Document): BulkOperationBase;
    
    deleteOne(): BulkOperationBase;
    
    delete(): BulkOperationBase;
    
    upsert(): this;
    
    collation(collation: CollationOptions): this;
    
    arrayFilters(arrayFilters: Document[]): this;
    
    hint(hint: Hint): this;
}


export declare interface FindOptions<TSchema extends Document = Document> extends Omit<CommandOperationOptions, 'writeConcern' | 'explain'>, AbstractCursorOptions {
    
    limit?: number;
    
    sort?: Sort;
    
    projection?: Document;
    
    skip?: number;
    
    hint?: Hint;
    
    timeout?: boolean;
    
    tailable?: boolean;
    
    awaitData?: boolean;
    
    batchSize?: number;
    
    returnKey?: boolean;
    
    min?: Document;
    
    max?: Document;
    
    maxTimeMS?: number;
    
    maxAwaitTimeMS?: number;
    
    noCursorTimeout?: boolean;
    
    collation?: CollationOptions;
    
    allowDiskUse?: boolean;
    
    singleBatch?: boolean;
    
    allowPartialResults?: boolean;
    
    showRecordId?: boolean;
    
    let?: Document;
    
    oplogReplay?: boolean;
    
    explain?: ExplainOptions['explain'];
    
}


export declare type Flatten<Type> = Type extends ReadonlyArray<infer Item> ? Item : Type;


export declare interface GCPEncryptionKeyOptions {
    
    projectId: string;
    
    location: string;
    
    keyRing: string;
    
    keyName: string;
    
    keyVersion?: string | undefined;
    
    endpoint?: string | undefined;
}


export declare type GCPKMSProviderConfiguration = {
    
    email: string;
    
    privateKey: string | Buffer;
    
    endpoint?: string | undefined;
} | {
    
    accessToken: string;
};


export declare type GenericListener = (...args: any[]) => void;


export declare class GridFSBucket extends TypedEventEmitter<GridFSBucketEvents> {
    
    
    static readonly INDEX: "index";
    constructor(db: Db, options?: GridFSBucketOptions);
    
    openUploadStream(filename: string, options?: GridFSBucketWriteStreamOptions): GridFSBucketWriteStream;
    
    openUploadStreamWithId(id: ObjectId, filename: string, options?: GridFSBucketWriteStreamOptions): GridFSBucketWriteStream;
    
    openDownloadStream(id: ObjectId, options?: GridFSBucketReadStreamOptions): GridFSBucketReadStream;
    
    delete(id: ObjectId, options?: {
        timeoutMS: number;
    }): Promise<void>;
    
    find(filter?: Filter<GridFSFile>, options?: FindOptions): FindCursor<GridFSFile>;
    
    openDownloadStreamByName(filename: string, options?: GridFSBucketReadStreamOptionsWithRevision): GridFSBucketReadStream;
    
    rename(id: ObjectId, filename: string, options?: {
        timeoutMS: number;
    }): Promise<void>;
    
    drop(options?: {
        timeoutMS: number;
    }): Promise<void>;
}


export declare type GridFSBucketEvents = {
    index(): void;
};


export declare interface GridFSBucketOptions extends WriteConcernOptions {
    
    bucketName?: string;
    
    chunkSizeBytes?: number;
    
    readPreference?: ReadPreference;
    
    timeoutMS?: number;
}




export declare class GridFSBucketReadStream extends Readable {
    
    
    static readonly FILE: "file";
    
    
    
    start(start?: number): this;
    
    end(end?: number): this;
    
    abort(): Promise<void>;
}


export declare interface GridFSBucketReadStreamOptions {
    sort?: Sort;
    skip?: number;
    
    start?: number;
    
    end?: number;
    
    timeoutMS?: number;
}


export declare interface GridFSBucketReadStreamOptionsWithRevision extends GridFSBucketReadStreamOptions {
    
    revision?: number;
}




export declare class GridFSBucketWriteStream extends Writable {
    bucket: GridFSBucket;
    
    chunks: Collection<GridFSChunk>;
    
    files: Collection<GridFSFile>;
    
    filename: string;
    
    options: GridFSBucketWriteStreamOptions;
    
    done: boolean;
    
    id: ObjectId;
    
    chunkSizeBytes: number;
    
    bufToStore: Buffer;
    
    length: number;
    
    n: number;
    
    pos: number;
    
    state: {
        
        streamEnd: boolean;
        
        outstandingRequests: number;
        
        errored: boolean;
        
        aborted: boolean;
    };
    
    writeConcern?: WriteConcern;
    
    gridFSFile: GridFSFile | null;
    
    
    
    
    
    
    abort(): Promise<void>;
}


export declare interface GridFSBucketWriteStreamOptions extends WriteConcernOptions {
    
    chunkSizeBytes?: number;
    
    id?: ObjectId;
    
    metadata?: Document;
    
    contentType?: string;
    
    aliases?: string[];
    
    timeoutMS?: number;
}


export declare interface GridFSChunk {
    _id: ObjectId;
    files_id: ObjectId;
    n: number;
    data: Buffer | Uint8Array;
}


export declare interface GridFSFile {
    _id: ObjectId;
    length: number;
    chunkSize: number;
    filename: string;
    metadata?: Document;
    uploadDate: Date;
    
    contentType?: string;
    
    aliases?: string[];
}


export declare const GSSAPICanonicalizationValue: Readonly<{
    readonly on: true;
    readonly off: false;
    readonly none: "none";
    readonly forward: "forward";
    readonly forwardAndReverse: "forwardAndReverse";
}>;


export declare type GSSAPICanonicalizationValue = (typeof GSSAPICanonicalizationValue)[keyof typeof GSSAPICanonicalizationValue];




export declare interface HedgeOptions {
    
    enabled?: boolean;
}


export declare type Hint = string | Document;


export declare class HostAddress {
    host: string | undefined;
    port: number | undefined;
    socketPath: string | undefined;
    isIPv6: boolean;
    constructor(hostString: string);
    inspect(): string;
    toString(): string;
    static fromString(this: void, s: string): HostAddress;
    static fromHostPort(host: string, port: number): HostAddress;
    static fromSrvRecord({ name, port }: SrvRecord): HostAddress;
    toHostPort(): {
        host: string;
        port: number;
    };
}


export declare interface IdPInfo {
    
    issuer: string;
    
    clientId: string;
    
    requestScopes?: string[];
}


export declare interface IdPServerResponse {
    
    accessToken: string;
    
    expiresInSeconds?: number;
    
    refreshToken?: string;
}


export declare interface IndexDescription extends Pick<CreateIndexesOptions, 'background' | 'unique' | 'partialFilterExpression' | 'sparse' | 'hidden' | 'expireAfterSeconds' | 'storageEngine' | 'version' | 'weights' | 'default_language' | 'language_override' | 'textIndexVersion' | '2dsphereIndexVersion' | 'bits' | 'min' | 'max' | 'bucketSize' | 'wildcardProjection'> {
    collation?: CollationOptions;
    name?: string;
    key: {
        [key: string]: IndexDirection;
    } | Map<string, IndexDirection>;
}


export declare type IndexDescriptionCompact = Record<string, [name: string, direction: IndexDirection][]>;


export declare type IndexDescriptionInfo = Omit<IndexDescription, 'key' | 'version'> & {
    key: {
        [key: string]: IndexDirection;
    };
    v?: IndexDescription['version'];
} & Document;


export declare type IndexDirection = -1 | 1 | '2d' | '2dsphere' | 'text' | 'geoHaystack' | 'hashed' | number;


export declare interface IndexInformationOptions extends ListIndexesOptions {
    
    full?: boolean;
}


export declare type IndexSpecification = OneOrMore<string | [string, IndexDirection] | {
    [key: string]: IndexDirection;
} | Map<string, IndexDirection>>;


export declare type InferIdType<TSchema> = TSchema extends {
    _id: infer IdType;
} ? Record<any, never> extends IdType ? never : IdType : TSchema extends {
    _id?: infer IdType;
} ? unknown extends IdType ? ObjectId : IdType : ObjectId;




export declare interface InsertManyResult<TSchema = Document> {
    
    acknowledged: boolean;
    
    insertedCount: number;
    
    insertedIds: {
        [key: number]: InferIdType<TSchema>;
    };
}


export declare interface InsertOneModel<TSchema extends Document = Document> {
    
    document: OptionalId<TSchema>;
}


export declare interface InsertOneOptions extends CommandOperationOptions {
    
    bypassDocumentValidation?: boolean;
    
    forceServerObjectId?: boolean;
}


export declare interface InsertOneResult<TSchema = Document> {
    
    acknowledged: boolean;
    
    insertedId: InferIdType<TSchema>;
}

export { Int32 }


export declare type IntegerType = number | Int32 | Long | bigint;




export declare type IsAny<Type, ResultIfAny, ResultIfNotAny> = true extends false & Type ? ResultIfAny : ResultIfNotAny;



export declare type Join<T extends unknown[], D extends string> = T extends [] ? '' : T extends [string | number] ? `${T[0]}` : T extends [string | number, ...infer R] ? `${T[0]}${D}${Join<R, D>}` : string;






export declare type KeysOfAType<TSchema, Type> = {
    [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? key : never;
}[keyof TSchema];


export declare type KeysOfOtherType<TSchema, Type> = {
    [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? never : key;
}[keyof TSchema];


export declare interface KMIPEncryptionKeyOptions {
    
    keyId?: string;
    
    endpoint?: string;
    
    delegated?: boolean;
}


export declare interface KMIPKMSProviderConfiguration {
    
    endpoint?: string;
}


export declare interface KMSProviders {
    
    aws?: AWSKMSProviderConfiguration | Record<string, never>;
    [key: `aws:${string}`]: AWSKMSProviderConfiguration;
    
    local?: LocalKMSProviderConfiguration;
    [key: `local:${string}`]: LocalKMSProviderConfiguration;
    
    kmip?: KMIPKMSProviderConfiguration;
    [key: `kmip:${string}`]: KMIPKMSProviderConfiguration;
    
    azure?: AzureKMSProviderConfiguration | Record<string, never>;
    [key: `azure:${string}`]: AzureKMSProviderConfiguration;
    
    gcp?: GCPKMSProviderConfiguration | Record<string, never>;
    [key: `gcp:${string}`]: GCPKMSProviderConfiguration;
}






export declare const LEGAL_TCP_SOCKET_OPTIONS: readonly ["autoSelectFamily", "autoSelectFamilyAttemptTimeout", "keepAliveInitialDelay", "family", "hints", "localAddress", "localPort", "lookup"];


export declare const LEGAL_TLS_SOCKET_OPTIONS: readonly ["allowPartialTrustChain", "ALPNProtocols", "ca", "cert", "checkServerIdentity", "ciphers", "crl", "ecdhCurve", "key", "minDHSize", "passphrase", "pfx", "rejectUnauthorized", "secureContext", "secureProtocol", "servername", "session"];




export declare class ListCollectionsCursor<T extends Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo = Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo> extends AbstractCursor<T> {
    parent: Db;
    filter: Document;
    options?: ListCollectionsOptions & Abortable;
    constructor(db: Db, filter: Document, options?: ListCollectionsOptions & Abortable);
    clone(): ListCollectionsCursor<T>;
    
}


export declare interface ListCollectionsOptions extends Omit<CommandOperationOptions, 'writeConcern'>, Abortable {
    
    nameOnly?: boolean;
    
    authorizedCollections?: boolean;
    
    batchSize?: number;
    
    
}


export declare interface ListDatabasesOptions extends CommandOperationOptions {
    
    filter?: Document;
    
    nameOnly?: boolean;
    
    authorizedDatabases?: boolean;
}


export declare interface ListDatabasesResult {
    databases: ({
        name: string;
        sizeOnDisk?: number;
        empty?: boolean;
    } & Document)[];
    totalSize?: number;
    totalSizeMb?: number;
    ok: 1 | 0;
}


export declare class ListIndexesCursor extends AbstractCursor {
    parent: Collection;
    options?: ListIndexesOptions;
    constructor(collection: Collection, options?: ListIndexesOptions);
    clone(): ListIndexesCursor;
    
}


export declare type ListIndexesOptions = AbstractCursorOptions & {
    
};


export declare class ListSearchIndexesCursor extends AggregationCursor<{
    name: string;
}> {
    
}


export declare type ListSearchIndexesOptions = Omit<AggregateOptions, 'readConcern' | 'writeConcern'>;


export declare interface LocalKMSProviderConfiguration {
    
    key: Binary | Uint8Array | string;
}


export declare interface Log extends Record<string, any> {
    t: Date;
    c: MongoLoggableComponent;
    s: SeverityLevel;
    message?: string;
}


export declare interface LogComponentSeveritiesClientOptions {
    
    command?: SeverityLevel;
    
    topology?: SeverityLevel;
    
    serverSelection?: SeverityLevel;
    
    connection?: SeverityLevel;
    
    client?: SeverityLevel;
    
    default?: SeverityLevel;
}
















export { Long }


export declare type MatchKeysAndValues<TSchema> = Readonly<Partial<TSchema>> & Record<string, any>;

export { MaxKey }


export { MinKey }


export declare interface ModifyResult<TSchema = Document> {
    value: WithId<TSchema> | null;
    lastErrorObject?: Document;
    ok: 0 | 1;
}


export declare const MONGO_CLIENT_EVENTS: readonly ["connectionPoolCreated", "connectionPoolReady", "connectionPoolCleared", "connectionPoolClosed", "connectionCreated", "connectionReady", "connectionClosed", "connectionCheckOutStarted", "connectionCheckOutFailed", "connectionCheckedOut", "connectionCheckedIn", "commandStarted", "commandSucceeded", "commandFailed", "serverOpening", "serverClosed", "serverDescriptionChanged", "topologyOpening", "topologyClosed", "topologyDescriptionChanged", "error", "timeout", "close", "serverHeartbeatStarted", "serverHeartbeatSucceeded", "serverHeartbeatFailed"];


export declare class MongoAPIError extends MongoDriverError {
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    get name(): string;
}


export declare class MongoAWSError extends MongoRuntimeError {
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    get name(): string;
}


export declare class MongoAzureError extends MongoOIDCError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoBatchReExecutionError extends MongoAPIError {
    
    constructor(message?: string);
    get name(): string;
}


export declare class MongoBulkWriteError extends MongoServerError {
    result: BulkWriteResult;
    writeErrors: OneOrMore<WriteError>;
    err?: WriteConcernError;
    
    constructor(error: {
        message: string;
        code: number;
        writeErrors?: WriteError[];
    } | WriteConcernError | AnyError, result: BulkWriteResult);
    get name(): string;
    
    get insertedCount(): number;
    
    get matchedCount(): number;
    
    get modifiedCount(): number;
    
    get deletedCount(): number;
    
    get upsertedCount(): number;
    
    get insertedIds(): {
        [key: number]: any;
    };
    
    get upsertedIds(): {
        [key: number]: any;
    };
}


export declare class MongoChangeStreamError extends MongoRuntimeError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoClient extends TypedEventEmitter<MongoClientEvents> implements AsyncDisposable_2 {
    
    
    
    
    
    
    readonly options: Readonly<Omit<MongoOptions, 'monitorCommands' | 'ca' | 'crl' | 'key' | 'cert' | 'driverInfo' | 'additionalDriverInfo' | 'metadata' | 'extendedMetadata'>> & Pick<MongoOptions, 'monitorCommands' | 'ca' | 'crl' | 'key' | 'cert' | 'driverInfo' | 'additionalDriverInfo' | 'metadata' | 'extendedMetadata'>;
    constructor(url: string, options?: MongoClientOptions);
    
    [Symbol.asyncDispose]: () => Promise<void>;
    
    
    appendMetadata(driverInfo: DriverInfo): void;
    
    get serverApi(): Readonly<ServerApi | undefined>;
    
    
    
    get readConcern(): ReadConcern | undefined;
    get writeConcern(): WriteConcern | undefined;
    get readPreference(): ReadPreference;
    get bsonOptions(): BSONSerializeOptions;
    get timeoutMS(): number | undefined;
    
    bulkWrite<SchemaMap extends Record<string, Document> = Record<string, Document>>(models: ReadonlyArray<ClientBulkWriteModel<SchemaMap>>, options?: ClientBulkWriteOptions): Promise<ClientBulkWriteResult>;
    
    connect(): Promise<this>;
    
    
    close(_force?: boolean): Promise<void>;
    private _close;
    
    db(dbName?: string, options?: DbOptions): Db;
    
    static connect(url: string, options?: MongoClientOptions): Promise<MongoClient>;
    
    startSession(options?: ClientSessionOptions): ClientSession;
    
    withSession<T = any>(executor: WithSessionCallback<T>): Promise<T>;
    withSession<T = any>(options: ClientSessionOptions, executor: WithSessionCallback<T>): Promise<T>;
    
    watch<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>>(pipeline?: Document[], options?: ChangeStreamOptions): ChangeStream<TSchema, TChange>;
}




export declare class MongoClientBulkWriteCursorError extends MongoRuntimeError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoClientBulkWriteError extends MongoServerError {
    
    writeConcernErrors: Document[];
    
    writeErrors: Map<number, ClientBulkWriteError>;
    
    partialResult?: ClientBulkWriteResult;
    
    constructor(message: ErrorDescription);
    get name(): string;
}


export declare class MongoClientBulkWriteExecutionError extends MongoRuntimeError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoClientClosedError extends MongoAPIError {
    
    constructor();
    get name(): string;
}


export declare type MongoClientEvents = Pick<TopologyEvents, (typeof MONGO_CLIENT_EVENTS)[number]> & {
    open(mongoClient: MongoClient): void;
};


export declare interface MongoClientOptions extends BSONSerializeOptions, SupportedNodeConnectionOptions {
    
    replicaSet?: string;
    
    timeoutMS?: number;
    
    tls?: boolean;
    
    ssl?: boolean;
    
    tlsCertificateKeyFile?: string;
    
    tlsCertificateKeyFilePassword?: string;
    
    tlsCAFile?: string;
    
    tlsCRLFile?: string;
    
    tlsAllowInvalidCertificates?: boolean;
    
    tlsAllowInvalidHostnames?: boolean;
    
    tlsInsecure?: boolean;
    
    connectTimeoutMS?: number;
    
    socketTimeoutMS?: number;
    
    compressors?: CompressorName[] | string;
    
    zlibCompressionLevel?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | undefined;
    
    srvMaxHosts?: number;
    
    srvServiceName?: string;
    
    maxPoolSize?: number;
    
    minPoolSize?: number;
    
    maxConnecting?: number;
    
    maxIdleTimeMS?: number;
    
    waitQueueTimeoutMS?: number;
    
    readConcern?: ReadConcernLike;
    
    readConcernLevel?: ReadConcernLevel;
    
    readPreference?: ReadPreferenceMode | ReadPreference;
    
    maxStalenessSeconds?: number;
    
    readPreferenceTags?: TagSet[];
    
    auth?: Auth;
    
    authSource?: string;
    
    authMechanism?: AuthMechanism;
    
    authMechanismProperties?: AuthMechanismProperties;
    
    localThresholdMS?: number;
    
    serverSelectionTimeoutMS?: number;
    
    heartbeatFrequencyMS?: number;
    
    minHeartbeatFrequencyMS?: number;
    
    appName?: string;
    
    retryReads?: boolean;
    
    retryWrites?: boolean;
    
    directConnection?: boolean;
    
    loadBalanced?: boolean;
    
    w?: W;
    
    wtimeoutMS?: number;
    
    journal?: boolean;
    
    writeConcern?: WriteConcern | WriteConcernSettings;
    
    noDelay?: boolean;
    
    forceServerObjectId?: boolean;
    
    pkFactory?: PkFactory;
    
    monitorCommands?: boolean;
    
    serverApi?: ServerApi | ServerApiVersion;
    
    autoEncryption?: AutoEncryptionOptions;
    
    driverInfo?: DriverInfo;
    
    proxyHost?: string;
    
    proxyPort?: number;
    
    proxyUsername?: string;
    
    proxyPassword?: string;
    
    serverMonitoringMode?: ServerMonitoringMode;
    
    mongodbLogPath?: 'stderr' | 'stdout' | MongoDBLogWritable;
    
    mongodbLogComponentSeverities?: LogComponentSeveritiesClientOptions;
    
    mongodbLogMaxDocumentLength?: number;
    
    
    
}




export declare class MongoCompatibilityError extends MongoAPIError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoCredentials {
    
    readonly username: string;
    
    readonly password: string;
    
    readonly source: string;
    
    readonly mechanism: AuthMechanism;
    
    readonly mechanismProperties: AuthMechanismProperties;
    constructor(options: MongoCredentialsOptions);
    
    equals(other: MongoCredentials): boolean;
    
    resolveAuthMechanism(hello: Document | null): MongoCredentials;
    validate(): void;
    static merge(creds: MongoCredentials | undefined, options: Partial<MongoCredentialsOptions>): MongoCredentials;
}


export declare interface MongoCredentialsOptions {
    username?: string;
    password: string;
    source: string;
    db?: string;
    mechanism?: AuthMechanism;
    mechanismProperties: AuthMechanismProperties;
}


export declare class MongoCryptAzureKMSRequestError extends MongoCryptError {
    
    body?: Document;
    
    constructor(message: string, body?: Document);
    get name(): string;
}


export declare class MongoCryptCreateDataKeyError extends MongoCryptError {
    encryptedFields: Document;
    
    constructor(encryptedFields: Document, { cause }: {
        cause: Error;
    });
    get name(): string;
}


export declare class MongoCryptCreateEncryptedCollectionError extends MongoCryptError {
    encryptedFields: Document;
    
    constructor(encryptedFields: Document, { cause }: {
        cause: Error;
    });
    get name(): string;
}




export declare class MongoCryptError extends MongoError {
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    get name(): string;
}


export declare class MongoCryptInvalidArgumentError extends MongoCryptError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoCryptKMSRequestNetworkTimeoutError extends MongoCryptError {
    get name(): string;
}


export declare class MongoCursorExhaustedError extends MongoAPIError {
    
    constructor(message?: string);
    get name(): string;
}


export declare class MongoCursorInUseError extends MongoAPIError {
    
    constructor(message?: string);
    get name(): string;
}


export declare class MongoDBCollectionNamespace extends MongoDBNamespace {
    collection: string;
    constructor(db: string, collection: string);
    static fromString(namespace?: string): MongoDBCollectionNamespace;
}


export declare interface MongoDBLogWritable {
    
    write(log: Log): PromiseLike<unknown> | unknown;
}


export declare class MongoDBNamespace {
    db: string;
    collection?: string;
    
    constructor(db: string, collection?: string);
    toString(): string;
    withCollection(collection: string): MongoDBCollectionNamespace;
    static fromString(namespace?: string): MongoDBNamespace;
}






export declare class MongoDecompressionError extends MongoRuntimeError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoDriverError extends MongoError {
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    get name(): string;
}


export declare class MongoError extends Error {
    
    get errorLabels(): string[];
    
    code?: number | string;
    topologyVersion?: TopologyVersion;
    connectionGeneration?: number;
    cause?: Error;
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    
    get name(): string;
    
    get errmsg(): string;
    
    hasErrorLabel(label: string): boolean;
    addErrorLabel(label: string): void;
}


export declare const MongoErrorLabel: Readonly<{
    readonly RetryableWriteError: "RetryableWriteError";
    readonly TransientTransactionError: "TransientTransactionError";
    readonly UnknownTransactionCommitResult: "UnknownTransactionCommitResult";
    readonly ResumableChangeStreamError: "ResumableChangeStreamError";
    readonly HandshakeError: "HandshakeError";
    readonly ResetPool: "ResetPool";
    readonly PoolRequstedRetry: "PoolRequstedRetry";
    readonly InterruptInUseConnections: "InterruptInUseConnections";
    readonly NoWritesPerformed: "NoWritesPerformed";
}>;


export declare type MongoErrorLabel = (typeof MongoErrorLabel)[keyof typeof MongoErrorLabel];


export declare class MongoExpiredSessionError extends MongoAPIError {
    
    constructor(message?: string);
    get name(): string;
}


export declare class MongoGCPError extends MongoOIDCError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoGridFSChunkError extends MongoRuntimeError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoGridFSStreamError extends MongoRuntimeError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoInvalidArgumentError extends MongoAPIError {
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    get name(): string;
}


export declare class MongoKerberosError extends MongoRuntimeError {
    
    constructor(message: string);
    get name(): string;
}


export declare const MongoLoggableComponent: Readonly<{
    readonly COMMAND: "command";
    readonly TOPOLOGY: "topology";
    readonly SERVER_SELECTION: "serverSelection";
    readonly CONNECTION: "connection";
    readonly CLIENT: "client";
}>;


export declare type MongoLoggableComponent = (typeof MongoLoggableComponent)[keyof typeof MongoLoggableComponent];










export declare class MongoMissingCredentialsError extends MongoAPIError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoMissingDependencyError extends MongoAPIError {
    dependencyName: string;
    
    cause: Error;
    
    constructor(message: string, options: {
        cause: Error;
        dependencyName: string;
    });
    get name(): string;
}


export declare class MongoNetworkError extends MongoError {
    
    
    constructor(message: string, options?: MongoNetworkErrorOptions);
    get name(): string;
}


export declare interface MongoNetworkErrorOptions {
    
    beforeHandshake?: boolean;
    cause?: Error;
}


export declare class MongoNetworkTimeoutError extends MongoNetworkError {
    
    constructor(message: string, options?: MongoNetworkErrorOptions);
    get name(): string;
}


export declare class MongoNotConnectedError extends MongoAPIError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoOIDCError extends MongoRuntimeError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoOperationTimeoutError extends MongoDriverError {
    get name(): string;
}


export declare interface MongoOptions extends Required<Pick<MongoClientOptions, 'autoEncryption' | 'connectTimeoutMS' | 'directConnection' | 'driverInfo' | 'forceServerObjectId' | 'minHeartbeatFrequencyMS' | 'heartbeatFrequencyMS' | 'localThresholdMS' | 'maxConnecting' | 'maxIdleTimeMS' | 'maxPoolSize' | 'minPoolSize' | 'monitorCommands' | 'noDelay' | 'pkFactory' | 'raw' | 'replicaSet' | 'retryReads' | 'retryWrites' | 'serverSelectionTimeoutMS' | 'socketTimeoutMS' | 'srvMaxHosts' | 'srvServiceName' | 'tlsAllowInvalidCertificates' | 'tlsAllowInvalidHostnames' | 'tlsInsecure' | 'waitQueueTimeoutMS' | 'zlibCompressionLevel'>>, SupportedNodeConnectionOptions {
    appName?: string;
    hosts: HostAddress[];
    srvHost?: string;
    credentials?: MongoCredentials;
    readPreference: ReadPreference;
    readConcern: ReadConcern;
    loadBalanced: boolean;
    directConnection: boolean;
    serverApi: ServerApi;
    compressors: CompressorName[];
    writeConcern: WriteConcern;
    dbName: string;
    
    metadata: ClientMetadata;
    extendedMetadata: Promise<Document>;
    additionalDriverInfo: DriverInfo[];
    
    
    proxyHost?: string;
    proxyPort?: number;
    proxyUsername?: string;
    proxyPassword?: string;
    serverMonitoringMode: ServerMonitoringMode;
    
    
    
    
    
    
    tls: boolean;
    tlsCAFile?: string;
    tlsCRLFile?: string;
    tlsCertificateKeyFile?: string;
    
    
    timeoutMS?: number;
    
}


export declare class MongoParseError extends MongoDriverError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoRuntimeError extends MongoDriverError {
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    get name(): string;
}


export declare class MongoServerClosedError extends MongoAPIError {
    
    constructor(message?: string);
    get name(): string;
}


export declare class MongoServerError extends MongoError {
    
    errorResponse: ErrorDescription;
    codeName?: string;
    writeConcernError?: Document;
    errInfo?: Document;
    ok?: number;
    [key: string]: any;
    
    constructor(message: ErrorDescription);
    get name(): string;
}


export declare class MongoServerSelectionError extends MongoSystemError {
    
    constructor(message: string, reason: TopologyDescription);
    get name(): string;
}


export declare class MongoStalePrimaryError extends MongoRuntimeError {
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    get name(): string;
}


export declare class MongoSystemError extends MongoError {
    
    reason?: TopologyDescription;
    
    constructor(message: string, reason: TopologyDescription);
    get name(): string;
}


export declare class MongoTailableCursorError extends MongoAPIError {
    
    constructor(message?: string);
    get name(): string;
}


export declare class MongoTopologyClosedError extends MongoAPIError {
    
    constructor(message?: string);
    get name(): string;
}


export declare class MongoTransactionError extends MongoAPIError {
    
    constructor(message: string);
    get name(): string;
}


export declare class MongoUnexpectedServerResponseError extends MongoRuntimeError {
    
    constructor(message: string, options?: {
        cause?: Error;
    });
    get name(): string;
}


export declare class MongoWriteConcernError extends MongoServerError {
    
    result: Document;
    
    constructor(result: WriteConcernErrorResult);
    get name(): string;
}




export declare type MonitorEvents = {
    serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;
    serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;
    serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;
    resetServer(error?: MongoError): void;
    resetConnectionPool(): void;
    close(): void;
} & EventEmitterWithState;






export declare interface MonitorOptions extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {
    connectTimeoutMS: number;
    heartbeatFrequencyMS: number;
    minHeartbeatFrequencyMS: number;
    serverMonitoringMode: ServerMonitoringMode;
}




export declare type NestedPaths<Type, Depth extends number[]> = Depth['length'] extends 8 ? [] : Type extends string | number | bigint | boolean | Date | RegExp | Buffer | Uint8Array | ((...args: any[]) => any) | {
    _bsontype: string;
} ? [] : Type extends ReadonlyArray<infer ArrayType> ? [] | [number, ...NestedPaths<ArrayType, [...Depth, 1]>] : Type extends Map<string, any> ? [string] : Type extends object ? {
    [Key in Extract<keyof Type, string>]: Type[Key] extends Type ? [Key] : Type extends Type[Key] ? [Key] : Type[Key] extends ReadonlyArray<infer ArrayType> ? Type extends ArrayType ? [Key] : ArrayType extends Type ? [Key] : [
    Key,
    ...NestedPaths<Type[Key], [...Depth, 1]>
    ] : 
    [
    Key,
    ...NestedPaths<Type[Key], [...Depth, 1]>
    ] | [Key];
}[Extract<keyof Type, string>] : [];


export declare type NestedPathsOfType<TSchema, Type> = KeysOfAType<{
    [Property in Join<NestedPaths<TSchema, []>, '.'>]: PropertyType<TSchema, Property>;
}, Type>;


export declare type NonObjectIdLikeDocument = {
    [key in keyof ObjectIdLike]?: never;
} & Document;


export declare type NotAcceptedFields<TSchema, FieldType> = {
    readonly [key in KeysOfOtherType<TSchema, FieldType>]?: never;
};


export declare type NumericType = IntegerType | Decimal128 | Double;

export { ObjectId }


export declare type OIDCCallbackFunction = (params: OIDCCallbackParams) => Promise<OIDCResponse>;


export declare interface OIDCCallbackParams {
    
    username?: string;
    
    timeoutContext: AbortSignal;
    
    version: 1;
    
    idpInfo?: IdPInfo;
    
    refreshToken?: string;
    
    tokenAudience?: string;
}


export declare interface OIDCResponse {
    
    accessToken: string;
    
    expiresInSeconds?: number;
    
    refreshToken?: string;
}






export declare type OneOrMore<T> = T | ReadonlyArray<T>;


export declare type OnlyFieldsOfType<TSchema, FieldType = any, AssignableType = FieldType> = IsAny<TSchema[keyof TSchema], AssignableType extends FieldType ? Record<string, FieldType> : Record<string, AssignableType>, AcceptedFields<TSchema, FieldType, AssignableType> & NotAcceptedFields<TSchema, FieldType> & Record<string, AssignableType>>;






export declare interface OperationOptions extends BSONSerializeOptions {
    
    session?: ClientSession;
    willRetryWrite?: boolean;
    
    readPreference?: ReadPreferenceLike;
    
    omitReadPreference?: boolean;
    
    
    timeoutMS?: number;
}




export declare type OperationTime = Timestamp;














export declare type OptionalId<TSchema> = EnhancedOmit<TSchema, '_id'> & {
    _id?: InferIdType<TSchema>;
};


export declare type OptionalUnlessRequiredId<TSchema> = TSchema extends {
    _id: any;
} ? TSchema : OptionalId<TSchema>;


export declare class OrderedBulkOperation extends BulkOperationBase {
    
    addToOperationsList(batchType: BatchType, document: Document | UpdateStatement | DeleteStatement): this;
}


export declare interface PkFactory {
    createPk(): any;
}




export declare const ProfilingLevel: Readonly<{
    readonly off: "off";
    readonly slowOnly: "slow_only";
    readonly all: "all";
}>;


export declare type ProfilingLevel = (typeof ProfilingLevel)[keyof typeof ProfilingLevel];


export declare type ProfilingLevelOptions = CommandOperationOptions;


export declare type PropertyType<Type, Property extends string> = string extends Property ? unknown : Property extends keyof Type ? Type[Property] : Property extends `${number}` ? Type extends ReadonlyArray<infer ArrayType> ? ArrayType : unknown : Property extends `${infer Key}.${infer Rest}` ? Key extends `${number}` ? Type extends ReadonlyArray<infer ArrayType> ? PropertyType<ArrayType, Rest> : unknown : Key extends keyof Type ? Type[Key] extends Map<string, infer MapType> ? MapType : PropertyType<Type[Key], Rest> : unknown : unknown;


export declare interface ProxyOptions {
    proxyHost?: string;
    proxyPort?: number;
    proxyUsername?: string;
    proxyPassword?: string;
}


export declare type PullAllOperator<TSchema> = ({
    readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: TSchema[key];
} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
    readonly [key: string]: ReadonlyArray<any>;
};


export declare type PullOperator<TSchema> = ({
    readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: Partial<Flatten<TSchema[key]>> | FilterOperations<Flatten<TSchema[key]>>;
} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
    readonly [key: string]: FilterOperators<any> | any;
};


export declare type PushOperator<TSchema> = ({
    readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: Flatten<TSchema[key]> | ArrayOperator<Array<Flatten<TSchema[key]>>>;
} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
    readonly [key: string]: ArrayOperator<any> | any;
};


export declare interface RangeOptions {
    
    min?: any;
    
    max?: any;
    
    sparsity?: Long | bigint;
    
    trimFactor?: Int32 | number;
    precision?: number;
}


export declare class ReadConcern {
    level: ReadConcernLevel | string;
    
    constructor(level: ReadConcernLevel);
    
    static fromOptions(options?: {
        readConcern?: ReadConcernLike;
        level?: ReadConcernLevel;
    }): ReadConcern | undefined;
    static get MAJORITY(): 'majority';
    static get AVAILABLE(): 'available';
    static get LINEARIZABLE(): 'linearizable';
    static get SNAPSHOT(): 'snapshot';
    toJSON(): Document;
}


export declare const ReadConcernLevel: Readonly<{
    readonly local: "local";
    readonly majority: "majority";
    readonly linearizable: "linearizable";
    readonly available: "available";
    readonly snapshot: "snapshot";
}>;


export declare type ReadConcernLevel = (typeof ReadConcernLevel)[keyof typeof ReadConcernLevel];


export declare type ReadConcernLike = ReadConcern | {
    level: ReadConcernLevel;
} | ReadConcernLevel;


export declare class ReadPreference {
    mode: ReadPreferenceMode;
    tags?: TagSet[];
    hedge?: HedgeOptions;
    maxStalenessSeconds?: number;
    minWireVersion?: number;
    static PRIMARY: "primary";
    static PRIMARY_PREFERRED: "primaryPreferred";
    static SECONDARY: "secondary";
    static SECONDARY_PREFERRED: "secondaryPreferred";
    static NEAREST: "nearest";
    static primary: ReadPreference;
    static primaryPreferred: ReadPreference;
    static secondary: ReadPreference;
    static secondaryPreferred: ReadPreference;
    static nearest: ReadPreference;
    
    constructor(mode: ReadPreferenceMode, tags?: TagSet[], options?: ReadPreferenceOptions);
    get preference(): ReadPreferenceMode;
    static fromString(mode: string): ReadPreference;
    
    static fromOptions(options?: ReadPreferenceFromOptions): ReadPreference | undefined;
    
    static translate(options: ReadPreferenceLikeOptions): ReadPreferenceLikeOptions;
    
    static isValid(mode: string): boolean;
    
    isValid(mode?: string): boolean;
    
    secondaryOk(): boolean;
    
    equals(readPreference: ReadPreference): boolean;
    
    toJSON(): Document;
}


export declare interface ReadPreferenceFromOptions extends ReadPreferenceLikeOptions {
    session?: ClientSession;
    readPreferenceTags?: TagSet[];
    hedge?: HedgeOptions;
}


export declare type ReadPreferenceLike = ReadPreference | ReadPreferenceMode;


export declare interface ReadPreferenceLikeOptions extends ReadPreferenceOptions {
    readPreference?: ReadPreferenceLike | {
        mode?: ReadPreferenceMode;
        preference?: ReadPreferenceMode;
        tags?: TagSet[];
        maxStalenessSeconds?: number;
    };
}


export declare const ReadPreferenceMode: Readonly<{
    readonly primary: "primary";
    readonly primaryPreferred: "primaryPreferred";
    readonly secondary: "secondary";
    readonly secondaryPreferred: "secondaryPreferred";
    readonly nearest: "nearest";
}>;


export declare type ReadPreferenceMode = (typeof ReadPreferenceMode)[keyof typeof ReadPreferenceMode];


export declare interface ReadPreferenceOptions {
    
    maxStalenessSeconds?: number;
    
    hedge?: HedgeOptions;
}


export declare type RegExpOrString<T> = T extends string ? BSONRegExp | RegExp | T : T;


export declare type RemoveUserOptions = CommandOperationOptions;


export declare interface RenameOptions extends CommandOperationOptions {
    
    dropTarget?: boolean;
    
    new_collection?: boolean;
}


export declare interface ReplaceOneModel<TSchema extends Document = Document> {
    
    filter: Filter<TSchema>;
    
    replacement: WithoutId<TSchema>;
    
    collation?: CollationOptions;
    
    hint?: Hint;
    
    upsert?: boolean;
    
    sort?: Sort;
}


export declare interface ReplaceOptions extends CommandOperationOptions {
    
    bypassDocumentValidation?: boolean;
    
    collation?: CollationOptions;
    
    hint?: string | Document;
    
    upsert?: boolean;
    
    let?: Document;
    
    sort?: Sort;
}


export declare interface ResumeOptions {
    startAtOperationTime?: Timestamp;
    batchSize?: number;
    maxAwaitTimeMS?: number;
    collation?: CollationOptions;
    readPreference?: ReadPreference;
    resumeAfter?: ResumeToken;
    startAfter?: ResumeToken;
    fullDocument?: string;
}


export declare type ResumeToken = unknown;


export declare const ReturnDocument: Readonly<{
    readonly BEFORE: "before";
    readonly AFTER: "after";
}>;


export declare type ReturnDocument = (typeof ReturnDocument)[keyof typeof ReturnDocument];


export declare interface RootFilterOperators<TSchema> extends Document {
    $and?: Filter<TSchema>[];
    $nor?: Filter<TSchema>[];
    $or?: Filter<TSchema>[];
    $text?: {
        $search: string;
        $language?: string;
        $caseSensitive?: boolean;
        $diacriticSensitive?: boolean;
    };
    $where?: string | ((this: TSchema) => boolean);
    $comment?: string | Document;
}








export declare class RunCommandCursor extends AbstractCursor {
    readonly command: Readonly<Record<string, any>>;
    readonly getMoreOptions: {
        comment?: any;
        maxAwaitTimeMS?: number;
        batchSize?: number;
    };
    
    setComment(comment: any): this;
    
    setMaxTimeMS(maxTimeMS: number): this;
    
    setBatchSize(batchSize: number): this;
    
    clone(): never;
    
    withReadConcern(_: ReadConcernLike): never;
    
    addCursorFlag(_: string, __: boolean): never;
    
    maxTimeMS(_: number): never;
    
    batchSize(_: number): never;
    
    
    
    
}


export declare type RunCommandOptions = {
    
    session?: ClientSession;
    
    readPreference?: ReadPreferenceLike;
    
    timeoutMS?: number;
    
} & BSONSerializeOptions;


export declare type RunCursorCommandOptions = {
    readPreference?: ReadPreferenceLike;
    session?: ClientSession;
    
    timeoutMS?: number;
    
    timeoutMode?: CursorTimeoutMode;
    tailable?: boolean;
    awaitData?: boolean;
} & BSONSerializeOptions;


export declare type SchemaMember<T, V> = {
    [P in keyof T]?: V;
} | {
    [key: string]: V;
};


export declare interface SearchIndexDescription extends Document {
    
    name?: string;
    
    definition: Document;
    
    type?: string;
}


export declare interface SelectServerOptions {
    readPreference?: ReadPreferenceLike;
    
    serverSelectionTimeoutMS?: number;
    session?: ClientSession;
    operationName: string;
    previousServer?: ServerDescription;
    
}

export { serialize }






















export declare interface ServerApi {
    version: ServerApiVersion;
    strict?: boolean;
    deprecationErrors?: boolean;
}


export declare const ServerApiVersion: Readonly<{
    readonly v1: "1";
}>;


export declare type ServerApiVersion = (typeof ServerApiVersion)[keyof typeof ServerApiVersion];


export declare class ServerCapabilities {
    maxWireVersion: number;
    minWireVersion: number;
    constructor(hello: Document);
    get hasAggregationCursor(): boolean;
    get hasWriteCommands(): boolean;
    get hasTextSearch(): boolean;
    get hasAuthCommands(): boolean;
    get hasListCollectionsCommand(): boolean;
    get hasListIndexesCommand(): boolean;
    get supportsSnapshotReads(): boolean;
    get commandsTakeWriteConcern(): boolean;
    get commandsTakeCollation(): boolean;
}


export declare class ServerClosedEvent {
    
    topologyId: number;
    
    address: string;
    
    
}




export declare class ServerDescription {
    address: string;
    type: ServerType;
    hosts: string[];
    passives: string[];
    arbiters: string[];
    tags: TagSet;
    error: MongoError | null;
    topologyVersion: TopologyVersion | null;
    minWireVersion: number;
    maxWireVersion: number;
    roundTripTime: number;
    
    minRoundTripTime: number;
    lastUpdateTime: number;
    lastWriteDate: number;
    me: string | null;
    primary: string | null;
    setName: string | null;
    setVersion: number | null;
    electionId: ObjectId | null;
    logicalSessionTimeoutMinutes: number | null;
    
    maxMessageSizeBytes: number | null;
    
    maxWriteBatchSize: number | null;
    
    maxBsonObjectSize: number | null;
    
    iscryptd: boolean;
    $clusterTime?: ClusterTime;
    
    get hostAddress(): HostAddress;
    get allHosts(): string[];
    
    get isReadable(): boolean;
    
    get isDataBearing(): boolean;
    
    get isWritable(): boolean;
    get host(): string;
    get port(): number;
    
    equals(other?: ServerDescription | null): boolean;
}


export declare class ServerDescriptionChangedEvent {
    
    topologyId: number;
    
    address: string;
    
    previousDescription: ServerDescription;
    
    newDescription: ServerDescription;
    name: "serverDescriptionChanged";
    
}




export declare type ServerEvents = {
    serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;
    serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;
    serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;
    
    descriptionReceived(description: ServerDescription): void;
    closed(): void;
    ended(): void;
} & ConnectionPoolEvents & EventEmitterWithState;


export declare class ServerHeartbeatFailedEvent {
    
    connectionId: string;
    
    duration: number;
    
    failure: Error;
    
    awaited: boolean;
    
    
}


export declare class ServerHeartbeatStartedEvent {
    
    connectionId: string;
    
    awaited: boolean;
    
    
}


export declare class ServerHeartbeatSucceededEvent {
    
    connectionId: string;
    
    duration: number;
    
    reply: Document;
    
    awaited: boolean;
    
    
}


export declare const ServerMonitoringMode: Readonly<{
    readonly auto: "auto";
    readonly poll: "poll";
    readonly stream: "stream";
}>;


export declare type ServerMonitoringMode = (typeof ServerMonitoringMode)[keyof typeof ServerMonitoringMode];


export declare class ServerOpeningEvent {
    
    topologyId: number;
    
    address: string;
    
    
}




















export declare class ServerSession {
    id: ServerSessionId;
    lastUse: number;
    txnNumber: number;
    isDirty: boolean;
    
    
    hasTimedOut(sessionTimeoutMinutes: number): boolean;
}


export declare type ServerSessionId = {
    id: Binary;
};




export declare const ServerType: Readonly<{
    readonly Standalone: "Standalone";
    readonly Mongos: "Mongos";
    readonly PossiblePrimary: "PossiblePrimary";
    readonly RSPrimary: "RSPrimary";
    readonly RSSecondary: "RSSecondary";
    readonly RSArbiter: "RSArbiter";
    readonly RSOther: "RSOther";
    readonly RSGhost: "RSGhost";
    readonly Unknown: "Unknown";
    readonly LoadBalancer: "LoadBalancer";
}>;


export declare type ServerType = (typeof ServerType)[keyof typeof ServerType];


export declare type SetFields<TSchema> = ({
    readonly [key in KeysOfAType<TSchema, ReadonlyArray<any> | undefined>]?: OptionalId<Flatten<TSchema[key]>> | AddToSetOperators<Array<OptionalId<Flatten<TSchema[key]>>>>;
} & IsAny<TSchema[keyof TSchema], object, NotAcceptedFields<TSchema, ReadonlyArray<any> | undefined>>) & {
    readonly [key: string]: AddToSetOperators<any> | any;
};


export declare type SetProfilingLevelOptions = CommandOperationOptions;


export declare const SeverityLevel: Readonly<{
    readonly EMERGENCY: "emergency";
    readonly ALERT: "alert";
    readonly CRITICAL: "critical";
    readonly ERROR: "error";
    readonly WARNING: "warn";
    readonly NOTICE: "notice";
    readonly INFORMATIONAL: "info";
    readonly DEBUG: "debug";
    readonly TRACE: "trace";
    readonly OFF: "off";
}>;


export declare type SeverityLevel = (typeof SeverityLevel)[keyof typeof SeverityLevel];


export declare type Sort = string | Exclude<SortDirection, {
    readonly $meta: string;
}> | ReadonlyArray<string> | {
    readonly [key: string]: SortDirection;
} | ReadonlyMap<string, SortDirection> | ReadonlyArray<readonly [string, SortDirection]> | readonly [string, SortDirection];


export declare type SortDirection = 1 | -1 | 'asc' | 'desc' | 'ascending' | 'descending' | {
    readonly $meta: string;
};



export declare type SortDirectionForCmd = 1 | -1 | {
    $meta: string;
};


export declare type SortForCmd = Map<string, SortDirectionForCmd>;












export declare type Stream = Socket | TLSSocket;


export declare class StreamDescription {
    address: string;
    type: ServerType;
    minWireVersion?: number;
    maxWireVersion?: number;
    maxBsonObjectSize: number;
    maxMessageSizeBytes: number;
    maxWriteBatchSize: number;
    compressors: CompressorName[];
    compressor?: CompressorName;
    logicalSessionTimeoutMinutes?: number;
    loadBalanced: boolean;
    __nodejs_mock_server__?: boolean;
    zlibCompressionLevel?: number;
    serverConnectionId: bigint | null;
    hello: Document | null;
    constructor(address: string, options?: StreamDescriptionOptions);
    receiveResponse(response: Document | null): void;
    parseServerConnectionID(serverConnectionId: number | Double | bigint | Long): bigint;
}


export declare interface StreamDescriptionOptions {
    compressors?: CompressorName[];
    logicalSessionTimeoutMinutes?: number;
    loadBalanced: boolean;
}


export declare type StrictFilter<TSchema> = Partial<TSchema> | ({
    [Property in Join<NestedPaths<WithId<TSchema>, []>, '.'>]?: Condition<PropertyType<WithId<TSchema>, Property>>;
} & RootFilterOperators<WithId<TSchema>>);


export declare type StrictMatchKeysAndValues<TSchema> = Readonly<{
    [Property in Join<NestedPaths<TSchema, []>, '.'>]?: PropertyType<TSchema, Property>;
} & {
    [Property in `${NestedPathsOfType<TSchema, any[]>}.$${`[${string}]` | ''}`]?: ArrayElement<PropertyType<TSchema, Property extends `${infer Key}.$${string}` ? Key : never>>;
} & {
    [Property in `${NestedPathsOfType<TSchema, Record<string, any>[]>}.$${`[${string}]` | ''}.${string}`]?: any;
} & Document>;


export declare type StrictUpdateFilter<TSchema> = {
    $currentDate?: OnlyFieldsOfType<TSchema, Date | Timestamp, true | {
        $type: 'date' | 'timestamp';
    }>;
    $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;
    $min?: StrictMatchKeysAndValues<TSchema>;
    $max?: StrictMatchKeysAndValues<TSchema>;
    $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;
    $rename?: Record<string, string>;
    $set?: StrictMatchKeysAndValues<TSchema>;
    $setOnInsert?: StrictMatchKeysAndValues<TSchema>;
    $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;
    $addToSet?: SetFields<TSchema>;
    $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;
    $pull?: PullOperator<TSchema>;
    $push?: PushOperator<TSchema>;
    $pullAll?: PullAllOperator<TSchema>;
    $bit?: OnlyFieldsOfType<TSchema, NumericType | undefined, {
        and: IntegerType;
    } | {
        or: IntegerType;
    } | {
        xor: IntegerType;
    }>;
} & Document;


export declare type SupportedNodeConnectionOptions = SupportedTLSConnectionOptions & SupportedTLSSocketOptions & SupportedSocketOptions;


export declare type SupportedSocketOptions = Pick<TcpNetConnectOpts & {
    autoSelectFamily?: boolean;
    autoSelectFamilyAttemptTimeout?: number;
    
    keepAliveInitialDelay?: number;
}, (typeof LEGAL_TCP_SOCKET_OPTIONS)[number]>;


export declare type SupportedTLSConnectionOptions = Pick<ConnectionOptions_2 & {
    allowPartialTrustChain?: boolean;
}, (typeof LEGAL_TLS_SOCKET_OPTIONS)[number]>;


export declare type SupportedTLSSocketOptions = Pick<TLSSocketOptions, Extract<keyof TLSSocketOptions, (typeof LEGAL_TLS_SOCKET_OPTIONS)[number]>>;


export declare type TagSet = {
    [key: string]: string;
};








export declare interface TimeSeriesCollectionOptions extends Document {
    timeField: string;
    metaField?: string;
    granularity?: 'seconds' | 'minutes' | 'hours' | string;
    bucketMaxSpanSeconds?: number;
    bucketRoundingSeconds?: number;
}

export { Timestamp }












export declare class TopologyClosedEvent {
    
    topologyId: number;
    
    
}


export declare class TopologyDescription {
    type: TopologyType;
    setName: string | null;
    maxSetVersion: number | null;
    maxElectionId: ObjectId | null;
    servers: Map<string, ServerDescription>;
    stale: boolean;
    compatible: boolean;
    compatibilityError?: string;
    logicalSessionTimeoutMinutes: number | null;
    heartbeatFrequencyMS: number;
    localThresholdMS: number;
    commonWireVersion: number;
    
    constructor(topologyType: TopologyType, serverDescriptions?: Map<string, ServerDescription> | null, setName?: string | null, maxSetVersion?: number | null, maxElectionId?: ObjectId | null, commonWireVersion?: number | null, options?: TopologyDescriptionOptions | null);
    
    
    get error(): MongoError | null;
    
    get hasKnownServers(): boolean;
    
    get hasDataBearingServers(): boolean;
    
    
    toJSON(): Document;
}


export declare class TopologyDescriptionChangedEvent {
    
    topologyId: number;
    
    previousDescription: TopologyDescription;
    
    newDescription: TopologyDescription;
    
    
}


export declare interface TopologyDescriptionOptions {
    heartbeatFrequencyMS?: number;
    localThresholdMS?: number;
}


export declare type TopologyEvents = {
    
    serverOpening(event: ServerOpeningEvent): void;
    serverClosed(event: ServerClosedEvent): void;
    serverDescriptionChanged(event: ServerDescriptionChangedEvent): void;
    topologyClosed(event: TopologyClosedEvent): void;
    topologyOpening(event: TopologyOpeningEvent): void;
    topologyDescriptionChanged(event: TopologyDescriptionChangedEvent): void;
    error(error: Error): void;
    
    close(): void;
    timeout(): void;
} & Omit<ServerEvents, 'connect'> & ConnectionPoolEvents & ConnectionEvents & EventEmitterWithState;


export declare class TopologyOpeningEvent {
    
    topologyId: number;
    
    
}






export declare const TopologyType: Readonly<{
    readonly Single: "Single";
    readonly ReplicaSetNoPrimary: "ReplicaSetNoPrimary";
    readonly ReplicaSetWithPrimary: "ReplicaSetWithPrimary";
    readonly Sharded: "Sharded";
    readonly Unknown: "Unknown";
    readonly LoadBalanced: "LoadBalanced";
}>;


export declare type TopologyType = (typeof TopologyType)[keyof typeof TopologyType];


export declare interface TopologyVersion {
    processId: ObjectId;
    counter: Long;
}


export declare class Transaction {
    
    
    options: TransactionOptions;
    
    
    
    
    
    get recoveryToken(): Document | undefined;
    
    get isPinned(): boolean;
    
    get isStarting(): boolean;
    
    get isActive(): boolean;
    
    get isCommitted(): boolean;
    
    
    
}


export declare interface TransactionOptions extends Omit<CommandOperationOptions, 'timeoutMS'> {
    
    readConcern?: ReadConcernLike;
    
    writeConcern?: WriteConcern;
    
    readPreference?: ReadPreferenceLike;
    
    maxCommitTimeMS?: number;
}




export declare interface TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {
    addListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
    addListener(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;
    addListener(event: string | symbol, listener: GenericListener): this;
    on<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
    on(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;
    on(event: string | symbol, listener: GenericListener): this;
    once<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
    once(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;
    once(event: string | symbol, listener: GenericListener): this;
    removeListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
    removeListener(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;
    removeListener(event: string | symbol, listener: GenericListener): this;
    off<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
    off(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;
    off(event: string | symbol, listener: GenericListener): this;
    removeAllListeners<EventKey extends keyof Events>(event?: EventKey | CommonEvents | symbol | string): this;
    listeners<EventKey extends keyof Events>(event: EventKey | CommonEvents | symbol | string): Events[EventKey][];
    rawListeners<EventKey extends keyof Events>(event: EventKey | CommonEvents | symbol | string): Events[EventKey][];
    emit<EventKey extends keyof Events>(event: EventKey | symbol, ...args: Parameters<Events[EventKey]>): boolean;
    listenerCount<EventKey extends keyof Events>(type: EventKey | CommonEvents | symbol | string): number;
    prependListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
    prependListener(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;
    prependListener(event: string | symbol, listener: GenericListener): this;
    prependOnceListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
    prependOnceListener(event: CommonEvents, listener: (eventName: string | symbol, listener: GenericListener) => void): this;
    prependOnceListener(event: string | symbol, listener: GenericListener): this;
    eventNames(): string[];
    getMaxListeners(): number;
    setMaxListeners(n: number): this;
}


export declare class TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {
    
    
    
    
    
}


export declare class UnorderedBulkOperation extends BulkOperationBase {
    
    handleWriteError(writeResult: BulkWriteResult): void;
    addToOperationsList(batchType: BatchType, document: Document | UpdateStatement | DeleteStatement): this;
}


export declare interface UpdateDescription<TSchema extends Document = Document> {
    
    updatedFields?: Partial<TSchema>;
    
    removedFields?: string[];
    
    truncatedArrays?: Array<{
        
        field: string;
        
        newSize: number;
    }>;
    
    disambiguatedPaths?: Document;
}


export declare type UpdateFilter<TSchema> = {
    $currentDate?: OnlyFieldsOfType<TSchema, Date | Timestamp, true | {
        $type: 'date' | 'timestamp';
    }>;
    $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;
    $min?: MatchKeysAndValues<TSchema>;
    $max?: MatchKeysAndValues<TSchema>;
    $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;
    $rename?: Record<string, string>;
    $set?: MatchKeysAndValues<TSchema>;
    $setOnInsert?: MatchKeysAndValues<TSchema>;
    $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;
    $addToSet?: SetFields<TSchema>;
    $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;
    $pull?: PullOperator<TSchema>;
    $push?: PushOperator<TSchema>;
    $pullAll?: PullAllOperator<TSchema>;
    $bit?: OnlyFieldsOfType<TSchema, NumericType | undefined, {
        and: IntegerType;
    } | {
        or: IntegerType;
    } | {
        xor: IntegerType;
    }>;
} & Document;


export declare interface UpdateManyModel<TSchema extends Document = Document> {
    
    filter: Filter<TSchema>;
    
    update: UpdateFilter<TSchema> | Document[];
    
    arrayFilters?: Document[];
    
    collation?: CollationOptions;
    
    hint?: Hint;
    
    upsert?: boolean;
}


export declare interface UpdateOneModel<TSchema extends Document = Document> {
    
    filter: Filter<TSchema>;
    
    update: UpdateFilter<TSchema> | Document[];
    
    arrayFilters?: Document[];
    
    collation?: CollationOptions;
    
    hint?: Hint;
    
    upsert?: boolean;
    
    sort?: Sort;
}


export declare interface UpdateOptions extends CommandOperationOptions {
    
    arrayFilters?: Document[];
    
    bypassDocumentValidation?: boolean;
    
    collation?: CollationOptions;
    
    hint?: Hint;
    
    upsert?: boolean;
    
    let?: Document;
}


export declare interface UpdateResult<TSchema extends Document = Document> {
    
    acknowledged: boolean;
    
    matchedCount: number;
    
    modifiedCount: number;
    
    upsertedCount: number;
    
    upsertedId: InferIdType<TSchema> | null;
}


export declare interface UpdateStatement {
    
    q: Document;
    
    u: Document | Document[];
    
    upsert?: boolean;
    
    multi?: boolean;
    
    collation?: CollationOptions;
    
    arrayFilters?: Document[];
    
    hint?: Hint;
    
    sort?: SortForCmd;
}

export { UUID }


export declare interface ValidateCollectionOptions extends CommandOperationOptions {
    
    background?: boolean;
}


export declare type W = number | 'majority';










export declare type WithId<TSchema> = EnhancedOmit<TSchema, '_id'> & {
    _id: InferIdType<TSchema>;
};


export declare type WithoutId<TSchema> = Omit<TSchema, '_id'>;


export declare type WithSessionCallback<T = unknown> = (session: ClientSession) => Promise<T>;


export declare type WithTransactionCallback<T = any> = (session: ClientSession) => Promise<T>;




export declare class WriteConcern {
    
    readonly w?: W;
    
    readonly journal?: boolean;
    
    readonly wtimeoutMS?: number;
    
    wtimeout?: number;
    
    j?: boolean;
    
    fsync?: boolean | 1;
    
    constructor(w?: W, wtimeoutMS?: number, journal?: boolean, fsync?: boolean | 1);
    
    static apply(command: Document, writeConcern: WriteConcern): Document;
    
    static fromOptions(options?: WriteConcernOptions | WriteConcern | W, inherit?: WriteConcernOptions | WriteConcern): WriteConcern | undefined;
}


export declare class WriteConcernError {
    
    constructor(error: WriteConcernErrorData);
    
    get code(): number | undefined;
    
    get errmsg(): string | undefined;
    
    get errInfo(): Document | undefined;
    toJSON(): WriteConcernErrorData;
    toString(): string;
}


export declare interface WriteConcernErrorData {
    code: number;
    errmsg: string;
    errInfo?: Document;
}


export declare interface WriteConcernErrorResult {
    writeConcernError: {
        code: number;
        errmsg: string;
        codeName?: string;
        errInfo?: Document;
    };
    ok: number;
    code?: number;
    errorLabels?: string[];
    [x: string | number]: unknown;
}


export declare interface WriteConcernOptions {
    
    writeConcern?: WriteConcern | WriteConcernSettings;
}


export declare interface WriteConcernSettings {
    
    w?: W;
    
    wtimeoutMS?: number;
    
    journal?: boolean;
    
    j?: boolean;
    
    wtimeout?: number;
    
    fsync?: boolean | 1;
}


export declare class WriteError {
    err: BulkWriteOperationError;
    constructor(err: BulkWriteOperationError);
    
    get code(): number;
    
    get index(): number;
    
    get errmsg(): string | undefined;
    
    get errInfo(): Document | undefined;
    
    getOperation(): Document;
    toJSON(): {
        code: number;
        index: number;
        errmsg?: string;
        op: Document;
    };
    toString(): string;
}



export { }
