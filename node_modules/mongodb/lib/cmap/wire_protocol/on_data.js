"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onData = onData;
const utils_1 = require("../../utils");

function onData(emitter, { timeoutContext, signal }) {
    signal?.throwIfAborted();
    
    
    const unconsumedEvents = new utils_1.List();
    
    const unconsumedPromises = new utils_1.List();
    
    let error = null;
    
    let finished = false;
    const iterator = {
        next() {
            
            const value = unconsumedEvents.shift();
            if (value != null) {
                return Promise.resolve({ value, done: false });
            }
            
            
            
            if (error != null) {
                const p = Promise.reject(error);
                
                error = null;
                return p;
            }
            
            if (finished)
                return closeHandler();
            
            const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
            unconsumedPromises.push({ resolve, reject });
            return promise;
        },
        return() {
            return closeHandler();
        },
        throw(err) {
            errorHandler(err);
            return Promise.resolve({ value: undefined, done: true });
        },
        [Symbol.asyncIterator]() {
            return this;
        },
        
        async [Symbol.asyncDispose]() {
            await closeHandler();
        }
    };
    
    emitter.on('data', eventHandler);
    emitter.on('error', errorHandler);
    const abortListener = (0, utils_1.addAbortListener)(signal, function () {
        errorHandler(this.reason);
    });
    const timeoutForSocketRead = timeoutContext?.timeoutForSocketRead;
    timeoutForSocketRead?.throwIfExpired();
    timeoutForSocketRead?.then(undefined, errorHandler);
    return iterator;
    function eventHandler(value) {
        const promise = unconsumedPromises.shift();
        if (promise != null)
            promise.resolve({ value, done: false });
        else
            unconsumedEvents.push(value);
    }
    function errorHandler(err) {
        const promise = unconsumedPromises.shift();
        if (promise != null)
            promise.reject(err);
        else
            error = err;
        void closeHandler();
    }
    function closeHandler() {
        
        emitter.off('data', eventHandler);
        emitter.off('error', errorHandler);
        abortListener?.[utils_1.kDispose]();
        finished = true;
        timeoutForSocketRead?.clear();
        const doneResult = { value: undefined, done: finished };
        for (const promise of unconsumedPromises) {
            promise.resolve(doneResult);
        }
        return Promise.resolve(doneResult);
    }
}
