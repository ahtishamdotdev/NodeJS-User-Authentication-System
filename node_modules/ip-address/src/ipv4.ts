

import * as common from './common';
import * as constants from './v4/constants';
import { AddressError } from './address-error';


export class Address4 {
  address: string;
  addressMinusSuffix?: string;
  groups: number = constants.GROUPS;
  parsedAddress: string[] = [];
  parsedSubnet: string = '';
  subnet: string = '/32';
  subnetMask: number = 32;
  v4: boolean = true;

  constructor(address: string) {
    this.address = address;

    const subnet = constants.RE_SUBNET_STRING.exec(address);

    if (subnet) {
      this.parsedSubnet = subnet[0].replace('/', '');
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = `/${this.subnetMask}`;

      if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
        throw new AddressError('Invalid subnet mask.');
      }

      address = address.replace(constants.RE_SUBNET_STRING, '');
    }

    this.addressMinusSuffix = address;

    this.parsedAddress = this.parse(address);
  }

  static isValid(address: string): boolean {
    try {
      
      new Address4(address);

      return true;
    } catch (e) {
      return false;
    }
  }

  
  parse(address: string) {
    const groups = address.split('.');

    if (!address.match(constants.RE_ADDRESS)) {
      throw new AddressError('Invalid IPv4 address.');
    }

    return groups;
  }

  
  correctForm(): string {
    return this.parsedAddress.map((part) => parseInt(part, 10)).join('.');
  }

  
  isCorrect = common.isCorrect(constants.BITS);

  
  static fromHex(hex: string): Address4 {
    const padded = hex.replace(/:/g, '').padStart(8, '0');
    const groups = [];
    let i;

    for (i = 0; i < 8; i += 2) {
      const h = padded.slice(i, i + 2);

      groups.push(parseInt(h, 16));
    }

    return new Address4(groups.join('.'));
  }

  
  static fromInteger(integer: number): Address4 {
    return Address4.fromHex(integer.toString(16));
  }

  
  static fromArpa(arpaFormAddress: string): Address4 {
    
    const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, '');

    const address = leader.split('.').reverse().join('.');

    return new Address4(address);
  }

  
  toHex(): string {
    return this.parsedAddress.map((part) => common.stringToPaddedHex(part)).join(':');
  }

  
  toArray(): number[] {
    return this.parsedAddress.map((part) => parseInt(part, 10));
  }

  
  toGroup6(): string {
    const output = [];
    let i;

    for (i = 0; i < constants.GROUPS; i += 2) {
      output.push(
        `${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(
          this.parsedAddress[i + 1],
        )}`,
      );
    }

    return output.join(':');
  }

  
  bigInt(): bigint {
    return BigInt(`0x${this.parsedAddress.map((n) => common.stringToPaddedHex(n)).join('')}`);
  }

  
  _startAddress(): bigint {
    return BigInt(`0b${this.mask() + '0'.repeat(constants.BITS - this.subnetMask)}`);
  }

  
  startAddress(): Address4 {
    return Address4.fromBigInt(this._startAddress());
  }

  
  startAddressExclusive(): Address4 {
    const adjust = BigInt('1');
    return Address4.fromBigInt(this._startAddress() + adjust);
  }

  
  _endAddress(): bigint {
    return BigInt(`0b${this.mask() + '1'.repeat(constants.BITS - this.subnetMask)}`);
  }

  
  endAddress(): Address4 {
    return Address4.fromBigInt(this._endAddress());
  }

  
  endAddressExclusive(): Address4 {
    const adjust = BigInt('1');
    return Address4.fromBigInt(this._endAddress() - adjust);
  }

  
  static fromBigInt(bigInt: bigint): Address4 {
    return Address4.fromHex(bigInt.toString(16));
  }

  
  mask(mask?: number): string {
    if (mask === undefined) {
      mask = this.subnetMask;
    }

    return this.getBitsBase2(0, mask);
  }

  
  getBitsBase2(start: number, end: number): string {
    return this.binaryZeroPad().slice(start, end);
  }

  
  reverseForm(options?: common.ReverseFormOptions): string {
    if (!options) {
      options = {};
    }

    const reversed = this.correctForm().split('.').reverse().join('.');

    if (options.omitSuffix) {
      return reversed;
    }

    return `${reversed}.in-addr.arpa.`;
  }

  
  isInSubnet = common.isInSubnet;

  
  isMulticast(): boolean {
    return this.isInSubnet(new Address4('224.0.0.0/4'));
  }

  
  binaryZeroPad(): string {
    return this.bigInt().toString(2).padStart(constants.BITS, '0');
  }

  
  groupForV6(): string {
    const segments = this.parsedAddress;

    return this.address.replace(
      constants.RE_ADDRESS,
      `<span class="hover-group group-v4 group-6">${segments
        .slice(0, 2)
        .join('.')}</span>.<span class="hover-group group-v4 group-7">${segments
        .slice(2, 4)
        .join('.')}</span>`,
    );
  }
}
