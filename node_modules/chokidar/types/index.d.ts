



import * as fs from "fs";
import { EventEmitter } from "events";
import { Matcher } from 'anymatch';

export class FSWatcher extends EventEmitter implements fs.FSWatcher {
  options: WatchOptions;

  
  constructor(options?: WatchOptions);

  
  add(paths: string | ReadonlyArray<string>): this;

  
  unwatch(paths: string | ReadonlyArray<string>): this;

  
  getWatched(): {
    [directory: string]: string[];
  };

  
  close(): Promise<void>;

  on(event: 'add'|'addDir'|'change', listener: (path: string, stats?: fs.Stats) => void): this;

  on(event: 'all', listener: (eventName: 'add'|'addDir'|'change'|'unlink'|'unlinkDir', path: string, stats?: fs.Stats) => void): this;

  
  on(event: 'error', listener: (error: Error) => void): this;

  
  on(event: 'raw', listener: (eventName: string, path: string, details: any) => void): this;

  
  on(event: 'ready', listener: () => void): this;

  on(event: 'unlink'|'unlinkDir', listener: (path: string) => void): this;

  on(event: string, listener: (...args: any[]) => void): this;

  ref(): this;
  
  unref(): this;
}

export interface WatchOptions {
  
  persistent?: boolean;

  
  ignored?: Matcher;

  
  ignoreInitial?: boolean;

  
  followSymlinks?: boolean;

  
  cwd?: string;

  
  disableGlobbing?: boolean;

  
  usePolling?: boolean;

  
  useFsEvents?: boolean;

  
  alwaysStat?: boolean;

  
  depth?: number;

  
  interval?: number;

  
  binaryInterval?: number;

  
  ignorePermissionErrors?: boolean;

  
  atomic?: boolean | number;

  
  awaitWriteFinish?: AwaitWriteFinishOptions | boolean;
}

export interface AwaitWriteFinishOptions {
  
  stabilityThreshold?: number;

  
  pollInterval?: number;
}


export function watch(
  paths: string | ReadonlyArray<string>,
  options?: WatchOptions
): FSWatcher;
