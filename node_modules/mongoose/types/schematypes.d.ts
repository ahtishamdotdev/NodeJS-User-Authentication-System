import * as BSON from 'bson';

declare module 'mongoose' {

  
  type Date = Schema.Types.Date;

  
  type Decimal128 = Schema.Types.Decimal128;


  
  type Int32 = Schema.Types.Int32;

  
  type Mixed = Schema.Types.Mixed;

  
  type Number = Schema.Types.Number;


  
  type Double = Schema.Types.Double;

  
  type ObjectId = Schema.Types.ObjectId;

  
  const SchemaTypes: typeof Schema.Types;

  type DefaultType<T> = T extends Schema.Types.Mixed ? any : Partial<ExtractMongooseArray<T>>;

  class SchemaTypeOptions<T, EnforcedDocType = any, THydratedDocumentType = HydratedDocument<EnforcedDocType>> {
    type?:
    T extends string ? StringSchemaDefinition :
      T extends number ? NumberSchemaDefinition :
        T extends boolean ? BooleanSchemaDefinition :
          T extends NativeDate ? DateSchemaDefinition :
            T extends Map<any, any> ? SchemaDefinition<typeof Map> :
              T extends Buffer ? SchemaDefinition<typeof Buffer> :
                T extends Types.ObjectId ? ObjectIdSchemaDefinition :
                  T extends Types.ObjectId[] ? AnyArray<ObjectIdSchemaDefinition> | AnyArray<SchemaTypeOptions<ObjectId, EnforcedDocType, THydratedDocumentType>> :
                    T extends object[] ? (AnyArray<Schema<any, any, any>> | AnyArray<SchemaDefinition<Unpacked<T>>> | AnyArray<SchemaTypeOptions<Unpacked<T>, EnforcedDocType, THydratedDocumentType>>) :
                      T extends string[] ? AnyArray<StringSchemaDefinition> | AnyArray<SchemaTypeOptions<string, EnforcedDocType, THydratedDocumentType>> :
                        T extends number[] ? AnyArray<NumberSchemaDefinition> | AnyArray<SchemaTypeOptions<number, EnforcedDocType, THydratedDocumentType>> :
                          T extends boolean[] ? AnyArray<BooleanSchemaDefinition> | AnyArray<SchemaTypeOptions<boolean, EnforcedDocType, THydratedDocumentType>> :
                            T extends Function[] ? AnyArray<Function | string> | AnyArray<SchemaTypeOptions<Unpacked<T>, EnforcedDocType, THydratedDocumentType>> :
                              T | typeof SchemaType | Schema<any, any, any> | SchemaDefinition<T> | Function | AnyArray<Function>;

    
    alias?: string | string[];

    
    validate?: SchemaValidator<T, EnforcedDocType, THydratedDocumentType> | AnyArray<SchemaValidator<T, EnforcedDocType, THydratedDocumentType>>;

    
    cast?: string |
    boolean |
    ((value: any) => T) |
    [(value: any) => T, string] |
    [((value: any) => T) | null, (value: any, path: string, model: Model<any>, kind: string) => string];

    
    required?: boolean | ((this: EnforcedDocType) => boolean) | [boolean, string] | [(this: EnforcedDocType) => boolean, string];

    
    default?: DefaultType<T> | ((this: EnforcedDocType, doc: any) => DefaultType<T> | null | undefined) | null;

    
    ref?: string | Model<any> | ((this: any, doc: any) => string | Model<any>);

    

    refPath?: string | ((this: any, doc: any) => string);

    
    select?: boolean | number;

    
    index?: boolean | IndexDirection | IndexOptions;

    
    unique?: boolean | number | [true, string];

    
    immutable?: boolean | ((this: any, doc: any) => boolean);

    
    sparse?: boolean | number;

    
    text?: boolean | number | any;

    
    transform?: (this: any, val: T) => any;

    
    get?: (value: any, doc?: this) => T | undefined;

    
    set?: (value: any, priorVal?: T, doc?: this) => any;

    
    enum?: Array<string | number | null> | ReadonlyArray<string | number | null> | { values: Array<string | number | null> | ReadonlyArray<string | number | null>, message?: string } | { [path: string]: string | number | null };

    
    subtype?: number;

    
    min?: number | NativeDate | [number, string] | [NativeDate, string] | readonly [number, string] | readonly [NativeDate, string];

    
    max?: number | NativeDate | [number, string] | [NativeDate, string] | readonly [number, string] | readonly [NativeDate, string];

    
    minimize?: boolean;

    
    expires?: string | number;

    
    excludeIndexes?: boolean;

    
    _id?: boolean;

    
    of?: Function | SchemaDefinitionProperty<any>;

    
    auto?: boolean;

    
    match?: RegExp | [RegExp, string] | readonly [RegExp, string];

    
    lowercase?: boolean;

    
    trim?: boolean;

    
    uppercase?: boolean;

    
    minlength?: number | [number, string] | readonly [number, string];
    minLength?: number | [number, string] | readonly [number, string];

    
    maxlength?: number | [number, string] | readonly [number, string];
    maxLength?: number | [number, string] | readonly [number, string];

    [other: string]: any;

    
    encrypt?: EncryptSchemaTypeOptions;
  }

  interface Validator<DocType = any> {
    message?: string | ((props: ValidatorProps) => string);
    type?: string;
    validator?: ValidatorFunction<DocType>;
    reason?: Error;
  }

  type ValidatorFunction<DocType = any> = (this: DocType, value: any, validatorProperties?: Validator) => any;

  interface QueryEncryptionEncryptOptions {
    
    keyId: BSON.Binary;

    
    queries?: 'equality' | 'range';
  }

  interface ClientSideEncryptionEncryptOptions {
    
    keyId: [BSON.Binary];

    
    algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' | 'AEAD_AES_256_CBC_HMAC_SHA_512-Random';
  }

  export type EncryptSchemaTypeOptions = QueryEncryptionEncryptOptions | ClientSideEncryptionEncryptOptions;

  class SchemaType<T = any, DocType = any> {
    
    constructor(path: string, options?: AnyObject, instance?: string);

    
    static cast(caster?: Function | boolean): Function;

    static checkRequired(checkRequired?: (v: any) => boolean): (v: any) => boolean;

    
    static set(option: string, value: any): void;

    
    static get(getter: (value: any) => any): void;

    
    static setters: ((val?: unknown, priorVal?: unknown, doc?: Document<unknown>, options?: Record<string, any> | null) => unknown)[];

    
    $conditionalHandlers: { [op: string]: (val: any, context: any) => any };

    
    OptionsConstructor: SchemaTypeOptions<T>;

    
    cast(val: any, doc?: Document<any>, init?: boolean, prev?: any, options?: any): any;
    cast<ResultType>(val: any, doc?: Document<any>, init?: boolean, prev?: any, options?: any): ResultType;

    
    default(val: any): any;

    
    get(fn: Function): this;

    
    getEmbeddedSchemaType<T = any, DocType = any>(): SchemaType<T, DocType> | undefined;

    
    immutable(bool: boolean): this;

    
    index(options: any): this;

    
    instance: string;

    
    isRequired?: boolean;

    
    options: AnyObject;

    
    path: string;

    
    ref(ref: string | boolean | Model<any>): this;

    
    required(required: boolean, message?: string): this;

    
    schema: Schema<any>;

    
    select(val: boolean): this;

    
    set(fn: Function): this;

    
    sparse(bool: boolean): this;

    
    text(bool: boolean): this;

    toJSONSchema(options?: { useBsonType?: boolean }): Record<string, any>;

    
    transform(fn: (value: any) => any): this;

    
    unique(bool: boolean): this;

    
    validators: Validator[];

    
    validate(obj: RegExp | ValidatorFunction<DocType> | Validator<DocType>, errorMsg?: string, type?: string): this;

    
    validateAll(validators: Array<RegExp | ValidatorFunction<DocType> | Validator<DocType>>): this;

    
    static defaultOptions?: Record<string, any>;
  }

  namespace Schema {
    namespace Types {
      class Array extends SchemaType implements AcceptsDiscriminator {
        
        static schemaName: 'Array';

        static options: { castNonArrays: boolean; };

        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;
        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;

        
        caster?: SchemaType;

        
        static defaultOptions: Record<string, any>;

        
        enum(vals: string[] | number[]): this;
      }

      class BigInt extends SchemaType {
        
        static schemaName: 'BigInt';

        
        static defaultOptions: Record<string, any>;
      }

      class Boolean extends SchemaType {
        
        static schemaName: 'Boolean';

        
        static convertToTrue: Set<any>;

        
        static convertToFalse: Set<any>;

        
        static defaultOptions: Record<string, any>;
      }

      class Buffer extends SchemaType {
        
        static schemaName: 'Buffer';

        
        subtype(subtype: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 128): this;

        
        static defaultOptions: Record<string, any>;
      }

      class Date extends SchemaType {
        
        static schemaName: 'Date';

        
        expires(when: number | string): this;

        
        max(value: NativeDate, message?: string): this;

        
        min(value: NativeDate, message?: string): this;

        
        static defaultOptions: Record<string, any>;
      }

      class Decimal128 extends SchemaType {
        
        static schemaName: 'Decimal128';

        
        static defaultOptions: Record<string, any>;
      }

      class Int32 extends SchemaType {
        
        static schemaName: 'Int32';

        
        static defaultOptions: Record<string, any>;
      }

      class DocumentArray extends SchemaType implements AcceptsDiscriminator {
        
        static schemaName: 'DocumentArray';

        static options: { castNonArrays: boolean; };

        schemaOptions?: SchemaOptions;

        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;
        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;

        
        schema: Schema;

        
        caster?: typeof Types.Subdocument;

        
        static defaultOptions: Record<string, any>;
      }

      class Map extends SchemaType {
        
        static schemaName: 'Map';

        
        static defaultOptions: Record<string, any>;
      }

      class Mixed extends SchemaType {
        
        static schemaName: 'Mixed';

        
        static defaultOptions: Record<string, any>;
      }

      class Number extends SchemaType {
        
        static schemaName: 'Number';

        
        enum(vals: number[]): this;

        
        max(value: number, message?: string): this;

        
        min(value: number, message?: string): this;

        
        static defaultOptions: Record<string, any>;
      }

      class Double extends SchemaType {
        
        static schemaName: 'Double';

        
        static defaultOptions: Record<string, any>;
      }

      class ObjectId extends SchemaType {
        
        static schemaName: 'ObjectId';

        
        auto(turnOn: boolean): this;

        
        static defaultOptions: Record<string, any>;
      }

      class Subdocument<DocType = unknown> extends SchemaType implements AcceptsDiscriminator {
        
        static schemaName: string;

        
        schema: Schema;

        
        static defaultOptions: Record<string, any>;

        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;
        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;

        cast(val: any, doc?: Document<any>, init?: boolean, prev?: any, options?: any): HydratedSingleSubdocument<DocType>;
      }

      class String extends SchemaType {
        
        static schemaName: 'String';

        
        enum(vals: string[] | any): this;

        
        lowercase(shouldApply?: boolean): this;

        
        match(value: RegExp, message: string): this;

        
        maxlength(value: number, message: string): this;

        
        minlength(value: number, message: string): this;

        
        trim(shouldTrim?: boolean): this;

        
        uppercase(shouldApply?: boolean): this;

        
        static defaultOptions: Record<string, any>;
      }

      class UUID extends SchemaType {
        
        static schemaName: 'UUID';

        
        static defaultOptions: Record<string, any>;
      }
    }
  }
}
