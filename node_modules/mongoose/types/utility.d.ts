declare module 'mongoose' {
  type IfAny<IFTYPE, THENTYPE, ELSETYPE = IFTYPE> = 0 extends (1 & IFTYPE) ? THENTYPE : ELSETYPE;
  type IfUnknown<IFTYPE, THENTYPE> = unknown extends IFTYPE ? THENTYPE : IFTYPE;

  type WithLevel1NestedPaths<T, K extends keyof T = keyof T> = {
    [P in K | NestedPaths<Required<T>, K>]: P extends K
      
      
      ? Extract<NonNullable<T[P]>, Document> extends never
        
        ? NonNullable<T[P]>
        : Extract<NonNullable<T[P]>, Document> extends Document<any, any, infer DocType, any>
          ? DocType
          : never
      
      : P extends `${infer Key}.${infer Rest}`
        ? Key extends keyof T
          ? T[Key] extends (infer U)[]
            ? Rest extends keyof NonNullable<U>
              ? NonNullable<U>[Rest]
              : never
            : Rest extends keyof NonNullable<T[Key]>
              ? NonNullable<T[Key]>[Rest]
              : never
          : never
        : never;
  };

  type NestedPaths<T, K extends keyof T> = K extends string
    ? T[K] extends TreatAsPrimitives
      ? never
      : Extract<NonNullable<T[K]>, Document> extends never
          ? T[K] extends Array<infer U>
            ? U extends Record<string, any>
              ? `${K}.${keyof NonNullable<U> & string}`
              : never
            : T[K] extends Record<string, any> | null | undefined
              ? `${K}.${keyof NonNullable<T[K]> & string}`
              : never
          : Extract<NonNullable<T[K]>, Document> extends Document<any, any, infer DocType, any>
            ? DocType extends Record<string, any>
              ? `${K}.${keyof NonNullable<DocType> & string}`
              : never
            : never
    : never;

  type WithoutUndefined<T> = T extends undefined ? never : T;

  
  type ExcludeKeys<T, K extends keyof T> = {
    [P in keyof T as P extends K ? never : P]: T[P];
  };

  type Unpacked<T> = T extends (infer U)[] ?
    U :
    T extends ReadonlyArray<infer U> ? U : T;

  type UnpackedIntersection<T, U> = T extends null ? null : T extends (infer A)[]
    ? (Omit<A, keyof U> & U)[]
    : keyof U extends never
      ? T
      : Omit<T, keyof U> & U;

  type MergeType<A, B> = Omit<A, keyof B> & B;

  
  type FlatRecord<T> = { [K in keyof T]: T[K] };

  
  type IsItRecordAndNotAny<T> = IfEquals<T, any, false, T extends Record<any, any> ? true : false>;


type IfEquals<T, U, Y = true, N = false> =
    (<G>() => G extends T ? 1 : 0) extends
    (<G>() => G extends U ? 1 : 0) ? Y : N;


type ThisParameter<T, F> = T extends { (this: infer This): void }
  ? This
  : F;


type AddThisParameter<T, D> = {
  [K in keyof T]: T[K] extends (...args: infer A) => infer R
    ? ThisParameter<T[K], unknown> extends unknown
      ? (this: D, ...args: A) => R
      : T[K]
    : T[K];
};

  
  export type WithTimestamps<T, P extends SchemaTimestampsConfig | boolean = true> = ResolveTimestamps<T, { timestamps: P }>;
}
