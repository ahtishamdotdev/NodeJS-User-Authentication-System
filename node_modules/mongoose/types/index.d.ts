


























declare class NativeDate extends globalThis.Date { }

declare module 'mongoose' {
  import Kareem = require('kareem');
  import events = require('events');
  import mongodb = require('mongodb');
  import mongoose = require('mongoose');

  export type Mongoose = typeof mongoose;

  
  export const Mongoose: new (options?: MongooseOptions | null) => Mongoose;

  export let Promise: any;

  
  export interface Models {
    [modelName: string]: Model<any>
  }

  
  export const models: Models;

  
  export function deleteModel(name: string | RegExp): Mongoose;

  
  export function sanitizeFilter<T>(filter: FilterQuery<T>): FilterQuery<T>;

  
  export function get<K extends keyof MongooseOptions>(key: K): MongooseOptions[K];

  export function omitUndefined<T extends Record<string, any>>(val: T): T;

  
  export type CompileModelOptions = {
    overwriteModels?: boolean,
    connection?: Connection
  };

  export function model<TSchema extends Schema = any>(
    name: string,
    schema?: TSchema,
    collection?: string,
    options?: CompileModelOptions
  ): Model<
    InferSchemaType<TSchema>,
    ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
    ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
    ObtainSchemaGeneric<TSchema, 'TVirtuals'>,
    HydratedDocument<
      InferSchemaType<TSchema>,
      ObtainSchemaGeneric<TSchema, 'TVirtuals'> & ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
      ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
      ObtainSchemaGeneric<TSchema, 'TVirtuals'>,
      ObtainSchemaGeneric<TSchema, 'TSchemaOptions'>
    >,
    TSchema
  > & ObtainSchemaGeneric<TSchema, 'TStaticMethods'>;

  export function model<T>(name: string, schema?: Schema<T, any, any> | Schema<T & Document, any, any>, collection?: string, options?: CompileModelOptions): Model<T>;

  export function model<T, U, TQueryHelpers = {}>(
    name: string,
    schema?: Schema<T, any, any, TQueryHelpers, any, any, any>,
    collection?: string,
    options?: CompileModelOptions
  ): U;

  
  export function modelNames(): Array<string>;

  
  export function setDriver(driver: any): Mongoose;

  
  export { mongodb as mongo };

  
  export function plugin(fn: (schema: Schema, opts?: any) => void, opts?: any): Mongoose;

  
  export function pluralize(fn?: ((str: string) => string) | null): ((str: string) => string) | null;

  
  export function set<K extends keyof MongooseOptions>(key: K, value: MongooseOptions[K]): Mongoose;
  export function set(options: { [K in keyof MongooseOptions]: MongooseOptions[K] }): Mongoose;

  
  export const version: string;

  export type AnyKeys<T> = { [P in keyof T]?: T[P] | any };
  export interface AnyObject {
    [k: string]: any
  }

  export type Require_id<T> = T extends { _id?: infer U }
    ? IfAny<U, T & { _id: Types.ObjectId }, T & Required<{ _id: U }>>
    : T & { _id: Types.ObjectId };

  export type Default__v<T, TSchemaOptions = {}> = TSchemaOptions extends { versionKey: false }
    ? T
    : TSchemaOptions extends { versionKey: infer VK }
      ? (
          
          T & {
            [K in VK as K extends string
              ? (string extends K ? never : K) 
              : never
            ]: number
          }
        )
      : T extends { __v?: infer U }
        ? T
        : T & { __v: number };

  
  export type HydratedDocument<
    DocType,
    TOverrides = {},
    TQueryHelpers = {},
    TVirtuals = {},
    TSchemaOptions = {}
  > = IfAny<
    DocType,
    any,
    TOverrides extends Record<string, never> ?
      Document<unknown, TQueryHelpers, DocType, TVirtuals, TSchemaOptions> & Default__v<Require_id<DocType>, TSchemaOptions> :
      IfAny<
        TOverrides,
        Document<unknown, TQueryHelpers, DocType, TVirtuals, TSchemaOptions> & Default__v<Require_id<DocType>, TSchemaOptions>,
        Document<unknown, TQueryHelpers, DocType, TVirtuals, TSchemaOptions> & MergeType<
          Default__v<Require_id<DocType>, TSchemaOptions>,
          TOverrides
        >
      >
  >;
  export type HydratedSingleSubdocument<
    DocType,
    TOverrides = {}
  > = IfAny<
  DocType,
  any,
  TOverrides extends Record<string, never> ?
    Types.Subdocument<unknown, Record<string, never>, DocType> & Require_id<DocType> :
    IfAny<
      TOverrides,
      Types.Subdocument<unknown, Record<string, never>, DocType> & Require_id<DocType>,
      Types.Subdocument<unknown, Record<string, never>, DocType> & MergeType<
        Require_id<DocType>,
        TOverrides
      >
    >
  >;
  export type HydratedArraySubdocument<DocType, TOverrides = {}> = IfAny<
    DocType,
    any,
    TOverrides extends Record<string, never> ?
      Types.ArraySubdocument<unknown, Record<string, never>, DocType> & Require_id<DocType> :
      IfAny<
        TOverrides,
        Types.ArraySubdocument<unknown, Record<string, never>, DocType> & Require_id<DocType>,
        Types.ArraySubdocument<unknown, Record<string, never>, DocType> & MergeType<
          Require_id<DocType>,
          TOverrides
        >
      >
    >;

  export type HydratedDocumentFromSchema<TSchema extends Schema> = HydratedDocument<
    InferSchemaType<TSchema>,
    ObtainSchemaGeneric<TSchema, 'TInstanceMethods'> & ObtainSchemaGeneric<TSchema, 'TVirtuals'>,
    ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
    ObtainSchemaGeneric<TSchema, 'TVirtuals'>,
    ObtainSchemaGeneric<TSchema, 'TSchemaOptions'>
  >;

  export interface TagSet {
    [k: string]: string;
  }

  export interface ToObjectOptions<RawDocType = unknown, THydratedDocumentType = HydratedDocument<RawDocType>> {
    
    aliases?: boolean;
    
    depopulate?: boolean;
    
    flattenMaps?: boolean;
    
    flattenObjectIds?: boolean;
    
    getters?: boolean;
    
    minimize?: boolean;
    
    schemaFieldsOnly?: boolean;
    
    transform?: boolean | ((
      doc: THydratedDocumentType,
      ret: Default__v<Require_id<RawDocType>>,
      options: ToObjectOptions<THydratedDocumentType>
    ) => any);
    
    useProjection?: boolean;
    
    versionKey?: boolean;
    
    virtuals?: boolean | string[];
  }

  export type DiscriminatorModel<M, T> = T extends Model<infer T, infer TQueryHelpers, infer TInstanceMethods, infer TVirtuals>
    ?
    M extends Model<infer M, infer MQueryHelpers, infer MInstanceMethods, infer MVirtuals>
      ? Model<Omit<M, keyof T> & T, MQueryHelpers | TQueryHelpers, MInstanceMethods | TInstanceMethods, MVirtuals | TVirtuals>
      : M
    : M;

  export type DiscriminatorSchema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods, DisSchema> =
    DisSchema extends Schema<infer DisSchemaEDocType, infer DisSchemaM, infer DisSchemaInstanceMethods, infer DisSchemaQueryhelpers, infer DisSchemaVirtuals, infer DisSchemaStatics>
      ? Schema<MergeType<DocType, DisSchemaEDocType>, DiscriminatorModel<DisSchemaM, M>, DisSchemaInstanceMethods | TInstanceMethods, DisSchemaQueryhelpers | TQueryHelpers, DisSchemaVirtuals | TVirtuals, DisSchemaStatics & TStaticMethods>
      : Schema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods>;

  type QueryResultType<T> = T extends Query<infer ResultType, any> ? ResultType : never;

  type PluginFunction<
    DocType,
    M,
    TInstanceMethods,
    TQueryHelpers,
    TVirtuals,
    TStaticMethods> = (schema: Schema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods>, opts?: any) => void;

  export class Schema<
    RawDocType = any,
    TModelType = Model<RawDocType, any, any, any>,
    TInstanceMethods = {},
    TQueryHelpers = {},
    TVirtuals = {},
    TStaticMethods = {},
    TSchemaOptions = DefaultSchemaOptions,
    DocType extends ApplySchemaOptions<
      ObtainDocumentType<DocType, RawDocType, ResolveSchemaOptions<TSchemaOptions>>,
      ResolveSchemaOptions<TSchemaOptions>
    > = ApplySchemaOptions<
      ObtainDocumentType<any, RawDocType, ResolveSchemaOptions<TSchemaOptions>>,
      ResolveSchemaOptions<TSchemaOptions>
    >,
    THydratedDocumentType = HydratedDocument<FlatRecord<DocType>, TVirtuals & TInstanceMethods, {}, TVirtuals, ResolveSchemaOptions<TSchemaOptions>>
  >
    extends events.EventEmitter {
    
    constructor(
      definition?: SchemaDefinition<SchemaDefinitionType<RawDocType>, RawDocType, THydratedDocumentType> | DocType,
      options?: SchemaOptions<
        FlatRecord<DocType>,
        TInstanceMethods,
        TQueryHelpers,
        TStaticMethods,
        TVirtuals,
        THydratedDocumentType,
        IfEquals<
          TModelType,
          Model<any, any, any, any>,
          Model<DocType, TQueryHelpers, TInstanceMethods, TVirtuals, THydratedDocumentType>,
          TModelType
        >
      > | ResolveSchemaOptions<TSchemaOptions>
    );

    
    add(obj: SchemaDefinition<SchemaDefinitionType<RawDocType>, RawDocType> | Schema, prefix?: string): this;

    
    alias(path: string, alias: string | string[]): this;

    
    childSchemas: { schema: Schema, model: any }[];

    
    clearIndexes(): this;

    
    clone<T = this>(): T;

    discriminator<DisSchema = Schema>(name: string | number, schema: DisSchema, options?: DiscriminatorOptions): this;

    
    pick<T = this>(paths: string[], options?: SchemaOptions): T;

    
    discriminators?: { [name: string]: Schema };

    
    eachPath(fn: (path: string, type: SchemaType) => void): this;

    
    index(fields: IndexDefinition, options?: Omit<IndexOptions, 'unique'> & { unique?: boolean | [true, string] }): this;

    
    searchIndex(description: SearchIndexDescription): this;

    
    indexes(): Array<[IndexDefinition, IndexOptions]>;

    
    get<K extends keyof SchemaOptions>(key: K): SchemaOptions[K];

    
    loadClass(model: Function, onlyVirtuals?: boolean): this;

    
    method<Context = THydratedDocumentType>(name: string, fn: (this: Context, ...args: any[]) => any, opts?: any): this;
    method(obj: Partial<TInstanceMethods>): this;

    
    methods: AddThisParameter<TInstanceMethods, THydratedDocumentType> & AnyObject;

    
    obj: SchemaDefinition<SchemaDefinitionType<RawDocType>, RawDocType>;

    
    omit<T = this>(paths: string[], options?: SchemaOptions): T;

    options: SchemaOptions;

    
    path<ResultType extends SchemaType = SchemaType<any, THydratedDocumentType>>(path: string): ResultType;
    path<pathGeneric extends keyof RawDocType>(path: pathGeneric): SchemaType<RawDocType[pathGeneric]>;
    path(path: string, constructor: any): this;

    
    paths: {
      [key: string]: SchemaType;
    };

    
    pathType(path: string): string;

    
    plugin<PFunc extends PluginFunction<DocType, TModelType, any, any, any, any>, POptions extends Parameters<PFunc>[1] = Parameters<PFunc>[1]>(fn: PFunc, opts?: POptions): this;

    

    
    
    post<T = Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | RegExp, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;
    post<T = THydratedDocumentType>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;
    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T, Array<any>>): this;
    post<T = TModelType>(method: 'insertMany' | RegExp, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;

    
    post<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: false }, fn: PostMiddlewareFunction<never, never>): this;
    post<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions & { document: boolean, query: false }, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
    post<T = never>(method: MongooseDistinctDocumentMiddleware | MongooseDistinctDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: true }, fn: PostMiddlewareFunction<T, T>): this;
    
    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: PostMiddlewareFunction<T, T>): this;
    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions & SchemaPostOptions, fn: PostMiddlewareFunction<T, T>): this;
    post<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: true, query: false }, fn: PostMiddlewareFunction<T, T>): this;
    post<T = THydratedDocumentType>(method: 'init', fn: PostMiddlewareFunction<T, T>): this;

    
    post<T = Query<any, any>>(method: MongooseRawResultQueryMiddleware|MongooseRawResultQueryMiddleware[], fn: PostMiddlewareFunction<T, null | QueryResultType<T> | ModifyResult<QueryResultType<T>>>): this;
    post<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
    post<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
    post<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: true }, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
    
    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: true, query: true }, fn: PostMiddlewareFunction<T, T|QueryResultType<T>>): this;
    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, fn: PostMiddlewareFunction<T, T|QueryResultType<T>>): this;

    
    
    post<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions & { document: boolean, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = never>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions & { document: false, query: boolean }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    
    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: true, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    
    post<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: true }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    
    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: true, query: true }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, fn: ErrorHandlingMiddlewareFunction<T>): this;

    
    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: PostMiddlewareFunction<T, Array<AggregateExtract<T>>>): this;
    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPostOptions, fn: PostMiddlewareFunction<T, Array<AggregateExtract<T>>>): this;
    post<T = TModelType>(method: 'insertMany' | RegExp, fn: PostMiddlewareFunction<T, T>): this;
    post<T = TModelType>(method: 'insertMany' | RegExp, options: SchemaPostOptions, fn: PostMiddlewareFunction<T, T>): this;

    
    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: ErrorHandlingMiddlewareFunction<T, Array<any>>): this;
    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T, Array<any>>): this;
    post<T = TModelType>(method: 'bulkWrite' | 'createCollection' | 'insertMany' | RegExp, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = TModelType>(method: 'bulkWrite' | 'createCollection' | 'insertMany' | RegExp, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;

    
    
    pre<T = never>(method: 'save', options: SchemaPreOptions & { document: false, query: boolean }, fn: PreSaveMiddlewareFunction<T>): this;
    pre<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: false, query: false }, fn: PreMiddlewareFunction<T>): this;
    pre<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPreOptions & { document: boolean, query: false }, fn: PreMiddlewareFunction<T>): this;
    pre<T = never>(method: MongooseDistinctDocumentMiddleware | MongooseDistinctDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: false, query: boolean }, fn: PreMiddlewareFunction<T>): this;
    
    pre<T = THydratedDocumentType | Query<any, any>>(
      method: MongooseQueryAndDocumentMiddleware | MongooseQueryAndDocumentMiddleware[] | RegExp,
      options: SchemaPreOptions & { document: true, query: true },
      fn: PreMiddlewareFunction<T>
    ): this;
    
    pre<T = THydratedDocumentType>(method: 'save', fn: PreSaveMiddlewareFunction<T>): this;
    pre<T = THydratedDocumentType, U = RawDocType>(method: 'init', fn: (this: T, doc: U) => void): this;
    pre<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: PreMiddlewareFunction<T>): this;
    pre<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;
    pre<T = THydratedDocumentType>(
      method: MongooseQueryAndDocumentMiddleware | MongooseQueryAndDocumentMiddleware[] | RegExp,
      options: SchemaPreOptions & { document: true },
      fn: PreMiddlewareFunction<T>
    ): this;
    pre<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: true, query: false }, fn: PreMiddlewareFunction<T>): this;
    
    pre<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: PreMiddlewareFunction<T>): this;
    pre<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;
    pre<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: false, query: true }, fn: PreMiddlewareFunction<T>): this;
    
    pre<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: true, query: true }, fn: PreMiddlewareFunction<T>): this;
    pre<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, fn: PreMiddlewareFunction<T>): this;
    
    pre<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: PreMiddlewareFunction<T>): this;
    
    pre<T = TModelType>(
      method: 'insertMany' | RegExp,
      fn: (
        this: T,
        next: (err?: CallbackError) => void,
        docs: any | Array<any>,
        options?: InsertManyOptions & { lean?: boolean }
      ) => void | Promise<void>
    ): this;
    
    pre<T = TModelType>(
      method: 'bulkWrite' | RegExp,
      fn: (
        this: T,
        next: (err?: CallbackError) => void,
        ops: Array<AnyBulkWriteOperation<any>>,
        options?: mongodb.BulkWriteOptions & MongooseBulkWriteOptions
      ) => void | Promise<void>
    ): this;
    
    pre<T = TModelType>(
      method: 'createCollection' | RegExp,
      fn: (
        this: T,
        next: (err?: CallbackError) => void,
        options?: mongodb.CreateCollectionOptions & Pick<SchemaOptions, 'expires'>
      ) => void | Promise<void>
    ): this;

    
    query: TQueryHelpers;

    
    queue(name: string, args: any[]): this;

    
    remove(paths: string | Array<string>): this;

    
    removeIndex(index: string | AnyObject): this;

    
    requiredPaths(invalidate?: boolean): string[];

    
    set<K extends keyof SchemaOptions>(key: K, value: SchemaOptions<DocType>[K], _tags?: any): this;

    
    static<K extends keyof TStaticMethods>(name: K, fn: TStaticMethods[K]): this;
    static(obj: { [F in keyof TStaticMethods]: TStaticMethods[F] } & { [name: string]: (this: TModelType, ...args: any[]) => any }): this;
    static(name: string, fn: (this: TModelType, ...args: any[]) => any): this;

    
    statics: { [F in keyof TStaticMethods]: TStaticMethods[F] } &
    { [name: string]: (this: TModelType, ...args: any[]) => unknown };

    toJSONSchema(options?: { useBsonType?: boolean }): Record<string, any>;

    
    virtual<T = THydratedDocumentType>(
      name: keyof TVirtuals | string,
      options?: VirtualTypeOptions<T, DocType>
    ): VirtualType<T>;

    
    virtuals: TVirtuals;

    
    virtualpath<T = THydratedDocumentType>(name: string): VirtualType<T> | null;

    static ObjectId: typeof Schema.Types.ObjectId;
  }

  export type NumberSchemaDefinition = typeof Number | 'number' | 'Number' | typeof Schema.Types.Number;
  export type StringSchemaDefinition = typeof String | 'string' | 'String' | typeof Schema.Types.String;
  export type BooleanSchemaDefinition = typeof Boolean | 'boolean' | 'Boolean' | typeof Schema.Types.Boolean;
  export type DateSchemaDefinition = DateConstructor | 'date' | 'Date' | typeof Schema.Types.Date;
  export type ObjectIdSchemaDefinition = 'ObjectId' | 'ObjectID' | typeof Schema.Types.ObjectId;

  export type SchemaDefinitionWithBuiltInClass<T> = T extends number
    ? NumberSchemaDefinition
    : T extends string
      ? StringSchemaDefinition
      : T extends boolean
        ? BooleanSchemaDefinition
        : T extends NativeDate
          ? DateSchemaDefinition
          : (Function | string);

  export type SchemaDefinitionProperty<T = undefined, EnforcedDocType = any, THydratedDocumentType = HydratedDocument<EnforcedDocType>> = SchemaDefinitionWithBuiltInClass<T>
    | SchemaTypeOptions<T extends undefined ? any : T, EnforcedDocType, THydratedDocumentType>
    | typeof SchemaType
    | Schema<any, any, any>
    | Schema<any, any, any>[]
    | SchemaTypeOptions<T extends undefined ? any : Unpacked<T>, EnforcedDocType, THydratedDocumentType>[]
    | Function[]
    | SchemaDefinition<T, EnforcedDocType, THydratedDocumentType>
    | SchemaDefinition<Unpacked<T>, EnforcedDocType, THydratedDocumentType>[]
    | typeof Schema.Types.Mixed
    | MixedSchemaTypeOptions<EnforcedDocType>;

  export type SchemaDefinition<T = undefined, EnforcedDocType = any, THydratedDocumentType = HydratedDocument<EnforcedDocType>> = T extends undefined
    ? { [path: string]: SchemaDefinitionProperty; }
    : { [path in keyof T]?: SchemaDefinitionProperty<T[path], EnforcedDocType, THydratedDocumentType>; };

  export type AnyArray<T> = T[] | ReadonlyArray<T>;
  export type ExtractMongooseArray<T> = T extends Types.Array<any> ? AnyArray<Unpacked<T>> : T;

  export interface MixedSchemaTypeOptions<EnforcedDocType> extends SchemaTypeOptions<Schema.Types.Mixed, EnforcedDocType> {
    type: typeof Schema.Types.Mixed;
  }

  export type RefType =
    | number
    | string
    | Buffer
    | undefined
    | Types.ObjectId
    | Types.Buffer
    | typeof Schema.Types.Number
    | typeof Schema.Types.String
    | typeof Schema.Types.Buffer
    | typeof Schema.Types.ObjectId
    | typeof Schema.Types.UUID;


  export type InferId<T> = mongodb.InferIdType<T>;

  export interface VirtualTypeOptions<HydratedDocType = Document, DocType = unknown> {
    
    ref?: string | Function;

    
    localField?: string | ((this: HydratedDocType, doc: HydratedDocType) => string);

    
    foreignField?: string | ((this: HydratedDocType, doc: HydratedDocType) => string);

    
    justOne?: boolean;

    
    getters?: boolean;

    
    count?: boolean;

    
    match?: FilterQuery<any> | ((doc: Record<string, any>, virtual?: this) => Record<string, any> | null);

    
    limit?: number;

    
    skip?: number;

    
    perDocumentLimit?: number;

    
    options?: QueryOptions<DocType> & { match?: AnyObject };

    
    applyToArray?: boolean;

    
    [extra: string]: any;
  }

  export class VirtualType<HydratedDocType> {
    
    applyGetters(value: any, doc: Document): any;

    
    applySetters(value: any, doc: Document): any;

    
    get<T = HydratedDocType>(fn: (this: T, value: any, virtualType: VirtualType<T>, doc: T) => any): this;

    
    set<T = HydratedDocType>(fn: (this: T, value: any, virtualType: VirtualType<T>, doc: T) => void): this;
  }

  export type ReturnsNewDoc = { new: true } | { returnOriginal: false } | { returnDocument: 'after' };

  type ArrayOperators = { $slice: number | [number, number]; $elemMatch?: never } | { $elemMatch: Record<string, any>; $slice?: never };
  
  type Projector<T, Element> = T extends Array<infer U>
    ? Projector<U, Element> | ArrayOperators
    : T extends TreatAsPrimitives
      ? Element
      : T extends Record<string, any>
        ? {
          [K in keyof T]?: T[K] extends Record<string, any> ? Projector<T[K], Element> | Element : Element;
        }
        : Element;
  type _IDType = { _id?: boolean | number };
  export type InclusionProjection<T> = IsItRecordAndNotAny<T> extends true
    ? Omit<Projector<WithLevel1NestedPaths<T>, boolean | number>, '_id'> & _IDType
    : AnyObject;
  export type ExclusionProjection<T> = IsItRecordAndNotAny<T> extends true
    ? Omit<Projector<WithLevel1NestedPaths<T>, false | 0>, '_id'> & _IDType
    : AnyObject;

  export type ProjectionType<T> = (InclusionProjection<T> & AnyObject)
    | (ExclusionProjection<T> & AnyObject)
    | string;
  export type SortValues = SortOrder;

  export type SortOrder = -1 | 1 | 'asc' | 'ascending' | 'desc' | 'descending';

  type _UpdateQuery<TSchema, AdditionalProperties = AnyObject> = {
    
    $currentDate?: AnyKeys<TSchema> & AdditionalProperties;
    $inc?: AnyKeys<TSchema> & AdditionalProperties;
    $min?: AnyKeys<TSchema> & AdditionalProperties;
    $max?: AnyKeys<TSchema> & AdditionalProperties;
    $mul?: AnyKeys<TSchema> & AdditionalProperties;
    $rename?: Record<string, string>;
    $set?: AnyKeys<TSchema> & AdditionalProperties;
    $setOnInsert?: AnyKeys<TSchema> & AdditionalProperties;
    $unset?: AnyKeys<TSchema> & AdditionalProperties;

    
    $addToSet?: AnyKeys<TSchema> & AdditionalProperties;
    $pop?: AnyKeys<TSchema> & AdditionalProperties;
    $pull?: AnyKeys<TSchema> & AdditionalProperties;
    $push?: AnyKeys<TSchema> & AdditionalProperties;
    $pullAll?: AnyKeys<TSchema> & AdditionalProperties;

    
    $bit?: AnyKeys<TSchema>;
  };

  export type UpdateWithAggregationPipeline = UpdateAggregationStage[];
  export type UpdateAggregationStage = { $addFields: any } |
  { $set: any } |
  { $project: any } |
  { $unset: any } |
  { $replaceRoot: any } |
  { $replaceWith: any };

  
  export type UpdateQuery<T> = AnyKeys<T> & _UpdateQuery<T> & AnyObject;

  
  export type UpdateQueryKnownOnly<T> = _UpdateQuery<T, {}>;

  export type FlattenMaps<T> = {
    [K in keyof T]: FlattenProperty<T[K]>;
  };

  export type BufferToBinaryProperty<T> = unknown extends Buffer
    ? T
    : T extends Buffer
      ? mongodb.Binary
      : T extends Types.DocumentArray<infer ItemType>
        ? Types.DocumentArray<BufferToBinary<ItemType>>
        : T extends Types.Subdocument<unknown, unknown, infer SubdocType>
          ? HydratedSingleSubdocument<BufferToBinary<SubdocType>>
          : BufferToBinary<T>;

  
   export type BufferToBinary<T> = unknown extends Buffer
     ? T
     : T extends Buffer
       ? mongodb.Binary
       : T extends Document
         ? T
         : T extends TreatAsPrimitives
           ? T
           : T extends Record<string, any>
             ? {
                 [K in keyof T]: BufferToBinaryProperty<T[K]>
               }
             : T;

  
  export type BufferToJSON<T> = unknown extends Buffer
    ? T
    : T extends Buffer
      ? { type: 'buffer', data: number[] }
      : T extends Document
        ? T
        : T extends TreatAsPrimitives
          ? T
          : T extends Record<string, any> ? {
            [K in keyof T]: T[K] extends Buffer
              ? { type: 'buffer', data: number[] }
              : T[K] extends Types.DocumentArray<infer ItemType>
                  ? Types.DocumentArray<BufferToBinary<ItemType>>
                  : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
                    ? HydratedSingleSubdocument<SubdocType>
                    : BufferToBinary<T[K]>;
          } : T;

  
  export type ObjectIdToString<T> = T extends mongodb.ObjectId
    ? string
    : T extends Document
      ? T
      : T extends TreatAsPrimitives
        ? T
        : T extends Record<string, any> ? {
          [K in keyof T]: T[K] extends mongodb.ObjectId
            ? string
            : T[K] extends Types.DocumentArray<infer ItemType>
                ? Types.DocumentArray<ObjectIdToString<ItemType>>
                : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
                  ? HydratedSingleSubdocument<ObjectIdToString<SubdocType>>
                  : ObjectIdToString<T[K]>;
        } : T;

  
  export type DateToString<T> = T extends NativeDate
    ? string
    : T extends Document
      ? T
        : T extends TreatAsPrimitives
        ? T
        : T extends Record<string, any> ? {
          [K in keyof T]: T[K] extends NativeDate
            ? string
            : T[K] extends (NativeDate | null | undefined)
              ? string | null | undefined
              : T[K] extends Types.DocumentArray<infer ItemType>
                  ? Types.DocumentArray<DateToString<ItemType>>
                  : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
                    ? HydratedSingleSubdocument<DateToString<SubdocType>>
                    : DateToString<T[K]>;
        } : T;

  
  export type SubdocsToPOJOs<T> = T extends Document
    ? T
    : T extends TreatAsPrimitives
      ? T
      : T extends Record<string, any> ? {
        [K in keyof T]: T[K] extends Types.DocumentArray<infer ItemType>
          ? ItemType[]
          : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
            ? SubdocType
            : SubdocsToPOJOs<T[K]>;
      } : T;

  export type JSONSerialized<T> = SubdocsToPOJOs<
    FlattenMaps<
      BufferToJSON<
        ObjectIdToString<
          DateToString<T>
        >
      >
    >
  >;

  
  type FlattenProperty<T> = T extends Map<any, infer V>
    ? Record<string, V> : T extends TreatAsPrimitives
      ? T : T extends Types.DocumentArray<infer ItemType>
        ? Types.DocumentArray<FlattenMaps<ItemType>> : FlattenMaps<T>;

  export type actualPrimitives = string | boolean | number | bigint | symbol | null | undefined;
  export type TreatAsPrimitives = actualPrimitives | NativeDate | RegExp | symbol | Error | BigInt | Types.ObjectId | Buffer | Function | mongodb.Binary | mongodb.ClientSession;

  export type SchemaDefinitionType<T> = T extends Document ? Omit<T, Exclude<keyof Document, '_id' | 'id' | '__v'>> : T;

  
  export class mquery { }

  export function overwriteMiddlewareResult(val: any): Kareem.OverwriteMiddlewareResult;

  export function skipMiddlewareFunction(val: any): Kareem.SkipWrappedFunction;

  export default mongoose;
}
