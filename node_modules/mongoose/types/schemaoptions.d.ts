declare module 'mongoose' {
  import mongodb = require('mongodb');

  interface SchemaTimestampsConfig {
    createdAt?: boolean | string;
    updatedAt?: boolean | string;
    currentTime?: () => (NativeDate | number);
  }

  type TypeKeyBaseType = string;

  type DefaultTypeKey = 'type';
  interface SchemaOptions<
    DocType = unknown,
    TInstanceMethods = {},
    QueryHelpers = {},
    TStaticMethods = {},
    TVirtuals = {},
    THydratedDocumentType = HydratedDocument<DocType, TInstanceMethods, QueryHelpers>,
    TModelType = Model<DocType, QueryHelpers, TInstanceMethods, TVirtuals, THydratedDocumentType>
  > {
    
    autoIndex?: boolean;
    
    autoSearchIndex?: boolean;
    
    autoCreate?: boolean;
    
    bufferCommands?: boolean;
    
    bufferTimeoutMS?: number;
    
    capped?: boolean | number | { size?: number; max?: number; autoIndexId?: boolean; };
    
    collation?: mongodb.CollationOptions;

    
    collectionOptions?: mongodb.CreateCollectionOptions;

    
    timeseries?: mongodb.TimeSeriesCollectionOptions;

    
    expireAfterSeconds?: number;

    
    expires?: number | string;

    
    collection?: string;
    
    discriminatorKey?: string;

    
    excludeIndexes?: boolean;
    
    id?: boolean;
    
    _id?: boolean;
    
    minimize?: boolean;
    
    optimisticConcurrency?: boolean | string[] | { exclude: string[] };
    
    pluginTags?: string[];
    
    read?: string;
    
    readConcern?: { level: 'local' | 'available' | 'majority' | 'snapshot' | 'linearizable' }
    
    writeConcern?: WriteConcern;
    
    safe?: boolean | { w?: number | string; wtimeout?: number; j?: boolean };
    
    shardKey?: Record<string, unknown>;
    
    strict?: boolean | 'throw';
    
    strictQuery?: boolean | 'throw';
    
    toJSON?: ToObjectOptions<DocType, THydratedDocumentType>;
    
    toObject?: ToObjectOptions<DocType, THydratedDocumentType>;
    
    typeKey?: string;

    
    validateBeforeSave?: boolean;
    
    validateModifiedOnly?: boolean;
    
    versionKey?: string | boolean;
    
    selectPopulatedPaths?: boolean;
    
    skipVersioning?: { [key: string]: boolean; };
    
    storeSubdocValidationError?: boolean;
    
    timestamps?: boolean | SchemaTimestampsConfig;

    
    suppressReservedKeysWarning?: boolean,

    
    statics?: IfEquals<
      TStaticMethods,
      {},
      { [name: string]: (this: TModelType, ...args: any[]) => unknown },
      AddThisParameter<TStaticMethods, TModelType>
    >

    
    methods?: IfEquals<
    TInstanceMethods,
    {},
    Record<any, (this: THydratedDocumentType, ...args: any) => unknown>,
    AddThisParameter<TInstanceMethods, THydratedDocumentType> & AnyObject
    >

    
    query?: IfEquals<
    QueryHelpers,
    {},
    Record<any, <T extends QueryWithHelpers<unknown, THydratedDocumentType, QueryHelpers, DocType>>(this: T, ...args: any) => T>,
    QueryHelpers
    >

    
    castNonArrays?: boolean;

    
    virtuals?: SchemaOptionsVirtualsPropertyType<DocType, TVirtuals, TInstanceMethods>,

    
    overwriteModels?: boolean;

    
    encryptionType?: 'csfle' | 'queryableEncryption';
  }

  interface DefaultSchemaOptions {
    typeKey: 'type';
    id: true;
    _id: true;
    timestamps: false;
    versionKey: '__v'
  }
}
