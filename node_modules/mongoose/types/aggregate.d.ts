declare module 'mongoose' {
  import mongodb = require('mongodb');

  
  type AggregateExtract<P> = P extends Aggregate<infer T> ? T : never;

  interface AggregateOptions extends Omit<mongodb.AggregateOptions & mongodb.Abortable, 'session'>, SessionOption {
    [key: string]: any;
  }

  class Aggregate<ResultType> implements SessionOperation {
    
    [Symbol.asyncIterator](): AsyncIterableIterator<Unpacked<ResultType>>;

    
    [Symbol.toStringTag]: string;

    options: AggregateOptions;

    
    addCursorFlag(flag: CursorFlag, value: boolean): this;

    
    addFields(arg: PipelineStage.AddFields['$addFields']): this;

    
    allowDiskUse(value: boolean): this;

    
    append(...args: PipelineStage[]): this;

    
    catch: Promise<ResultType>['catch'];

    
    collation(options: mongodb.CollationOptions): this;

    
    count(fieldName: PipelineStage.Count['$count']): this;

    
    densify(arg: PipelineStage.Densify['$densify']): this;

    
    cursor<DocType = any>(options?: Record<string, unknown>): Cursor<DocType>;


    
    exec(): Promise<ResultType>;

    
    explain(verbosity: mongodb.ExplainVerbosityLike): Promise<AnyObject>;
    explain(): Promise<AnyObject>;

    
    facet(options: PipelineStage.Facet['$facet']): this;

    
    fill(arg: PipelineStage.Fill['$fill']): this;

    
    finally: Promise<ResultType>['finally'];

    
    graphLookup(options: PipelineStage.GraphLookup['$graphLookup']): this;

    
    group(arg: PipelineStage.Group['$group']): this;

    
    hint(value: Record<string, unknown> | string): this;

    
    limit(num: PipelineStage.Limit['$limit']): this;

    
    lookup(options: PipelineStage.Lookup['$lookup']): this;

    
    match(arg: PipelineStage.Match['$match']): this;

    
    model(model: Model<any>): this;

    
    model(): Model<any>;

    
    near(arg: PipelineStage.GeoNear['$geoNear']): this;

    
    pipeline(): PipelineStage[];

    
    project(arg: PipelineStage.Project['$project'] | string): this;

    
    read(pref: mongodb.ReadPreferenceLike): this;

    
    readConcern(level: string): this;

    
    redact(expression: PipelineStage.Redact['$redact'], thenExpr: '$$DESCEND' | '$$PRUNE' | '$$KEEP' | AnyObject, elseExpr: '$$DESCEND' | '$$PRUNE' | '$$KEEP' | AnyObject): this;

    
    replaceRoot(newRoot: PipelineStage.ReplaceRoot['$replaceRoot']['newRoot'] | string): this;

    
    search(options: PipelineStage.Search['$search']): this;

    
    option(value: AggregateOptions): this;

    
    sample(arg: PipelineStage.Sample['$sample']['size']): this;

    
    session(session: mongodb.ClientSession | null): this;

    
    skip(num: PipelineStage.Skip['$skip']): this;

    
    sort(arg: string | Record<string, SortValues> | PipelineStage.Sort['$sort']): this;

    
    then: Promise<ResultType>['then'];

    
    sortByCount(arg: string | PipelineStage.SortByCount['$sortByCount']): this;

    
    unionWith(options: PipelineStage.UnionWith['$unionWith']): this;

    
    unwind(...args: PipelineStage.Unwind['$unwind'][]): this;
  }
}
