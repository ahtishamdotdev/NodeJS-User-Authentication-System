declare module 'mongoose' {
  import mongodb = require('mongodb');

  export type Condition<T> = T | QuerySelector<T | any> | any;

  
  type RootFilterQuery<T> = FilterQuery<T> | Query<any, any> | Types.ObjectId;

  type FilterQuery<T> = {
    [P in keyof T]?: Condition<T[P]>;
  } & RootQuerySelector<T> & { _id?: Condition<string>; };

  type MongooseBaseQueryOptionKeys =
    | 'context'
    | 'multipleCastError'
    | 'overwriteDiscriminatorKey'
    | 'overwriteImmutable'
    | 'populate'
    | 'runValidators'
    | 'sanitizeProjection'
    | 'sanitizeFilter'
    | 'schemaLevelProjections'
    | 'setDefaultsOnInsert'
    | 'strict'
    | 'strictQuery'
    | 'translateAliases';

  type MongooseBaseQueryOptions<DocType = unknown> = Pick<QueryOptions<DocType>, MongooseBaseQueryOptionKeys>;

  type MongooseUpdateQueryOptions<DocType = unknown> = Pick<QueryOptions<DocType>, MongooseBaseQueryOptionKeys | 'timestamps'>;

  type ProjectionFields<DocType> = { [Key in keyof DocType]?: any } & Record<string, any>;

  type QueryWithHelpers<
    ResultType,
    DocType,
    THelpers = {},
    RawDocType = DocType,
    QueryOp = 'find',
    TDocOverrides = Record<string, never>
  > = Query<ResultType, DocType, THelpers, RawDocType, QueryOp, TDocOverrides> & THelpers;

  type QuerySelector<T> = {
    
    $eq?: T;
    $gt?: T;
    $gte?: T;
    $in?: [T] extends AnyArray<any> ? Unpacked<T>[] : T[];
    $lt?: T;
    $lte?: T;
    $ne?: T;
    $nin?: [T] extends AnyArray<any> ? Unpacked<T>[] : T[];
    
    $not?: T extends string ? QuerySelector<T> | RegExp : QuerySelector<T>;
    
    
    $exists?: boolean;
    $type?: string | number;
    
    $expr?: any;
    $jsonSchema?: any;
    $mod?: T extends number ? [number, number] : never;
    $regex?: T extends string ? RegExp | string : never;
    $options?: T extends string ? string : never;
    
    
    $geoIntersects?: { $geometry: object };
    $geoWithin?: object;
    $near?: object;
    $nearSphere?: object;
    $maxDistance?: number;
    
    
    $all?: T extends AnyArray<any> ? any[] : never;
    $elemMatch?: T extends AnyArray<any> ? object : never;
    $size?: T extends AnyArray<any> ? number : never;
    
    $bitsAllClear?: number | mongodb.Binary | number[];
    $bitsAllSet?: number | mongodb.Binary | number[];
    $bitsAnyClear?: number | mongodb.Binary | number[];
    $bitsAnySet?: number | mongodb.Binary | number[];
  };

  type RootQuerySelector<T> = {
    
    $and?: Array<FilterQuery<T>>;
    
    $nor?: Array<FilterQuery<T>>;
    
    $or?: Array<FilterQuery<T>>;
    
    $text?: {
      $search: string;
      $language?: string;
      $caseSensitive?: boolean;
      $diacriticSensitive?: boolean;
    };
    
    $where?: string | Function;
    
    $comment?: string;
    $expr?: Record<string, any>;
    
    [key: string]: any;
  };

  interface QueryTimestampsConfig {
    createdAt?: boolean;
    updatedAt?: boolean;
  }

  interface QueryOptions<DocType = unknown> extends
    PopulateOption,
    SessionOption {
    arrayFilters?: { [key: string]: any }[];
    batchSize?: number;
    collation?: mongodb.CollationOptions;
    comment?: any;
    context?: string;
    explain?: mongodb.ExplainVerbosityLike;
    fields?: any | string;
    hint?: mongodb.Hint;
    
    lean?: boolean | Record<string, any>;
    limit?: number;
    maxTimeMS?: number;
    multi?: boolean;
    multipleCastError?: boolean;
    
    new?: boolean;

    overwriteDiscriminatorKey?: boolean;
    
    overwriteImmutable?: boolean;
    projection?: { [P in keyof DocType]?: number | string } | AnyObject | string;
    
    includeResultMetadata?: boolean;
    readPreference?: string | mongodb.ReadPreferenceMode;
    
    returnOriginal?: boolean;
    
    returnDocument?: 'before' | 'after';
    
    runValidators?: boolean;
    
    sanitizeProjection?: boolean;
    
    sanitizeFilter?: boolean;
    
    schemaLevelProjections?: boolean;
    setDefaultsOnInsert?: boolean;
    skip?: number;
    sort?: any;
    
    strict?: boolean | string;
    
    strictQuery?: boolean | 'throw';
    tailable?: number;
    
    timestamps?: boolean | QueryTimestampsConfig;
    
    translateAliases?: boolean;
    upsert?: boolean;
    useBigInt64?: boolean;
    writeConcern?: mongodb.WriteConcern;

    [other: string]: any;
  }

  type QueryOpThatReturnsDocument = 'find' | 'findOne' | 'findOneAndUpdate' | 'findOneAndReplace' | 'findOneAndDelete';

  type GetLeanResultType<RawDocType, ResultType, QueryOp> = QueryOp extends QueryOpThatReturnsDocument
    ? (ResultType extends any[] ? Default__v<Require_id<FlattenMaps<BufferToBinary<RawDocType>>>>[] : Default__v<Require_id<FlattenMaps<BufferToBinary<RawDocType>>>>)
    : ResultType;

  type MergePopulatePaths<RawDocType, ResultType, QueryOp, Paths, TQueryHelpers, TDocOverrides = Record<string, never>> = QueryOp extends QueryOpThatReturnsDocument
    ? ResultType extends null
      ? ResultType
      : ResultType extends (infer U)[]
        ? U extends Document
          ? HydratedDocument<MergeType<RawDocType, Paths>, TDocOverrides, TQueryHelpers>[]
          : (MergeType<U, Paths>)[]
        : ResultType extends Document
          ? HydratedDocument<MergeType<RawDocType, Paths>, TDocOverrides, TQueryHelpers>
          : MergeType<ResultType, Paths>
    : MergeType<ResultType, Paths>;

  class Query<ResultType, DocType, THelpers = {}, RawDocType = unknown, QueryOp = 'find', TDocOverrides = Record<string, never>> implements SessionOperation {
    _mongooseOptions: QueryOptions<DocType>;

    
    [Symbol.asyncIterator](): AsyncIterableIterator<Unpacked<ResultType>>;

    
    exec(): Promise<ResultType>;

    $where(argument: string | Function): QueryWithHelpers<
      DocType[],
      DocType,
      THelpers,
      RawDocType,
      QueryOp,
      TDocOverrides
    >;

    
    all(path: string, val: Array<any>): this;
    all(val: Array<any>): this;

    
    allowDiskUse(value: boolean): this;

    
    and(array: FilterQuery<RawDocType>[]): this;

    
    batchSize(val: number): this;

    
    box(lower: number[], upper: number[]): this;
    box(val: any): this;

    
    cast(model?: Model<any, THelpers> | null, obj?: any): any;

    
    catch: Promise<ResultType>['catch'];

    
    finally: Promise<ResultType>['finally'];

    
    [Symbol.toStringTag]: string;

    
    circle(path: string, area: any): this;
    circle(area: any): this;

    
    clone(): this;

    
    collation(value: mongodb.CollationOptions): this;

    
    comment(val: string): this;

    
    countDocuments(
      criteria?: RootFilterQuery<RawDocType>,
      options?: QueryOptions<DocType>
    ): QueryWithHelpers<number, DocType, THelpers, RawDocType, 'countDocuments', TDocOverrides>;

    
    cursor(options?: QueryOptions<DocType>): Cursor<Unpacked<ResultType>, QueryOptions<DocType>>;

    
    deleteMany(
      filter?: RootFilterQuery<RawDocType>,
      options?: QueryOptions<DocType>
    ): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'deleteMany', TDocOverrides>;
    deleteMany(filter: RootFilterQuery<RawDocType>): QueryWithHelpers<
      any,
      DocType,
      THelpers,
      RawDocType,
      'deleteMany',
      TDocOverrides
    >;
    deleteMany(): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'deleteMany', TDocOverrides>;

    
    deleteOne(
      filter?: RootFilterQuery<RawDocType>,
      options?: QueryOptions<DocType>
    ): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'deleteOne', TDocOverrides>;
    deleteOne(filter: RootFilterQuery<RawDocType>): QueryWithHelpers<
      any,
      DocType,
      THelpers,
      RawDocType,
      'deleteOne',
      TDocOverrides
    >;
    deleteOne(): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'deleteOne', TDocOverrides>;

    
    distinct<DocKey extends string, ResultType = unknown>(
      field: DocKey,
      filter?: RootFilterQuery<RawDocType>,
      options?: QueryOptions<DocType>
    ): QueryWithHelpers<
      Array<
        DocKey extends keyof WithLevel1NestedPaths<DocType>
          ? WithoutUndefined<Unpacked<WithLevel1NestedPaths<DocType>[DocKey]>>
          : ResultType
      >,
      DocType,
      THelpers,
      RawDocType,
      'distinct',
      TDocOverrides
    >;

    
    elemMatch<K = string>(path: K, val: any): this;
    elemMatch(val: Function | any): this;

    
    error(): NativeError | null;
    error(val: NativeError | null): this;

    
    equals(val: any): this;

    
    estimatedDocumentCount(options?: QueryOptions<DocType>): QueryWithHelpers<
      number,
      DocType,
      THelpers,
      RawDocType,
      'estimatedDocumentCount',
      TDocOverrides
    >;

    
    exists<K = string>(path: K, val: boolean): this;
    exists(val: boolean): this;

    
    explain(verbose?: mongodb.ExplainVerbosityLike): this;

    
    find(
      filter: RootFilterQuery<RawDocType>,
      projection?: ProjectionType<RawDocType> | null,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType, 'find', TDocOverrides>;
    find(
      filter: RootFilterQuery<RawDocType>,
      projection?: ProjectionType<RawDocType> | null
    ): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType, 'find', TDocOverrides>;
    find(
      filter: RootFilterQuery<RawDocType>
    ): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType, 'find', TDocOverrides>;
    find(): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType, 'find', TDocOverrides>;

    
    findOne(
      filter?: RootFilterQuery<RawDocType>,
      projection?: ProjectionType<RawDocType> | null,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TDocOverrides>;
    findOne(
      filter?: RootFilterQuery<RawDocType>,
      projection?: ProjectionType<RawDocType> | null
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TDocOverrides>;
    findOne(
      filter?: RootFilterQuery<RawDocType>
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TDocOverrides>;

    
    findOneAndDelete(
      filter?: RootFilterQuery<RawDocType>,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndDelete'>;

    
    findOneAndUpdate(
      filter: RootFilterQuery<RawDocType>,
      update: UpdateQuery<RawDocType>,
      options: QueryOptions<DocType> & { includeResultMetadata: true }
    ): QueryWithHelpers<ModifyResult<DocType>, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;
    findOneAndUpdate(
      filter: RootFilterQuery<RawDocType>,
      update: UpdateQuery<RawDocType>,
      options: QueryOptions<DocType> & { upsert: true } & ReturnsNewDoc
    ): QueryWithHelpers<DocType, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;
    findOneAndUpdate(
      filter: RootFilterQuery<RawDocType>,
      update: UpdateQuery<RawDocType>,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;
    findOneAndUpdate(
      update: UpdateQuery<RawDocType>
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;
    findOneAndUpdate(): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;

    
    findById(
      id: mongodb.ObjectId | any,
      projection?: ProjectionType<RawDocType> | null,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TDocOverrides>;
    findById(
      id: mongodb.ObjectId | any,
      projection?: ProjectionType<RawDocType> | null
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TDocOverrides>;
    findById(
      id: mongodb.ObjectId | any
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TDocOverrides>;

    
    findByIdAndDelete(
      id: mongodb.ObjectId | any,
      options: QueryOptions<DocType> & { includeResultMetadata: true }
    ): QueryWithHelpers<ModifyResult<DocType>, DocType, THelpers, RawDocType, 'findOneAndDelete', TDocOverrides>;
    findByIdAndDelete(
      id?: mongodb.ObjectId | any,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndDelete', TDocOverrides>;

    
    findByIdAndUpdate(
      id: mongodb.ObjectId | any,
      update: UpdateQuery<RawDocType>,
      options: QueryOptions<DocType> & { includeResultMetadata: true }
    ): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;
    findByIdAndUpdate(
      id: mongodb.ObjectId | any,
      update: UpdateQuery<RawDocType>,
      options: QueryOptions<DocType> & { upsert: true } & ReturnsNewDoc
    ): QueryWithHelpers<DocType, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;
    findByIdAndUpdate(
      id?: mongodb.ObjectId | any,
      update?: UpdateQuery<RawDocType>,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;
    findByIdAndUpdate(
      id: mongodb.ObjectId | any,
      update: UpdateQuery<RawDocType>
    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate', TDocOverrides>;

    
    geometry(object: { type: string, coordinates: any[] }): this;

    
    get(path: string): any;

    
    getFilter(): FilterQuery<RawDocType>;

    
    getOptions(): QueryOptions<DocType>;

    
    getPopulatedPaths(): Array<string>;

    
    getQuery(): FilterQuery<RawDocType>;

    
    getUpdate(): UpdateQuery<DocType> | UpdateWithAggregationPipeline | null;

    
    gt<K = string>(path: K, val: any): this;
    gt(val: number): this;

    
    gte<K = string>(path: K, val: any): this;
    gte(val: number): this;

    
    hint(val: any): this;

    
    in<K = string>(path: K, val: any[]): this;
    in(val: Array<any>): this;

    
    intersects(arg?: any): this;

    
    j(val: boolean | null): this;

    
    lean(
      val?: boolean | any
    ): QueryWithHelpers<
      ResultType extends null
        ? GetLeanResultType<RawDocType, ResultType, QueryOp> | null
        : GetLeanResultType<RawDocType, ResultType, QueryOp>,
      DocType,
      THelpers,
      RawDocType,
      QueryOp,
      TDocOverrides
      >;
    lean<LeanResultType>(
      val?: boolean | any
    ): QueryWithHelpers<
      ResultType extends null
        ? LeanResultType | null
        : LeanResultType,
      DocType,
      THelpers,
      RawDocType,
      QueryOp,
      TDocOverrides
      >;

    
    limit(val: number): this;

    
    lt<K = string>(path: K, val: any): this;
    lt(val: number): this;

    
    lte<K = string>(path: K, val: any): this;
    lte(val: number): this;

    
    transform<MappedType>(fn: (doc: ResultType) => MappedType): QueryWithHelpers<MappedType, DocType, THelpers, RawDocType, QueryOp, TDocOverrides>;

    
    maxDistance(path: string, val: number): this;
    maxDistance(val: number): this;

    
    maxTimeMS(ms: number): this;

    
    merge(source: RootFilterQuery<RawDocType>): this;

    
    mod<K = string>(path: K, val: number): this;
    mod(val: Array<number>): this;

    
    model: Model<any>; 

    
    mongooseOptions(val?: QueryOptions<DocType>): QueryOptions<DocType>;

    
    ne<K = string>(path: K, val: any): this;
    ne(val: any): this;

    
    near<K = string>(path: K, val: any): this;
    near(val: any): this;

    
    nin<K = string>(path: K, val: any[]): this;
    nin(val: Array<any>): this;

    
    nor(array: Array<FilterQuery<RawDocType>>): this;

    
    or(array: Array<FilterQuery<RawDocType>>): this;

    
    orFail(err?: NativeError | (() => NativeError)): QueryWithHelpers<NonNullable<ResultType>, DocType, THelpers, RawDocType, QueryOp, TDocOverrides>;

    
    polygon(path: string, ...coordinatePairs: number[][]): this;
    polygon(...coordinatePairs: number[][]): this;

    
    populate(
      path: string | string[],
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any
    ): QueryWithHelpers<
      ResultType,
      DocType,
      THelpers,
      RawDocType,
      QueryOp,
      TDocOverrides
    >;
    populate(
      options: PopulateOptions | (PopulateOptions | string)[]
    ): QueryWithHelpers<
      ResultType,
      DocType,
      THelpers,
      RawDocType,
      QueryOp,
      TDocOverrides
    >;
    populate<Paths>(
      path: string | string[],
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any
    ): QueryWithHelpers<
      MergePopulatePaths<RawDocType, ResultType, QueryOp, Paths, THelpers, TDocOverrides>,
      DocType,
      THelpers,
      UnpackedIntersection<RawDocType, Paths>,
      QueryOp,
      TDocOverrides
    >;
    populate<Paths>(
      options: PopulateOptions | (PopulateOptions | string)[]
    ): QueryWithHelpers<
      MergePopulatePaths<RawDocType, ResultType, QueryOp, Paths, THelpers, TDocOverrides>,
      DocType,
      THelpers,
      UnpackedIntersection<RawDocType, Paths>,
      QueryOp,
      TDocOverrides
    >;

    
    pre(fn: Function): this;

    
    post(fn: Function): this;

    
    projection(fields?: ProjectionFields<DocType> | string): ProjectionFields<DocType>;
    projection(fields: null): null;
    projection(): ProjectionFields<DocType> | null;

    
    read(mode: string | mongodb.ReadPreferenceMode, tags?: any[]): this;

    
    readConcern(level: string): this;

    
    regex<K = string>(path: K, val: RegExp): this;
    regex(val: string | RegExp): this;

    
    replaceOne(
      filter?: RootFilterQuery<RawDocType>,
      replacement?: DocType | AnyObject,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'replaceOne', TDocOverrides>;

    
    sanitizeProjection(value: boolean): this;

    
    schemaLevelProjections(value: boolean): this;

    
    select<RawDocTypeOverride extends { [P in keyof RawDocType]?: any } = {}>(
      arg: string | readonly string[] | Record<string, number | boolean | string | object>
    ): QueryWithHelpers<
      IfEquals<
        RawDocTypeOverride,
        {},
        ResultType,
        ResultType extends any[]
          ? ResultType extends HydratedDocument<any>[]
            ? HydratedDocument<RawDocTypeOverride>[]
            : RawDocTypeOverride[]
          : (ResultType extends HydratedDocument<any>
            ? HydratedDocument<RawDocTypeOverride>
            : RawDocTypeOverride) | (null extends ResultType ? null : never)
      >,
      DocType,
      THelpers,
      IfEquals<
        RawDocTypeOverride,
        {},
        RawDocType,
        RawDocTypeOverride
      >,
      QueryOp,
      TDocOverrides
    >;

    
    selected(): boolean;

    
    selectedExclusively(): boolean;

    
    selectedInclusively(): boolean;

    
    session(session: mongodb.ClientSession | null): this;

    
    set(path: string | Record<string, unknown>, value?: any): this;

    
    setOptions(options: QueryOptions<DocType>, overwrite?: boolean): this;

    
    setQuery(val: FilterQuery<RawDocType> | null): void;

    setUpdate(update: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline): void;

    
    size<K = string>(path: K, val: number): this;
    size(val: number): this;

    
    skip(val: number): this;

    
    slice(path: string, val: number | Array<number>): this;
    slice(val: number | Array<number>): this;

    
    sort(
      arg?: string | { [key: string]: SortOrder | { $meta: any } } | [string, SortOrder][] | undefined | null,
      options?: { override?: boolean }
    ): this;

    
    tailable(bool?: boolean, opts?: {
      numberOfRetries?: number;
      tailableRetryInterval?: number;
    }): this;

    
    then: Promise<ResultType>['then'];

    
    toConstructor<RetType = typeof Query>(): RetType;

    
    updateMany(
      filter: RootFilterQuery<RawDocType>,
      update: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType, 'updateMany', TDocOverrides>;
    updateMany(
      update: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline
    ): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType, 'updateMany', TDocOverrides>;

    
    updateOne(
      filter: RootFilterQuery<RawDocType>,
      update: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline,
      options?: QueryOptions<DocType> | null
    ): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType, 'updateOne', TDocOverrides>;
    updateOne(
      update: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline
    ): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType, 'updateOne', TDocOverrides>;

    
    w(val: string | number | null): this;

    
    where(path: string, val?: any): this;
    where(obj: object): this;
    where(): this;

    
    within(val?: any): this;

    
    wtimeout(ms: number): this;
  }
}
