declare module 'mongoose' {
  import mongodb = require('mongodb');
  import events = require('events');

  
  const connection: Connection;

  
  const connections: Connection[];

  
  function connect(uri: string, options?: ConnectOptions): Promise<Mongoose>;

  
  function createConnection(uri: string, options?: ConnectOptions): Connection;
  function createConnection(): Connection;

  function disconnect(): Promise<void>;

  
  enum ConnectionStates {
    disconnected = 0,
    connected = 1,
    connecting = 2,
    disconnecting = 3,
    uninitialized = 99,
  }

  
  const STATES: typeof ConnectionStates;

  interface ConnectOptions extends mongodb.MongoClientOptions {
    
    bufferCommands?: boolean;
    
    dbName?: string;
    
    user?: string;
    
    pass?: string;
    
    autoIndex?: boolean;
    
    autoCreate?: boolean;
    
    sanitizeFilter?: boolean;
  }

  export type AnyConnectionBulkWriteModel<TSchema extends AnyObject> = Omit<mongodb.ClientInsertOneModel<TSchema>, 'namespace'>
    | Omit<mongodb.ClientReplaceOneModel<TSchema>, 'namespace'>
    | Omit<mongodb.ClientUpdateOneModel<TSchema>, 'namespace'>
    | Omit<mongodb.ClientUpdateManyModel<TSchema>, 'namespace'>
    | Omit<mongodb.ClientDeleteOneModel<TSchema>, 'namespace'>
    | Omit<mongodb.ClientDeleteManyModel<TSchema>, 'namespace'>;

  export type ConnectionBulkWriteModel<SchemaMap extends Record<string, AnyObject> = Record<string, AnyObject>> = {
      [ModelName in keyof SchemaMap]: AnyConnectionBulkWriteModel<SchemaMap[ModelName]> & {
          model: ModelName;
      };
  }[keyof SchemaMap];

  export type BaseConnection = Connection;

  class Connection extends events.EventEmitter implements SessionStarter {
    
    aggregate<ResultType = unknown>(pipeline?: PipelineStage[] | null, options?: AggregateOptions): Aggregate<Array<ResultType>>;

    
    asPromise(): Promise<this>;

    
    base: Mongoose;

    bulkWrite<TSchemaMap extends Record<string, AnyObject>>(
      ops: Array<ConnectionBulkWriteModel<TSchemaMap>>,
      options: mongodb.ClientBulkWriteOptions & { ordered: false }
    ): Promise<mongodb.ClientBulkWriteResult & { mongoose?: { validationErrors: Error[], results: Array<Error | mongodb.WriteError | null> } }>;
    bulkWrite<TSchemaMap extends Record<string, AnyObject>>(
      ops: Array<ConnectionBulkWriteModel<TSchemaMap>>,
      options?: mongodb.ClientBulkWriteOptions
    ): Promise<mongodb.ClientBulkWriteResult>;

    
    close(force?: boolean): Promise<void>;

    
    destroy(force?: boolean): Promise<void>;

    
    collection<T extends AnyObject = AnyObject>(name: string, options?: mongodb.CreateCollectionOptions): Collection<T>;

    
    readonly collections: { [index: string]: Collection };

    
    readonly config: any;

    
    readonly db: mongodb.Db | undefined;

    
    createCollection<T extends AnyObject = AnyObject>(name: string, options?: mongodb.CreateCollectionOptions): Promise<mongodb.Collection<T>>;

    
    createCollections(continueOnError?: boolean): Promise<Record<string, Error | mongodb.Collection<any>>>;

    
    deleteModel(name: string | RegExp): this;

    
    dropCollection(collection: string): Promise<void>;

    
    dropDatabase(): Promise<void>;

    
    get(key: string): any;

    
    getClient(): mongodb.MongoClient;

    
    readonly host: string;

    
    readonly id: number;

    
    listCollections(): Promise<Pick<mongodb.CollectionInfo, 'name' | 'type'>[]>;

    
    listDatabases(): Promise<mongodb.ListDatabasesResult>;

    
    readonly models: Readonly<{ [index: string]: Model<any> }>;

    
    model<TSchema extends Schema = any>(
      name: string,
      schema?: TSchema,
      collection?: string,
      options?: CompileModelOptions
    ): Model<
    InferSchemaType<TSchema>,
    ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
    ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
    {},
    HydratedDocument<
    InferSchemaType<TSchema>,
    ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
    ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
    >,
    TSchema> & ObtainSchemaGeneric<TSchema, 'TStaticMethods'>;
    model<T, U, TQueryHelpers = {}>(
      name: string,
      schema?: Schema<T, any, any, TQueryHelpers, any, any, any>,
      collection?: string,
      options?: CompileModelOptions
    ): U;
    model<T>(name: string, schema?: Schema<T, any, any>, collection?: string, options?: CompileModelOptions): Model<T>;

    
    modelNames(): Array<string>;

    
    readonly name: string;

    
    openUri(uri: string, options?: ConnectOptions): Promise<Connection>;

    
    readonly pass: string;

    
    readonly port: number;

    
    plugin<S extends Schema = Schema, O = AnyObject>(fn: (schema: S, opts?: any) => void, opts?: O): Connection;

    
    plugins: Array<any>;

    
    readonly readyState: ConnectionStates;

    
    set(key: string, value: any): any;

    
    setClient(client: mongodb.MongoClient): this;

    
    startSession(options?: ClientSessionOptions): Promise<ClientSession>;

    
    syncIndexes(options?: SyncIndexesOptions): Promise<ConnectionSyncIndexesResult>;

    
    transaction<ReturnType = unknown>(fn: (session: mongodb.ClientSession) => Promise<ReturnType>, options?: mongodb.TransactionOptions): Promise<ReturnType>;

    
    useDb(name: string, options?: { useCache?: boolean, noListener?: boolean }): Connection;

    
    readonly user: string;

    
    watch<ResultType extends mongodb.Document = any>(pipeline?: Array<any>, options?: mongodb.ChangeStreamOptions): mongodb.ChangeStream<ResultType>;

    withSession<T = any>(executor: (session: ClientSession) => Promise<T>): Promise<T>;
  }

}
